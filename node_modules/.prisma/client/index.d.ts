
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model analyses
 * 
 */
export type analyses = $Result.DefaultSelection<Prisma.$analysesPayload>
/**
 * Model AnalysisQuota
 * 
 */
export type AnalysisQuota = $Result.DefaultSelection<Prisma.$AnalysisQuotaPayload>
/**
 * Model IAQuota
 * 
 */
export type IAQuota = $Result.DefaultSelection<Prisma.$IAQuotaPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model chat_messages
 * 
 */
export type chat_messages = $Result.DefaultSelection<Prisma.$chat_messagesPayload>
/**
 * Model game_moves
 * 
 */
export type game_moves = $Result.DefaultSelection<Prisma.$game_movesPayload>
/**
 * Model subscriptions
 * 
 */
export type subscriptions = $Result.DefaultSelection<Prisma.$subscriptionsPayload>
/**
 * Model tournament_participants
 * 
 */
export type tournament_participants = $Result.DefaultSelection<Prisma.$tournament_participantsPayload>
/**
 * Model tournament_matches
 * 
 */
export type tournament_matches = $Result.DefaultSelection<Prisma.$tournament_matchesPayload>
/**
 * Model tournaments
 * 
 */
export type tournaments = $Result.DefaultSelection<Prisma.$tournamentsPayload>
/**
 * Model user_analytics
 * 
 */
export type user_analytics = $Result.DefaultSelection<Prisma.$user_analyticsPayload>
/**
 * Model game_analyses
 * 
 */
export type game_analyses = $Result.DefaultSelection<Prisma.$game_analysesPayload>
/**
 * Model games
 * 
 */
export type games = $Result.DefaultSelection<Prisma.$gamesPayload>
/**
 * Model GameSession
 * 
 */
export type GameSession = $Result.DefaultSelection<Prisma.$GameSessionPayload>
/**
 * Model GameEvent
 * 
 */
export type GameEvent = $Result.DefaultSelection<Prisma.$GameEventPayload>
/**
 * Model matches
 * 
 */
export type matches = $Result.DefaultSelection<Prisma.$matchesPayload>
/**
 * Model user_learning_progress
 * 
 */
export type user_learning_progress = $Result.DefaultSelection<Prisma.$user_learning_progressPayload>
/**
 * Model user_achievements
 * 
 */
export type user_achievements = $Result.DefaultSelection<Prisma.$user_achievementsPayload>
/**
 * Model user_preferences
 * 
 */
export type user_preferences = $Result.DefaultSelection<Prisma.$user_preferencesPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model seasons
 * 
 */
export type seasons = $Result.DefaultSelection<Prisma.$seasonsPayload>
/**
 * Model user_season_stats
 * 
 */
export type user_season_stats = $Result.DefaultSelection<Prisma.$user_season_statsPayload>
/**
 * Model season_leaderboard
 * 
 */
export type season_leaderboard = $Result.DefaultSelection<Prisma.$season_leaderboardPayload>
/**
 * Model user_quota_history
 * 
 */
export type user_quota_history = $Result.DefaultSelection<Prisma.$user_quota_historyPayload>
/**
 * Model websocket_connections
 * 
 */
export type websocket_connections = $Result.DefaultSelection<Prisma.$websocket_connectionsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AnalysisType: {
  FULL: 'FULL',
  HINT: 'HINT',
  EVALUATE: 'EVALUATE'
};

export type AnalysisType = (typeof AnalysisType)[keyof typeof AnalysisType]


export const MessageType: {
  TEXT: 'TEXT',
  EMOJI: 'EMOJI',
  SYSTEM: 'SYSTEM'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const Player: {
  WHITE: 'WHITE',
  BLACK: 'BLACK'
};

export type Player = (typeof Player)[keyof typeof Player]


export const SubscriptionPlan: {
  FREE: 'FREE',
  PREMIUM: 'PREMIUM',
  VIP: 'VIP'
};

export type SubscriptionPlan = (typeof SubscriptionPlan)[keyof typeof SubscriptionPlan]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  CANCELLED: 'CANCELLED',
  PAST_DUE: 'PAST_DUE',
  UNPAID: 'UNPAID'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const TournamentMatchStatus: {
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type TournamentMatchStatus = (typeof TournamentMatchStatus)[keyof typeof TournamentMatchStatus]


export const TournamentStatus: {
  REGISTRATION: 'REGISTRATION',
  IN_PROGRESS: 'IN_PROGRESS',
  FINISHED: 'FINISHED',
  CANCELLED: 'CANCELLED'
};

export type TournamentStatus = (typeof TournamentStatus)[keyof typeof TournamentStatus]


export const GameMode: {
  AI_VS_PLAYER: 'AI_VS_PLAYER',
  PLAYER_VS_PLAYER: 'PLAYER_VS_PLAYER',
  TOURNAMENT: 'TOURNAMENT'
};

export type GameMode = (typeof GameMode)[keyof typeof GameMode]


export const GameStatus: {
  WAITING: 'WAITING',
  PLAYING: 'PLAYING',
  DRAW_PENDING: 'DRAW_PENDING',
  COMPLETED: 'COMPLETED',
  FINISHED: 'FINISHED',
  ABORTED: 'ABORTED'
};

export type GameStatus = (typeof GameStatus)[keyof typeof GameStatus]


export const TimeControlPreset: {
  BLITZ: 'BLITZ',
  NORMAL: 'NORMAL',
  LONG: 'LONG',
  CUSTOM: 'CUSTOM'
};

export type TimeControlPreset = (typeof TimeControlPreset)[keyof typeof TimeControlPreset]


export const ResignationType: {
  SINGLE: 'SINGLE',
  GAMMON: 'GAMMON',
  BACKGAMMON: 'BACKGAMMON'
};

export type ResignationType = (typeof ResignationType)[keyof typeof ResignationType]


export const MatchState: {
  IN_PROGRESS: 'IN_PROGRESS',
  FINISHED: 'FINISHED'
};

export type MatchState = (typeof MatchState)[keyof typeof MatchState]


export const SubscriptionType: {
  FREE: 'FREE',
  PREMIUM: 'PREMIUM',
  VIP: 'VIP'
};

export type SubscriptionType = (typeof SubscriptionType)[keyof typeof SubscriptionType]

}

export type AnalysisType = $Enums.AnalysisType

export const AnalysisType: typeof $Enums.AnalysisType

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

export type Player = $Enums.Player

export const Player: typeof $Enums.Player

export type SubscriptionPlan = $Enums.SubscriptionPlan

export const SubscriptionPlan: typeof $Enums.SubscriptionPlan

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type TournamentMatchStatus = $Enums.TournamentMatchStatus

export const TournamentMatchStatus: typeof $Enums.TournamentMatchStatus

export type TournamentStatus = $Enums.TournamentStatus

export const TournamentStatus: typeof $Enums.TournamentStatus

export type GameMode = $Enums.GameMode

export const GameMode: typeof $Enums.GameMode

export type GameStatus = $Enums.GameStatus

export const GameStatus: typeof $Enums.GameStatus

export type TimeControlPreset = $Enums.TimeControlPreset

export const TimeControlPreset: typeof $Enums.TimeControlPreset

export type ResignationType = $Enums.ResignationType

export const ResignationType: typeof $Enums.ResignationType

export type MatchState = $Enums.MatchState

export const MatchState: typeof $Enums.MatchState

export type SubscriptionType = $Enums.SubscriptionType

export const SubscriptionType: typeof $Enums.SubscriptionType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Analyses
 * const analyses = await prisma.analyses.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Analyses
   * const analyses = await prisma.analyses.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.analyses`: Exposes CRUD operations for the **analyses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Analyses
    * const analyses = await prisma.analyses.findMany()
    * ```
    */
  get analyses(): Prisma.analysesDelegate<ExtArgs>;

  /**
   * `prisma.analysisQuota`: Exposes CRUD operations for the **AnalysisQuota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalysisQuotas
    * const analysisQuotas = await prisma.analysisQuota.findMany()
    * ```
    */
  get analysisQuota(): Prisma.AnalysisQuotaDelegate<ExtArgs>;

  /**
   * `prisma.iAQuota`: Exposes CRUD operations for the **IAQuota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IAQuotas
    * const iAQuotas = await prisma.iAQuota.findMany()
    * ```
    */
  get iAQuota(): Prisma.IAQuotaDelegate<ExtArgs>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs>;

  /**
   * `prisma.chat_messages`: Exposes CRUD operations for the **chat_messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chat_messages
    * const chat_messages = await prisma.chat_messages.findMany()
    * ```
    */
  get chat_messages(): Prisma.chat_messagesDelegate<ExtArgs>;

  /**
   * `prisma.game_moves`: Exposes CRUD operations for the **game_moves** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Game_moves
    * const game_moves = await prisma.game_moves.findMany()
    * ```
    */
  get game_moves(): Prisma.game_movesDelegate<ExtArgs>;

  /**
   * `prisma.subscriptions`: Exposes CRUD operations for the **subscriptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscriptions.findMany()
    * ```
    */
  get subscriptions(): Prisma.subscriptionsDelegate<ExtArgs>;

  /**
   * `prisma.tournament_participants`: Exposes CRUD operations for the **tournament_participants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournament_participants
    * const tournament_participants = await prisma.tournament_participants.findMany()
    * ```
    */
  get tournament_participants(): Prisma.tournament_participantsDelegate<ExtArgs>;

  /**
   * `prisma.tournament_matches`: Exposes CRUD operations for the **tournament_matches** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournament_matches
    * const tournament_matches = await prisma.tournament_matches.findMany()
    * ```
    */
  get tournament_matches(): Prisma.tournament_matchesDelegate<ExtArgs>;

  /**
   * `prisma.tournaments`: Exposes CRUD operations for the **tournaments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournaments
    * const tournaments = await prisma.tournaments.findMany()
    * ```
    */
  get tournaments(): Prisma.tournamentsDelegate<ExtArgs>;

  /**
   * `prisma.user_analytics`: Exposes CRUD operations for the **user_analytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_analytics
    * const user_analytics = await prisma.user_analytics.findMany()
    * ```
    */
  get user_analytics(): Prisma.user_analyticsDelegate<ExtArgs>;

  /**
   * `prisma.game_analyses`: Exposes CRUD operations for the **game_analyses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Game_analyses
    * const game_analyses = await prisma.game_analyses.findMany()
    * ```
    */
  get game_analyses(): Prisma.game_analysesDelegate<ExtArgs>;

  /**
   * `prisma.games`: Exposes CRUD operations for the **games** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.games.findMany()
    * ```
    */
  get games(): Prisma.gamesDelegate<ExtArgs>;

  /**
   * `prisma.gameSession`: Exposes CRUD operations for the **GameSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameSessions
    * const gameSessions = await prisma.gameSession.findMany()
    * ```
    */
  get gameSession(): Prisma.GameSessionDelegate<ExtArgs>;

  /**
   * `prisma.gameEvent`: Exposes CRUD operations for the **GameEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameEvents
    * const gameEvents = await prisma.gameEvent.findMany()
    * ```
    */
  get gameEvent(): Prisma.GameEventDelegate<ExtArgs>;

  /**
   * `prisma.matches`: Exposes CRUD operations for the **matches** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matches
    * const matches = await prisma.matches.findMany()
    * ```
    */
  get matches(): Prisma.matchesDelegate<ExtArgs>;

  /**
   * `prisma.user_learning_progress`: Exposes CRUD operations for the **user_learning_progress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_learning_progresses
    * const user_learning_progresses = await prisma.user_learning_progress.findMany()
    * ```
    */
  get user_learning_progress(): Prisma.user_learning_progressDelegate<ExtArgs>;

  /**
   * `prisma.user_achievements`: Exposes CRUD operations for the **user_achievements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_achievements
    * const user_achievements = await prisma.user_achievements.findMany()
    * ```
    */
  get user_achievements(): Prisma.user_achievementsDelegate<ExtArgs>;

  /**
   * `prisma.user_preferences`: Exposes CRUD operations for the **user_preferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_preferences
    * const user_preferences = await prisma.user_preferences.findMany()
    * ```
    */
  get user_preferences(): Prisma.user_preferencesDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.seasons`: Exposes CRUD operations for the **seasons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seasons
    * const seasons = await prisma.seasons.findMany()
    * ```
    */
  get seasons(): Prisma.seasonsDelegate<ExtArgs>;

  /**
   * `prisma.user_season_stats`: Exposes CRUD operations for the **user_season_stats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_season_stats
    * const user_season_stats = await prisma.user_season_stats.findMany()
    * ```
    */
  get user_season_stats(): Prisma.user_season_statsDelegate<ExtArgs>;

  /**
   * `prisma.season_leaderboard`: Exposes CRUD operations for the **season_leaderboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Season_leaderboards
    * const season_leaderboards = await prisma.season_leaderboard.findMany()
    * ```
    */
  get season_leaderboard(): Prisma.season_leaderboardDelegate<ExtArgs>;

  /**
   * `prisma.user_quota_history`: Exposes CRUD operations for the **user_quota_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_quota_histories
    * const user_quota_histories = await prisma.user_quota_history.findMany()
    * ```
    */
  get user_quota_history(): Prisma.user_quota_historyDelegate<ExtArgs>;

  /**
   * `prisma.websocket_connections`: Exposes CRUD operations for the **websocket_connections** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Websocket_connections
    * const websocket_connections = await prisma.websocket_connections.findMany()
    * ```
    */
  get websocket_connections(): Prisma.websocket_connectionsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    analyses: 'analyses',
    AnalysisQuota: 'AnalysisQuota',
    IAQuota: 'IAQuota',
    UserSession: 'UserSession',
    chat_messages: 'chat_messages',
    game_moves: 'game_moves',
    subscriptions: 'subscriptions',
    tournament_participants: 'tournament_participants',
    tournament_matches: 'tournament_matches',
    tournaments: 'tournaments',
    user_analytics: 'user_analytics',
    game_analyses: 'game_analyses',
    games: 'games',
    GameSession: 'GameSession',
    GameEvent: 'GameEvent',
    matches: 'matches',
    user_learning_progress: 'user_learning_progress',
    user_achievements: 'user_achievements',
    user_preferences: 'user_preferences',
    users: 'users',
    seasons: 'seasons',
    user_season_stats: 'user_season_stats',
    season_leaderboard: 'season_leaderboard',
    user_quota_history: 'user_quota_history',
    websocket_connections: 'websocket_connections'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "analyses" | "analysisQuota" | "iAQuota" | "userSession" | "chat_messages" | "game_moves" | "subscriptions" | "tournament_participants" | "tournament_matches" | "tournaments" | "user_analytics" | "game_analyses" | "games" | "gameSession" | "gameEvent" | "matches" | "user_learning_progress" | "user_achievements" | "user_preferences" | "users" | "seasons" | "user_season_stats" | "season_leaderboard" | "user_quota_history" | "websocket_connections"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      analyses: {
        payload: Prisma.$analysesPayload<ExtArgs>
        fields: Prisma.analysesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.analysesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.analysesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload>
          }
          findFirst: {
            args: Prisma.analysesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.analysesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload>
          }
          findMany: {
            args: Prisma.analysesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload>[]
          }
          create: {
            args: Prisma.analysesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload>
          }
          createMany: {
            args: Prisma.analysesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.analysesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload>[]
          }
          delete: {
            args: Prisma.analysesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload>
          }
          update: {
            args: Prisma.analysesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload>
          }
          deleteMany: {
            args: Prisma.analysesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.analysesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.analysesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload>
          }
          aggregate: {
            args: Prisma.AnalysesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyses>
          }
          groupBy: {
            args: Prisma.analysesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalysesGroupByOutputType>[]
          }
          count: {
            args: Prisma.analysesCountArgs<ExtArgs>
            result: $Utils.Optional<AnalysesCountAggregateOutputType> | number
          }
        }
      }
      AnalysisQuota: {
        payload: Prisma.$AnalysisQuotaPayload<ExtArgs>
        fields: Prisma.AnalysisQuotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalysisQuotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalysisQuotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuotaPayload>
          }
          findFirst: {
            args: Prisma.AnalysisQuotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalysisQuotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuotaPayload>
          }
          findMany: {
            args: Prisma.AnalysisQuotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuotaPayload>[]
          }
          create: {
            args: Prisma.AnalysisQuotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuotaPayload>
          }
          createMany: {
            args: Prisma.AnalysisQuotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalysisQuotaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuotaPayload>[]
          }
          delete: {
            args: Prisma.AnalysisQuotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuotaPayload>
          }
          update: {
            args: Prisma.AnalysisQuotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuotaPayload>
          }
          deleteMany: {
            args: Prisma.AnalysisQuotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalysisQuotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnalysisQuotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuotaPayload>
          }
          aggregate: {
            args: Prisma.AnalysisQuotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalysisQuota>
          }
          groupBy: {
            args: Prisma.AnalysisQuotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalysisQuotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalysisQuotaCountArgs<ExtArgs>
            result: $Utils.Optional<AnalysisQuotaCountAggregateOutputType> | number
          }
        }
      }
      IAQuota: {
        payload: Prisma.$IAQuotaPayload<ExtArgs>
        fields: Prisma.IAQuotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IAQuotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IAQuotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IAQuotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IAQuotaPayload>
          }
          findFirst: {
            args: Prisma.IAQuotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IAQuotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IAQuotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IAQuotaPayload>
          }
          findMany: {
            args: Prisma.IAQuotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IAQuotaPayload>[]
          }
          create: {
            args: Prisma.IAQuotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IAQuotaPayload>
          }
          createMany: {
            args: Prisma.IAQuotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IAQuotaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IAQuotaPayload>[]
          }
          delete: {
            args: Prisma.IAQuotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IAQuotaPayload>
          }
          update: {
            args: Prisma.IAQuotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IAQuotaPayload>
          }
          deleteMany: {
            args: Prisma.IAQuotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IAQuotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IAQuotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IAQuotaPayload>
          }
          aggregate: {
            args: Prisma.IAQuotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIAQuota>
          }
          groupBy: {
            args: Prisma.IAQuotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<IAQuotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.IAQuotaCountArgs<ExtArgs>
            result: $Utils.Optional<IAQuotaCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      chat_messages: {
        payload: Prisma.$chat_messagesPayload<ExtArgs>
        fields: Prisma.chat_messagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chat_messagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chat_messagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          findFirst: {
            args: Prisma.chat_messagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chat_messagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          findMany: {
            args: Prisma.chat_messagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>[]
          }
          create: {
            args: Prisma.chat_messagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          createMany: {
            args: Prisma.chat_messagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chat_messagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>[]
          }
          delete: {
            args: Prisma.chat_messagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          update: {
            args: Prisma.chat_messagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          deleteMany: {
            args: Prisma.chat_messagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chat_messagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.chat_messagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          aggregate: {
            args: Prisma.Chat_messagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat_messages>
          }
          groupBy: {
            args: Prisma.chat_messagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Chat_messagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.chat_messagesCountArgs<ExtArgs>
            result: $Utils.Optional<Chat_messagesCountAggregateOutputType> | number
          }
        }
      }
      game_moves: {
        payload: Prisma.$game_movesPayload<ExtArgs>
        fields: Prisma.game_movesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.game_movesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.game_movesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload>
          }
          findFirst: {
            args: Prisma.game_movesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.game_movesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload>
          }
          findMany: {
            args: Prisma.game_movesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload>[]
          }
          create: {
            args: Prisma.game_movesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload>
          }
          createMany: {
            args: Prisma.game_movesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.game_movesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload>[]
          }
          delete: {
            args: Prisma.game_movesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload>
          }
          update: {
            args: Prisma.game_movesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload>
          }
          deleteMany: {
            args: Prisma.game_movesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.game_movesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.game_movesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload>
          }
          aggregate: {
            args: Prisma.Game_movesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame_moves>
          }
          groupBy: {
            args: Prisma.game_movesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Game_movesGroupByOutputType>[]
          }
          count: {
            args: Prisma.game_movesCountArgs<ExtArgs>
            result: $Utils.Optional<Game_movesCountAggregateOutputType> | number
          }
        }
      }
      subscriptions: {
        payload: Prisma.$subscriptionsPayload<ExtArgs>
        fields: Prisma.subscriptionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subscriptionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subscriptionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          findFirst: {
            args: Prisma.subscriptionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subscriptionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          findMany: {
            args: Prisma.subscriptionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>[]
          }
          create: {
            args: Prisma.subscriptionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          createMany: {
            args: Prisma.subscriptionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.subscriptionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>[]
          }
          delete: {
            args: Prisma.subscriptionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          update: {
            args: Prisma.subscriptionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          deleteMany: {
            args: Prisma.subscriptionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subscriptionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.subscriptionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptions>
          }
          groupBy: {
            args: Prisma.subscriptionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.subscriptionsCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionsCountAggregateOutputType> | number
          }
        }
      }
      tournament_participants: {
        payload: Prisma.$tournament_participantsPayload<ExtArgs>
        fields: Prisma.tournament_participantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tournament_participantsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tournament_participantsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload>
          }
          findFirst: {
            args: Prisma.tournament_participantsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tournament_participantsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload>
          }
          findMany: {
            args: Prisma.tournament_participantsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload>[]
          }
          create: {
            args: Prisma.tournament_participantsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload>
          }
          createMany: {
            args: Prisma.tournament_participantsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tournament_participantsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload>[]
          }
          delete: {
            args: Prisma.tournament_participantsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload>
          }
          update: {
            args: Prisma.tournament_participantsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload>
          }
          deleteMany: {
            args: Prisma.tournament_participantsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tournament_participantsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tournament_participantsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload>
          }
          aggregate: {
            args: Prisma.Tournament_participantsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournament_participants>
          }
          groupBy: {
            args: Prisma.tournament_participantsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tournament_participantsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tournament_participantsCountArgs<ExtArgs>
            result: $Utils.Optional<Tournament_participantsCountAggregateOutputType> | number
          }
        }
      }
      tournament_matches: {
        payload: Prisma.$tournament_matchesPayload<ExtArgs>
        fields: Prisma.tournament_matchesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tournament_matchesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_matchesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tournament_matchesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_matchesPayload>
          }
          findFirst: {
            args: Prisma.tournament_matchesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_matchesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tournament_matchesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_matchesPayload>
          }
          findMany: {
            args: Prisma.tournament_matchesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_matchesPayload>[]
          }
          create: {
            args: Prisma.tournament_matchesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_matchesPayload>
          }
          createMany: {
            args: Prisma.tournament_matchesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tournament_matchesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_matchesPayload>[]
          }
          delete: {
            args: Prisma.tournament_matchesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_matchesPayload>
          }
          update: {
            args: Prisma.tournament_matchesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_matchesPayload>
          }
          deleteMany: {
            args: Prisma.tournament_matchesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tournament_matchesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tournament_matchesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_matchesPayload>
          }
          aggregate: {
            args: Prisma.Tournament_matchesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournament_matches>
          }
          groupBy: {
            args: Prisma.tournament_matchesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tournament_matchesGroupByOutputType>[]
          }
          count: {
            args: Prisma.tournament_matchesCountArgs<ExtArgs>
            result: $Utils.Optional<Tournament_matchesCountAggregateOutputType> | number
          }
        }
      }
      tournaments: {
        payload: Prisma.$tournamentsPayload<ExtArgs>
        fields: Prisma.tournamentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tournamentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tournamentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>
          }
          findFirst: {
            args: Prisma.tournamentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tournamentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>
          }
          findMany: {
            args: Prisma.tournamentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>[]
          }
          create: {
            args: Prisma.tournamentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>
          }
          createMany: {
            args: Prisma.tournamentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tournamentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>[]
          }
          delete: {
            args: Prisma.tournamentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>
          }
          update: {
            args: Prisma.tournamentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>
          }
          deleteMany: {
            args: Prisma.tournamentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tournamentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tournamentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>
          }
          aggregate: {
            args: Prisma.TournamentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournaments>
          }
          groupBy: {
            args: Prisma.tournamentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tournamentsCountArgs<ExtArgs>
            result: $Utils.Optional<TournamentsCountAggregateOutputType> | number
          }
        }
      }
      user_analytics: {
        payload: Prisma.$user_analyticsPayload<ExtArgs>
        fields: Prisma.user_analyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_analyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_analyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>
          }
          findFirst: {
            args: Prisma.user_analyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_analyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>
          }
          findMany: {
            args: Prisma.user_analyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>[]
          }
          create: {
            args: Prisma.user_analyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>
          }
          createMany: {
            args: Prisma.user_analyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_analyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>[]
          }
          delete: {
            args: Prisma.user_analyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>
          }
          update: {
            args: Prisma.user_analyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>
          }
          deleteMany: {
            args: Prisma.user_analyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_analyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_analyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>
          }
          aggregate: {
            args: Prisma.User_analyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_analytics>
          }
          groupBy: {
            args: Prisma.user_analyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_analyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_analyticsCountArgs<ExtArgs>
            result: $Utils.Optional<User_analyticsCountAggregateOutputType> | number
          }
        }
      }
      game_analyses: {
        payload: Prisma.$game_analysesPayload<ExtArgs>
        fields: Prisma.game_analysesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.game_analysesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_analysesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.game_analysesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_analysesPayload>
          }
          findFirst: {
            args: Prisma.game_analysesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_analysesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.game_analysesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_analysesPayload>
          }
          findMany: {
            args: Prisma.game_analysesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_analysesPayload>[]
          }
          create: {
            args: Prisma.game_analysesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_analysesPayload>
          }
          createMany: {
            args: Prisma.game_analysesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.game_analysesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_analysesPayload>[]
          }
          delete: {
            args: Prisma.game_analysesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_analysesPayload>
          }
          update: {
            args: Prisma.game_analysesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_analysesPayload>
          }
          deleteMany: {
            args: Prisma.game_analysesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.game_analysesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.game_analysesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_analysesPayload>
          }
          aggregate: {
            args: Prisma.Game_analysesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame_analyses>
          }
          groupBy: {
            args: Prisma.game_analysesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Game_analysesGroupByOutputType>[]
          }
          count: {
            args: Prisma.game_analysesCountArgs<ExtArgs>
            result: $Utils.Optional<Game_analysesCountAggregateOutputType> | number
          }
        }
      }
      games: {
        payload: Prisma.$gamesPayload<ExtArgs>
        fields: Prisma.gamesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.gamesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.gamesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload>
          }
          findFirst: {
            args: Prisma.gamesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.gamesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload>
          }
          findMany: {
            args: Prisma.gamesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload>[]
          }
          create: {
            args: Prisma.gamesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload>
          }
          createMany: {
            args: Prisma.gamesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.gamesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload>[]
          }
          delete: {
            args: Prisma.gamesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload>
          }
          update: {
            args: Prisma.gamesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload>
          }
          deleteMany: {
            args: Prisma.gamesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.gamesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.gamesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload>
          }
          aggregate: {
            args: Prisma.GamesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGames>
          }
          groupBy: {
            args: Prisma.gamesGroupByArgs<ExtArgs>
            result: $Utils.Optional<GamesGroupByOutputType>[]
          }
          count: {
            args: Prisma.gamesCountArgs<ExtArgs>
            result: $Utils.Optional<GamesCountAggregateOutputType> | number
          }
        }
      }
      GameSession: {
        payload: Prisma.$GameSessionPayload<ExtArgs>
        fields: Prisma.GameSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          findFirst: {
            args: Prisma.GameSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          findMany: {
            args: Prisma.GameSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>[]
          }
          create: {
            args: Prisma.GameSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          createMany: {
            args: Prisma.GameSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>[]
          }
          delete: {
            args: Prisma.GameSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          update: {
            args: Prisma.GameSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          deleteMany: {
            args: Prisma.GameSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GameSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          aggregate: {
            args: Prisma.GameSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameSession>
          }
          groupBy: {
            args: Prisma.GameSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameSessionCountArgs<ExtArgs>
            result: $Utils.Optional<GameSessionCountAggregateOutputType> | number
          }
        }
      }
      GameEvent: {
        payload: Prisma.$GameEventPayload<ExtArgs>
        fields: Prisma.GameEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          findFirst: {
            args: Prisma.GameEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          findMany: {
            args: Prisma.GameEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>[]
          }
          create: {
            args: Prisma.GameEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          createMany: {
            args: Prisma.GameEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>[]
          }
          delete: {
            args: Prisma.GameEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          update: {
            args: Prisma.GameEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          deleteMany: {
            args: Prisma.GameEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GameEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          aggregate: {
            args: Prisma.GameEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameEvent>
          }
          groupBy: {
            args: Prisma.GameEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameEventCountArgs<ExtArgs>
            result: $Utils.Optional<GameEventCountAggregateOutputType> | number
          }
        }
      }
      matches: {
        payload: Prisma.$matchesPayload<ExtArgs>
        fields: Prisma.matchesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.matchesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$matchesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.matchesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$matchesPayload>
          }
          findFirst: {
            args: Prisma.matchesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$matchesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.matchesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$matchesPayload>
          }
          findMany: {
            args: Prisma.matchesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$matchesPayload>[]
          }
          create: {
            args: Prisma.matchesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$matchesPayload>
          }
          createMany: {
            args: Prisma.matchesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.matchesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$matchesPayload>[]
          }
          delete: {
            args: Prisma.matchesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$matchesPayload>
          }
          update: {
            args: Prisma.matchesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$matchesPayload>
          }
          deleteMany: {
            args: Prisma.matchesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.matchesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.matchesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$matchesPayload>
          }
          aggregate: {
            args: Prisma.MatchesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatches>
          }
          groupBy: {
            args: Prisma.matchesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchesGroupByOutputType>[]
          }
          count: {
            args: Prisma.matchesCountArgs<ExtArgs>
            result: $Utils.Optional<MatchesCountAggregateOutputType> | number
          }
        }
      }
      user_learning_progress: {
        payload: Prisma.$user_learning_progressPayload<ExtArgs>
        fields: Prisma.user_learning_progressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_learning_progressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_learning_progressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_learning_progressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_learning_progressPayload>
          }
          findFirst: {
            args: Prisma.user_learning_progressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_learning_progressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_learning_progressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_learning_progressPayload>
          }
          findMany: {
            args: Prisma.user_learning_progressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_learning_progressPayload>[]
          }
          create: {
            args: Prisma.user_learning_progressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_learning_progressPayload>
          }
          createMany: {
            args: Prisma.user_learning_progressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_learning_progressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_learning_progressPayload>[]
          }
          delete: {
            args: Prisma.user_learning_progressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_learning_progressPayload>
          }
          update: {
            args: Prisma.user_learning_progressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_learning_progressPayload>
          }
          deleteMany: {
            args: Prisma.user_learning_progressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_learning_progressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_learning_progressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_learning_progressPayload>
          }
          aggregate: {
            args: Prisma.User_learning_progressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_learning_progress>
          }
          groupBy: {
            args: Prisma.user_learning_progressGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_learning_progressGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_learning_progressCountArgs<ExtArgs>
            result: $Utils.Optional<User_learning_progressCountAggregateOutputType> | number
          }
        }
      }
      user_achievements: {
        payload: Prisma.$user_achievementsPayload<ExtArgs>
        fields: Prisma.user_achievementsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_achievementsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_achievementsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_achievementsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_achievementsPayload>
          }
          findFirst: {
            args: Prisma.user_achievementsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_achievementsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_achievementsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_achievementsPayload>
          }
          findMany: {
            args: Prisma.user_achievementsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_achievementsPayload>[]
          }
          create: {
            args: Prisma.user_achievementsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_achievementsPayload>
          }
          createMany: {
            args: Prisma.user_achievementsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_achievementsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_achievementsPayload>[]
          }
          delete: {
            args: Prisma.user_achievementsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_achievementsPayload>
          }
          update: {
            args: Prisma.user_achievementsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_achievementsPayload>
          }
          deleteMany: {
            args: Prisma.user_achievementsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_achievementsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_achievementsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_achievementsPayload>
          }
          aggregate: {
            args: Prisma.User_achievementsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_achievements>
          }
          groupBy: {
            args: Prisma.user_achievementsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_achievementsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_achievementsCountArgs<ExtArgs>
            result: $Utils.Optional<User_achievementsCountAggregateOutputType> | number
          }
        }
      }
      user_preferences: {
        payload: Prisma.$user_preferencesPayload<ExtArgs>
        fields: Prisma.user_preferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_preferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_preferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_preferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_preferencesPayload>
          }
          findFirst: {
            args: Prisma.user_preferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_preferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_preferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_preferencesPayload>
          }
          findMany: {
            args: Prisma.user_preferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_preferencesPayload>[]
          }
          create: {
            args: Prisma.user_preferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_preferencesPayload>
          }
          createMany: {
            args: Prisma.user_preferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_preferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_preferencesPayload>[]
          }
          delete: {
            args: Prisma.user_preferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_preferencesPayload>
          }
          update: {
            args: Prisma.user_preferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_preferencesPayload>
          }
          deleteMany: {
            args: Prisma.user_preferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_preferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_preferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_preferencesPayload>
          }
          aggregate: {
            args: Prisma.User_preferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_preferences>
          }
          groupBy: {
            args: Prisma.user_preferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_preferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_preferencesCountArgs<ExtArgs>
            result: $Utils.Optional<User_preferencesCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      seasons: {
        payload: Prisma.$seasonsPayload<ExtArgs>
        fields: Prisma.seasonsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.seasonsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seasonsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.seasonsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seasonsPayload>
          }
          findFirst: {
            args: Prisma.seasonsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seasonsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.seasonsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seasonsPayload>
          }
          findMany: {
            args: Prisma.seasonsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seasonsPayload>[]
          }
          create: {
            args: Prisma.seasonsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seasonsPayload>
          }
          createMany: {
            args: Prisma.seasonsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.seasonsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seasonsPayload>[]
          }
          delete: {
            args: Prisma.seasonsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seasonsPayload>
          }
          update: {
            args: Prisma.seasonsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seasonsPayload>
          }
          deleteMany: {
            args: Prisma.seasonsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.seasonsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.seasonsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seasonsPayload>
          }
          aggregate: {
            args: Prisma.SeasonsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeasons>
          }
          groupBy: {
            args: Prisma.seasonsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeasonsGroupByOutputType>[]
          }
          count: {
            args: Prisma.seasonsCountArgs<ExtArgs>
            result: $Utils.Optional<SeasonsCountAggregateOutputType> | number
          }
        }
      }
      user_season_stats: {
        payload: Prisma.$user_season_statsPayload<ExtArgs>
        fields: Prisma.user_season_statsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_season_statsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_season_statsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_season_statsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_season_statsPayload>
          }
          findFirst: {
            args: Prisma.user_season_statsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_season_statsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_season_statsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_season_statsPayload>
          }
          findMany: {
            args: Prisma.user_season_statsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_season_statsPayload>[]
          }
          create: {
            args: Prisma.user_season_statsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_season_statsPayload>
          }
          createMany: {
            args: Prisma.user_season_statsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_season_statsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_season_statsPayload>[]
          }
          delete: {
            args: Prisma.user_season_statsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_season_statsPayload>
          }
          update: {
            args: Prisma.user_season_statsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_season_statsPayload>
          }
          deleteMany: {
            args: Prisma.user_season_statsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_season_statsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_season_statsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_season_statsPayload>
          }
          aggregate: {
            args: Prisma.User_season_statsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_season_stats>
          }
          groupBy: {
            args: Prisma.user_season_statsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_season_statsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_season_statsCountArgs<ExtArgs>
            result: $Utils.Optional<User_season_statsCountAggregateOutputType> | number
          }
        }
      }
      season_leaderboard: {
        payload: Prisma.$season_leaderboardPayload<ExtArgs>
        fields: Prisma.season_leaderboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.season_leaderboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$season_leaderboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.season_leaderboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$season_leaderboardPayload>
          }
          findFirst: {
            args: Prisma.season_leaderboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$season_leaderboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.season_leaderboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$season_leaderboardPayload>
          }
          findMany: {
            args: Prisma.season_leaderboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$season_leaderboardPayload>[]
          }
          create: {
            args: Prisma.season_leaderboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$season_leaderboardPayload>
          }
          createMany: {
            args: Prisma.season_leaderboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.season_leaderboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$season_leaderboardPayload>[]
          }
          delete: {
            args: Prisma.season_leaderboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$season_leaderboardPayload>
          }
          update: {
            args: Prisma.season_leaderboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$season_leaderboardPayload>
          }
          deleteMany: {
            args: Prisma.season_leaderboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.season_leaderboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.season_leaderboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$season_leaderboardPayload>
          }
          aggregate: {
            args: Prisma.Season_leaderboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeason_leaderboard>
          }
          groupBy: {
            args: Prisma.season_leaderboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<Season_leaderboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.season_leaderboardCountArgs<ExtArgs>
            result: $Utils.Optional<Season_leaderboardCountAggregateOutputType> | number
          }
        }
      }
      user_quota_history: {
        payload: Prisma.$user_quota_historyPayload<ExtArgs>
        fields: Prisma.user_quota_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_quota_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quota_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_quota_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quota_historyPayload>
          }
          findFirst: {
            args: Prisma.user_quota_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quota_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_quota_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quota_historyPayload>
          }
          findMany: {
            args: Prisma.user_quota_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quota_historyPayload>[]
          }
          create: {
            args: Prisma.user_quota_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quota_historyPayload>
          }
          createMany: {
            args: Prisma.user_quota_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_quota_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quota_historyPayload>[]
          }
          delete: {
            args: Prisma.user_quota_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quota_historyPayload>
          }
          update: {
            args: Prisma.user_quota_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quota_historyPayload>
          }
          deleteMany: {
            args: Prisma.user_quota_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_quota_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_quota_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quota_historyPayload>
          }
          aggregate: {
            args: Prisma.User_quota_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_quota_history>
          }
          groupBy: {
            args: Prisma.user_quota_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_quota_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_quota_historyCountArgs<ExtArgs>
            result: $Utils.Optional<User_quota_historyCountAggregateOutputType> | number
          }
        }
      }
      websocket_connections: {
        payload: Prisma.$websocket_connectionsPayload<ExtArgs>
        fields: Prisma.websocket_connectionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.websocket_connectionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.websocket_connectionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload>
          }
          findFirst: {
            args: Prisma.websocket_connectionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.websocket_connectionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload>
          }
          findMany: {
            args: Prisma.websocket_connectionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload>[]
          }
          create: {
            args: Prisma.websocket_connectionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload>
          }
          createMany: {
            args: Prisma.websocket_connectionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.websocket_connectionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload>[]
          }
          delete: {
            args: Prisma.websocket_connectionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload>
          }
          update: {
            args: Prisma.websocket_connectionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload>
          }
          deleteMany: {
            args: Prisma.websocket_connectionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.websocket_connectionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.websocket_connectionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload>
          }
          aggregate: {
            args: Prisma.Websocket_connectionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebsocket_connections>
          }
          groupBy: {
            args: Prisma.websocket_connectionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Websocket_connectionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.websocket_connectionsCountArgs<ExtArgs>
            result: $Utils.Optional<Websocket_connectionsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Tournament_participantsCountOutputType
   */

  export type Tournament_participantsCountOutputType = {
    whiteMatches: number
    blackMatches: number
    wonMatches: number
  }

  export type Tournament_participantsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whiteMatches?: boolean | Tournament_participantsCountOutputTypeCountWhiteMatchesArgs
    blackMatches?: boolean | Tournament_participantsCountOutputTypeCountBlackMatchesArgs
    wonMatches?: boolean | Tournament_participantsCountOutputTypeCountWonMatchesArgs
  }

  // Custom InputTypes
  /**
   * Tournament_participantsCountOutputType without action
   */
  export type Tournament_participantsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament_participantsCountOutputType
     */
    select?: Tournament_participantsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Tournament_participantsCountOutputType without action
   */
  export type Tournament_participantsCountOutputTypeCountWhiteMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournament_matchesWhereInput
  }

  /**
   * Tournament_participantsCountOutputType without action
   */
  export type Tournament_participantsCountOutputTypeCountBlackMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournament_matchesWhereInput
  }

  /**
   * Tournament_participantsCountOutputType without action
   */
  export type Tournament_participantsCountOutputTypeCountWonMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournament_matchesWhereInput
  }


  /**
   * Count Type TournamentsCountOutputType
   */

  export type TournamentsCountOutputType = {
    games: number
    participants: number
    matches: number
  }

  export type TournamentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | TournamentsCountOutputTypeCountGamesArgs
    participants?: boolean | TournamentsCountOutputTypeCountParticipantsArgs
    matches?: boolean | TournamentsCountOutputTypeCountMatchesArgs
  }

  // Custom InputTypes
  /**
   * TournamentsCountOutputType without action
   */
  export type TournamentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentsCountOutputType
     */
    select?: TournamentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TournamentsCountOutputType without action
   */
  export type TournamentsCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gamesWhereInput
  }

  /**
   * TournamentsCountOutputType without action
   */
  export type TournamentsCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournament_participantsWhereInput
  }

  /**
   * TournamentsCountOutputType without action
   */
  export type TournamentsCountOutputTypeCountMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournament_matchesWhereInput
  }


  /**
   * Count Type GamesCountOutputType
   */

  export type GamesCountOutputType = {
    chatMessages: number
    gameMoves: number
    websocketConnections: number
    sessions: number
    events: number
  }

  export type GamesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatMessages?: boolean | GamesCountOutputTypeCountChatMessagesArgs
    gameMoves?: boolean | GamesCountOutputTypeCountGameMovesArgs
    websocketConnections?: boolean | GamesCountOutputTypeCountWebsocketConnectionsArgs
    sessions?: boolean | GamesCountOutputTypeCountSessionsArgs
    events?: boolean | GamesCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * GamesCountOutputType without action
   */
  export type GamesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GamesCountOutputType
     */
    select?: GamesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GamesCountOutputType without action
   */
  export type GamesCountOutputTypeCountChatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_messagesWhereInput
  }

  /**
   * GamesCountOutputType without action
   */
  export type GamesCountOutputTypeCountGameMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: game_movesWhereInput
  }

  /**
   * GamesCountOutputType without action
   */
  export type GamesCountOutputTypeCountWebsocketConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: websocket_connectionsWhereInput
  }

  /**
   * GamesCountOutputType without action
   */
  export type GamesCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameSessionWhereInput
  }

  /**
   * GamesCountOutputType without action
   */
  export type GamesCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameEventWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    analyses: number
    analysisQuotas: number
    sessions: number
    chatMessages: number
    gameMoves: number
    userAnalytics: number
    gameAnalyses: number
    tournamentParticipants: number
    tournaments: number
    websocketConnections: number
    whiteGames: number
    blackGames: number
    gameSessions: number
    seasonStats: number
    seasonLeaderboards: number
    quotaHistory: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analyses?: boolean | UsersCountOutputTypeCountAnalysesArgs
    analysisQuotas?: boolean | UsersCountOutputTypeCountAnalysisQuotasArgs
    sessions?: boolean | UsersCountOutputTypeCountSessionsArgs
    chatMessages?: boolean | UsersCountOutputTypeCountChatMessagesArgs
    gameMoves?: boolean | UsersCountOutputTypeCountGameMovesArgs
    userAnalytics?: boolean | UsersCountOutputTypeCountUserAnalyticsArgs
    gameAnalyses?: boolean | UsersCountOutputTypeCountGameAnalysesArgs
    tournamentParticipants?: boolean | UsersCountOutputTypeCountTournamentParticipantsArgs
    tournaments?: boolean | UsersCountOutputTypeCountTournamentsArgs
    websocketConnections?: boolean | UsersCountOutputTypeCountWebsocketConnectionsArgs
    whiteGames?: boolean | UsersCountOutputTypeCountWhiteGamesArgs
    blackGames?: boolean | UsersCountOutputTypeCountBlackGamesArgs
    gameSessions?: boolean | UsersCountOutputTypeCountGameSessionsArgs
    seasonStats?: boolean | UsersCountOutputTypeCountSeasonStatsArgs
    seasonLeaderboards?: boolean | UsersCountOutputTypeCountSeasonLeaderboardsArgs
    quotaHistory?: boolean | UsersCountOutputTypeCountQuotaHistoryArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: analysesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAnalysisQuotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalysisQuotaWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountChatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_messagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountGameMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: game_movesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUserAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_analyticsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountGameAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: game_analysesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTournamentParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournament_participantsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTournamentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountWebsocketConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: websocket_connectionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountWhiteGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gamesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountBlackGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gamesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountGameSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameSessionWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSeasonStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_season_statsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSeasonLeaderboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: season_leaderboardWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountQuotaHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_quota_historyWhereInput
  }


  /**
   * Count Type SeasonsCountOutputType
   */

  export type SeasonsCountOutputType = {
    seasonStats: number
    leaderboards: number
    quotaHistory: number
  }

  export type SeasonsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seasonStats?: boolean | SeasonsCountOutputTypeCountSeasonStatsArgs
    leaderboards?: boolean | SeasonsCountOutputTypeCountLeaderboardsArgs
    quotaHistory?: boolean | SeasonsCountOutputTypeCountQuotaHistoryArgs
  }

  // Custom InputTypes
  /**
   * SeasonsCountOutputType without action
   */
  export type SeasonsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonsCountOutputType
     */
    select?: SeasonsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeasonsCountOutputType without action
   */
  export type SeasonsCountOutputTypeCountSeasonStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_season_statsWhereInput
  }

  /**
   * SeasonsCountOutputType without action
   */
  export type SeasonsCountOutputTypeCountLeaderboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: season_leaderboardWhereInput
  }

  /**
   * SeasonsCountOutputType without action
   */
  export type SeasonsCountOutputTypeCountQuotaHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_quota_historyWhereInput
  }


  /**
   * Models
   */

  /**
   * Model analyses
   */

  export type AggregateAnalyses = {
    _count: AnalysesCountAggregateOutputType | null
    _avg: AnalysesAvgAggregateOutputType | null
    _sum: AnalysesSumAggregateOutputType | null
    _min: AnalysesMinAggregateOutputType | null
    _max: AnalysesMaxAggregateOutputType | null
  }

  export type AnalysesAvgAggregateOutputType = {
    dice: number | null
    equity: number | null
    pr: number | null
  }

  export type AnalysesSumAggregateOutputType = {
    dice: number[]
    equity: number | null
    pr: number | null
  }

  export type AnalysesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    boardState: string | null
    move: string | null
    bestMove: string | null
    equity: number | null
    pr: number | null
    explanation: string | null
    analysisType: $Enums.AnalysisType | null
    createdAt: Date | null
  }

  export type AnalysesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    boardState: string | null
    move: string | null
    bestMove: string | null
    equity: number | null
    pr: number | null
    explanation: string | null
    analysisType: $Enums.AnalysisType | null
    createdAt: Date | null
  }

  export type AnalysesCountAggregateOutputType = {
    id: number
    userId: number
    boardState: number
    dice: number
    move: number
    bestMove: number
    equity: number
    pr: number
    explanation: number
    alternatives: number
    analysisType: number
    createdAt: number
    _all: number
  }


  export type AnalysesAvgAggregateInputType = {
    dice?: true
    equity?: true
    pr?: true
  }

  export type AnalysesSumAggregateInputType = {
    dice?: true
    equity?: true
    pr?: true
  }

  export type AnalysesMinAggregateInputType = {
    id?: true
    userId?: true
    boardState?: true
    move?: true
    bestMove?: true
    equity?: true
    pr?: true
    explanation?: true
    analysisType?: true
    createdAt?: true
  }

  export type AnalysesMaxAggregateInputType = {
    id?: true
    userId?: true
    boardState?: true
    move?: true
    bestMove?: true
    equity?: true
    pr?: true
    explanation?: true
    analysisType?: true
    createdAt?: true
  }

  export type AnalysesCountAggregateInputType = {
    id?: true
    userId?: true
    boardState?: true
    dice?: true
    move?: true
    bestMove?: true
    equity?: true
    pr?: true
    explanation?: true
    alternatives?: true
    analysisType?: true
    createdAt?: true
    _all?: true
  }

  export type AnalysesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which analyses to aggregate.
     */
    where?: analysesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analyses to fetch.
     */
    orderBy?: analysesOrderByWithRelationInput | analysesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: analysesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned analyses
    **/
    _count?: true | AnalysesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalysesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalysesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalysesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalysesMaxAggregateInputType
  }

  export type GetAnalysesAggregateType<T extends AnalysesAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyses[P]>
      : GetScalarType<T[P], AggregateAnalyses[P]>
  }




  export type analysesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: analysesWhereInput
    orderBy?: analysesOrderByWithAggregationInput | analysesOrderByWithAggregationInput[]
    by: AnalysesScalarFieldEnum[] | AnalysesScalarFieldEnum
    having?: analysesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalysesCountAggregateInputType | true
    _avg?: AnalysesAvgAggregateInputType
    _sum?: AnalysesSumAggregateInputType
    _min?: AnalysesMinAggregateInputType
    _max?: AnalysesMaxAggregateInputType
  }

  export type AnalysesGroupByOutputType = {
    id: string
    userId: string
    boardState: string
    dice: number[]
    move: string
    bestMove: string
    equity: number
    pr: number
    explanation: string
    alternatives: JsonValue
    analysisType: $Enums.AnalysisType
    createdAt: Date
    _count: AnalysesCountAggregateOutputType | null
    _avg: AnalysesAvgAggregateOutputType | null
    _sum: AnalysesSumAggregateOutputType | null
    _min: AnalysesMinAggregateOutputType | null
    _max: AnalysesMaxAggregateOutputType | null
  }

  type GetAnalysesGroupByPayload<T extends analysesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalysesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalysesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalysesGroupByOutputType[P]>
            : GetScalarType<T[P], AnalysesGroupByOutputType[P]>
        }
      >
    >


  export type analysesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    boardState?: boolean
    dice?: boolean
    move?: boolean
    bestMove?: boolean
    equity?: boolean
    pr?: boolean
    explanation?: boolean
    alternatives?: boolean
    analysisType?: boolean
    createdAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyses"]>

  export type analysesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    boardState?: boolean
    dice?: boolean
    move?: boolean
    bestMove?: boolean
    equity?: boolean
    pr?: boolean
    explanation?: boolean
    alternatives?: boolean
    analysisType?: boolean
    createdAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyses"]>

  export type analysesSelectScalar = {
    id?: boolean
    userId?: boolean
    boardState?: boolean
    dice?: boolean
    move?: boolean
    bestMove?: boolean
    equity?: boolean
    pr?: boolean
    explanation?: boolean
    alternatives?: boolean
    analysisType?: boolean
    createdAt?: boolean
  }

  export type analysesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type analysesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $analysesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "analyses"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      boardState: string
      dice: number[]
      move: string
      bestMove: string
      equity: number
      pr: number
      explanation: string
      alternatives: Prisma.JsonValue
      analysisType: $Enums.AnalysisType
      createdAt: Date
    }, ExtArgs["result"]["analyses"]>
    composites: {}
  }

  type analysesGetPayload<S extends boolean | null | undefined | analysesDefaultArgs> = $Result.GetResult<Prisma.$analysesPayload, S>

  type analysesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<analysesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnalysesCountAggregateInputType | true
    }

  export interface analysesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['analyses'], meta: { name: 'analyses' } }
    /**
     * Find zero or one Analyses that matches the filter.
     * @param {analysesFindUniqueArgs} args - Arguments to find a Analyses
     * @example
     * // Get one Analyses
     * const analyses = await prisma.analyses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends analysesFindUniqueArgs>(args: SelectSubset<T, analysesFindUniqueArgs<ExtArgs>>): Prisma__analysesClient<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Analyses that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {analysesFindUniqueOrThrowArgs} args - Arguments to find a Analyses
     * @example
     * // Get one Analyses
     * const analyses = await prisma.analyses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends analysesFindUniqueOrThrowArgs>(args: SelectSubset<T, analysesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__analysesClient<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Analyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analysesFindFirstArgs} args - Arguments to find a Analyses
     * @example
     * // Get one Analyses
     * const analyses = await prisma.analyses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends analysesFindFirstArgs>(args?: SelectSubset<T, analysesFindFirstArgs<ExtArgs>>): Prisma__analysesClient<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Analyses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analysesFindFirstOrThrowArgs} args - Arguments to find a Analyses
     * @example
     * // Get one Analyses
     * const analyses = await prisma.analyses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends analysesFindFirstOrThrowArgs>(args?: SelectSubset<T, analysesFindFirstOrThrowArgs<ExtArgs>>): Prisma__analysesClient<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Analyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analysesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Analyses
     * const analyses = await prisma.analyses.findMany()
     * 
     * // Get first 10 Analyses
     * const analyses = await prisma.analyses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analysesWithIdOnly = await prisma.analyses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends analysesFindManyArgs>(args?: SelectSubset<T, analysesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Analyses.
     * @param {analysesCreateArgs} args - Arguments to create a Analyses.
     * @example
     * // Create one Analyses
     * const Analyses = await prisma.analyses.create({
     *   data: {
     *     // ... data to create a Analyses
     *   }
     * })
     * 
     */
    create<T extends analysesCreateArgs>(args: SelectSubset<T, analysesCreateArgs<ExtArgs>>): Prisma__analysesClient<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Analyses.
     * @param {analysesCreateManyArgs} args - Arguments to create many Analyses.
     * @example
     * // Create many Analyses
     * const analyses = await prisma.analyses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends analysesCreateManyArgs>(args?: SelectSubset<T, analysesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Analyses and returns the data saved in the database.
     * @param {analysesCreateManyAndReturnArgs} args - Arguments to create many Analyses.
     * @example
     * // Create many Analyses
     * const analyses = await prisma.analyses.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Analyses and only return the `id`
     * const analysesWithIdOnly = await prisma.analyses.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends analysesCreateManyAndReturnArgs>(args?: SelectSubset<T, analysesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Analyses.
     * @param {analysesDeleteArgs} args - Arguments to delete one Analyses.
     * @example
     * // Delete one Analyses
     * const Analyses = await prisma.analyses.delete({
     *   where: {
     *     // ... filter to delete one Analyses
     *   }
     * })
     * 
     */
    delete<T extends analysesDeleteArgs>(args: SelectSubset<T, analysesDeleteArgs<ExtArgs>>): Prisma__analysesClient<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Analyses.
     * @param {analysesUpdateArgs} args - Arguments to update one Analyses.
     * @example
     * // Update one Analyses
     * const analyses = await prisma.analyses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends analysesUpdateArgs>(args: SelectSubset<T, analysesUpdateArgs<ExtArgs>>): Prisma__analysesClient<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Analyses.
     * @param {analysesDeleteManyArgs} args - Arguments to filter Analyses to delete.
     * @example
     * // Delete a few Analyses
     * const { count } = await prisma.analyses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends analysesDeleteManyArgs>(args?: SelectSubset<T, analysesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analysesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Analyses
     * const analyses = await prisma.analyses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends analysesUpdateManyArgs>(args: SelectSubset<T, analysesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Analyses.
     * @param {analysesUpsertArgs} args - Arguments to update or create a Analyses.
     * @example
     * // Update or create a Analyses
     * const analyses = await prisma.analyses.upsert({
     *   create: {
     *     // ... data to create a Analyses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Analyses we want to update
     *   }
     * })
     */
    upsert<T extends analysesUpsertArgs>(args: SelectSubset<T, analysesUpsertArgs<ExtArgs>>): Prisma__analysesClient<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analysesCountArgs} args - Arguments to filter Analyses to count.
     * @example
     * // Count the number of Analyses
     * const count = await prisma.analyses.count({
     *   where: {
     *     // ... the filter for the Analyses we want to count
     *   }
     * })
    **/
    count<T extends analysesCountArgs>(
      args?: Subset<T, analysesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalysesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalysesAggregateArgs>(args: Subset<T, AnalysesAggregateArgs>): Prisma.PrismaPromise<GetAnalysesAggregateType<T>>

    /**
     * Group by Analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analysesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends analysesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: analysesGroupByArgs['orderBy'] }
        : { orderBy?: analysesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, analysesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalysesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the analyses model
   */
  readonly fields: analysesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for analyses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__analysesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the analyses model
   */ 
  interface analysesFieldRefs {
    readonly id: FieldRef<"analyses", 'String'>
    readonly userId: FieldRef<"analyses", 'String'>
    readonly boardState: FieldRef<"analyses", 'String'>
    readonly dice: FieldRef<"analyses", 'Int[]'>
    readonly move: FieldRef<"analyses", 'String'>
    readonly bestMove: FieldRef<"analyses", 'String'>
    readonly equity: FieldRef<"analyses", 'Float'>
    readonly pr: FieldRef<"analyses", 'Float'>
    readonly explanation: FieldRef<"analyses", 'String'>
    readonly alternatives: FieldRef<"analyses", 'Json'>
    readonly analysisType: FieldRef<"analyses", 'AnalysisType'>
    readonly createdAt: FieldRef<"analyses", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * analyses findUnique
   */
  export type analysesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    /**
     * Filter, which analyses to fetch.
     */
    where: analysesWhereUniqueInput
  }

  /**
   * analyses findUniqueOrThrow
   */
  export type analysesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    /**
     * Filter, which analyses to fetch.
     */
    where: analysesWhereUniqueInput
  }

  /**
   * analyses findFirst
   */
  export type analysesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    /**
     * Filter, which analyses to fetch.
     */
    where?: analysesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analyses to fetch.
     */
    orderBy?: analysesOrderByWithRelationInput | analysesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for analyses.
     */
    cursor?: analysesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of analyses.
     */
    distinct?: AnalysesScalarFieldEnum | AnalysesScalarFieldEnum[]
  }

  /**
   * analyses findFirstOrThrow
   */
  export type analysesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    /**
     * Filter, which analyses to fetch.
     */
    where?: analysesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analyses to fetch.
     */
    orderBy?: analysesOrderByWithRelationInput | analysesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for analyses.
     */
    cursor?: analysesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of analyses.
     */
    distinct?: AnalysesScalarFieldEnum | AnalysesScalarFieldEnum[]
  }

  /**
   * analyses findMany
   */
  export type analysesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    /**
     * Filter, which analyses to fetch.
     */
    where?: analysesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analyses to fetch.
     */
    orderBy?: analysesOrderByWithRelationInput | analysesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing analyses.
     */
    cursor?: analysesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analyses.
     */
    skip?: number
    distinct?: AnalysesScalarFieldEnum | AnalysesScalarFieldEnum[]
  }

  /**
   * analyses create
   */
  export type analysesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    /**
     * The data needed to create a analyses.
     */
    data: XOR<analysesCreateInput, analysesUncheckedCreateInput>
  }

  /**
   * analyses createMany
   */
  export type analysesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many analyses.
     */
    data: analysesCreateManyInput | analysesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * analyses createManyAndReturn
   */
  export type analysesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many analyses.
     */
    data: analysesCreateManyInput | analysesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * analyses update
   */
  export type analysesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    /**
     * The data needed to update a analyses.
     */
    data: XOR<analysesUpdateInput, analysesUncheckedUpdateInput>
    /**
     * Choose, which analyses to update.
     */
    where: analysesWhereUniqueInput
  }

  /**
   * analyses updateMany
   */
  export type analysesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update analyses.
     */
    data: XOR<analysesUpdateManyMutationInput, analysesUncheckedUpdateManyInput>
    /**
     * Filter which analyses to update
     */
    where?: analysesWhereInput
  }

  /**
   * analyses upsert
   */
  export type analysesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    /**
     * The filter to search for the analyses to update in case it exists.
     */
    where: analysesWhereUniqueInput
    /**
     * In case the analyses found by the `where` argument doesn't exist, create a new analyses with this data.
     */
    create: XOR<analysesCreateInput, analysesUncheckedCreateInput>
    /**
     * In case the analyses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<analysesUpdateInput, analysesUncheckedUpdateInput>
  }

  /**
   * analyses delete
   */
  export type analysesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    /**
     * Filter which analyses to delete.
     */
    where: analysesWhereUniqueInput
  }

  /**
   * analyses deleteMany
   */
  export type analysesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which analyses to delete
     */
    where?: analysesWhereInput
  }

  /**
   * analyses without action
   */
  export type analysesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
  }


  /**
   * Model AnalysisQuota
   */

  export type AggregateAnalysisQuota = {
    _count: AnalysisQuotaCountAggregateOutputType | null
    _avg: AnalysisQuotaAvgAggregateOutputType | null
    _sum: AnalysisQuotaSumAggregateOutputType | null
    _min: AnalysisQuotaMinAggregateOutputType | null
    _max: AnalysisQuotaMaxAggregateOutputType | null
  }

  export type AnalysisQuotaAvgAggregateOutputType = {
    count: number | null
    extraQuota: number | null
  }

  export type AnalysisQuotaSumAggregateOutputType = {
    count: number | null
    extraQuota: number | null
  }

  export type AnalysisQuotaMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    count: number | null
    extraQuota: number | null
    initialFree: boolean | null
  }

  export type AnalysisQuotaMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    count: number | null
    extraQuota: number | null
    initialFree: boolean | null
  }

  export type AnalysisQuotaCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    count: number
    extraQuota: number
    initialFree: number
    _all: number
  }


  export type AnalysisQuotaAvgAggregateInputType = {
    count?: true
    extraQuota?: true
  }

  export type AnalysisQuotaSumAggregateInputType = {
    count?: true
    extraQuota?: true
  }

  export type AnalysisQuotaMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    count?: true
    extraQuota?: true
    initialFree?: true
  }

  export type AnalysisQuotaMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    count?: true
    extraQuota?: true
    initialFree?: true
  }

  export type AnalysisQuotaCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    count?: true
    extraQuota?: true
    initialFree?: true
    _all?: true
  }

  export type AnalysisQuotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalysisQuota to aggregate.
     */
    where?: AnalysisQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisQuotas to fetch.
     */
    orderBy?: AnalysisQuotaOrderByWithRelationInput | AnalysisQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalysisQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalysisQuotas
    **/
    _count?: true | AnalysisQuotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalysisQuotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalysisQuotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalysisQuotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalysisQuotaMaxAggregateInputType
  }

  export type GetAnalysisQuotaAggregateType<T extends AnalysisQuotaAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalysisQuota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalysisQuota[P]>
      : GetScalarType<T[P], AggregateAnalysisQuota[P]>
  }




  export type AnalysisQuotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalysisQuotaWhereInput
    orderBy?: AnalysisQuotaOrderByWithAggregationInput | AnalysisQuotaOrderByWithAggregationInput[]
    by: AnalysisQuotaScalarFieldEnum[] | AnalysisQuotaScalarFieldEnum
    having?: AnalysisQuotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalysisQuotaCountAggregateInputType | true
    _avg?: AnalysisQuotaAvgAggregateInputType
    _sum?: AnalysisQuotaSumAggregateInputType
    _min?: AnalysisQuotaMinAggregateInputType
    _max?: AnalysisQuotaMaxAggregateInputType
  }

  export type AnalysisQuotaGroupByOutputType = {
    id: string
    userId: string
    date: Date
    count: number
    extraQuota: number
    initialFree: boolean
    _count: AnalysisQuotaCountAggregateOutputType | null
    _avg: AnalysisQuotaAvgAggregateOutputType | null
    _sum: AnalysisQuotaSumAggregateOutputType | null
    _min: AnalysisQuotaMinAggregateOutputType | null
    _max: AnalysisQuotaMaxAggregateOutputType | null
  }

  type GetAnalysisQuotaGroupByPayload<T extends AnalysisQuotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalysisQuotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalysisQuotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalysisQuotaGroupByOutputType[P]>
            : GetScalarType<T[P], AnalysisQuotaGroupByOutputType[P]>
        }
      >
    >


  export type AnalysisQuotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    count?: boolean
    extraQuota?: boolean
    initialFree?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analysisQuota"]>

  export type AnalysisQuotaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    count?: boolean
    extraQuota?: boolean
    initialFree?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analysisQuota"]>

  export type AnalysisQuotaSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    count?: boolean
    extraQuota?: boolean
    initialFree?: boolean
  }

  export type AnalysisQuotaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type AnalysisQuotaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $AnalysisQuotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalysisQuota"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      count: number
      extraQuota: number
      initialFree: boolean
    }, ExtArgs["result"]["analysisQuota"]>
    composites: {}
  }

  type AnalysisQuotaGetPayload<S extends boolean | null | undefined | AnalysisQuotaDefaultArgs> = $Result.GetResult<Prisma.$AnalysisQuotaPayload, S>

  type AnalysisQuotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnalysisQuotaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnalysisQuotaCountAggregateInputType | true
    }

  export interface AnalysisQuotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalysisQuota'], meta: { name: 'AnalysisQuota' } }
    /**
     * Find zero or one AnalysisQuota that matches the filter.
     * @param {AnalysisQuotaFindUniqueArgs} args - Arguments to find a AnalysisQuota
     * @example
     * // Get one AnalysisQuota
     * const analysisQuota = await prisma.analysisQuota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalysisQuotaFindUniqueArgs>(args: SelectSubset<T, AnalysisQuotaFindUniqueArgs<ExtArgs>>): Prisma__AnalysisQuotaClient<$Result.GetResult<Prisma.$AnalysisQuotaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AnalysisQuota that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnalysisQuotaFindUniqueOrThrowArgs} args - Arguments to find a AnalysisQuota
     * @example
     * // Get one AnalysisQuota
     * const analysisQuota = await prisma.analysisQuota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalysisQuotaFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalysisQuotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalysisQuotaClient<$Result.GetResult<Prisma.$AnalysisQuotaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AnalysisQuota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisQuotaFindFirstArgs} args - Arguments to find a AnalysisQuota
     * @example
     * // Get one AnalysisQuota
     * const analysisQuota = await prisma.analysisQuota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalysisQuotaFindFirstArgs>(args?: SelectSubset<T, AnalysisQuotaFindFirstArgs<ExtArgs>>): Prisma__AnalysisQuotaClient<$Result.GetResult<Prisma.$AnalysisQuotaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AnalysisQuota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisQuotaFindFirstOrThrowArgs} args - Arguments to find a AnalysisQuota
     * @example
     * // Get one AnalysisQuota
     * const analysisQuota = await prisma.analysisQuota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalysisQuotaFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalysisQuotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalysisQuotaClient<$Result.GetResult<Prisma.$AnalysisQuotaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AnalysisQuotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisQuotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalysisQuotas
     * const analysisQuotas = await prisma.analysisQuota.findMany()
     * 
     * // Get first 10 AnalysisQuotas
     * const analysisQuotas = await prisma.analysisQuota.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analysisQuotaWithIdOnly = await prisma.analysisQuota.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalysisQuotaFindManyArgs>(args?: SelectSubset<T, AnalysisQuotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisQuotaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AnalysisQuota.
     * @param {AnalysisQuotaCreateArgs} args - Arguments to create a AnalysisQuota.
     * @example
     * // Create one AnalysisQuota
     * const AnalysisQuota = await prisma.analysisQuota.create({
     *   data: {
     *     // ... data to create a AnalysisQuota
     *   }
     * })
     * 
     */
    create<T extends AnalysisQuotaCreateArgs>(args: SelectSubset<T, AnalysisQuotaCreateArgs<ExtArgs>>): Prisma__AnalysisQuotaClient<$Result.GetResult<Prisma.$AnalysisQuotaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AnalysisQuotas.
     * @param {AnalysisQuotaCreateManyArgs} args - Arguments to create many AnalysisQuotas.
     * @example
     * // Create many AnalysisQuotas
     * const analysisQuota = await prisma.analysisQuota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalysisQuotaCreateManyArgs>(args?: SelectSubset<T, AnalysisQuotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalysisQuotas and returns the data saved in the database.
     * @param {AnalysisQuotaCreateManyAndReturnArgs} args - Arguments to create many AnalysisQuotas.
     * @example
     * // Create many AnalysisQuotas
     * const analysisQuota = await prisma.analysisQuota.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalysisQuotas and only return the `id`
     * const analysisQuotaWithIdOnly = await prisma.analysisQuota.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalysisQuotaCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalysisQuotaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisQuotaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AnalysisQuota.
     * @param {AnalysisQuotaDeleteArgs} args - Arguments to delete one AnalysisQuota.
     * @example
     * // Delete one AnalysisQuota
     * const AnalysisQuota = await prisma.analysisQuota.delete({
     *   where: {
     *     // ... filter to delete one AnalysisQuota
     *   }
     * })
     * 
     */
    delete<T extends AnalysisQuotaDeleteArgs>(args: SelectSubset<T, AnalysisQuotaDeleteArgs<ExtArgs>>): Prisma__AnalysisQuotaClient<$Result.GetResult<Prisma.$AnalysisQuotaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AnalysisQuota.
     * @param {AnalysisQuotaUpdateArgs} args - Arguments to update one AnalysisQuota.
     * @example
     * // Update one AnalysisQuota
     * const analysisQuota = await prisma.analysisQuota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalysisQuotaUpdateArgs>(args: SelectSubset<T, AnalysisQuotaUpdateArgs<ExtArgs>>): Prisma__AnalysisQuotaClient<$Result.GetResult<Prisma.$AnalysisQuotaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AnalysisQuotas.
     * @param {AnalysisQuotaDeleteManyArgs} args - Arguments to filter AnalysisQuotas to delete.
     * @example
     * // Delete a few AnalysisQuotas
     * const { count } = await prisma.analysisQuota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalysisQuotaDeleteManyArgs>(args?: SelectSubset<T, AnalysisQuotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalysisQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisQuotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalysisQuotas
     * const analysisQuota = await prisma.analysisQuota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalysisQuotaUpdateManyArgs>(args: SelectSubset<T, AnalysisQuotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnalysisQuota.
     * @param {AnalysisQuotaUpsertArgs} args - Arguments to update or create a AnalysisQuota.
     * @example
     * // Update or create a AnalysisQuota
     * const analysisQuota = await prisma.analysisQuota.upsert({
     *   create: {
     *     // ... data to create a AnalysisQuota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalysisQuota we want to update
     *   }
     * })
     */
    upsert<T extends AnalysisQuotaUpsertArgs>(args: SelectSubset<T, AnalysisQuotaUpsertArgs<ExtArgs>>): Prisma__AnalysisQuotaClient<$Result.GetResult<Prisma.$AnalysisQuotaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AnalysisQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisQuotaCountArgs} args - Arguments to filter AnalysisQuotas to count.
     * @example
     * // Count the number of AnalysisQuotas
     * const count = await prisma.analysisQuota.count({
     *   where: {
     *     // ... the filter for the AnalysisQuotas we want to count
     *   }
     * })
    **/
    count<T extends AnalysisQuotaCountArgs>(
      args?: Subset<T, AnalysisQuotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalysisQuotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalysisQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisQuotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalysisQuotaAggregateArgs>(args: Subset<T, AnalysisQuotaAggregateArgs>): Prisma.PrismaPromise<GetAnalysisQuotaAggregateType<T>>

    /**
     * Group by AnalysisQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisQuotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalysisQuotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalysisQuotaGroupByArgs['orderBy'] }
        : { orderBy?: AnalysisQuotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalysisQuotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalysisQuotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalysisQuota model
   */
  readonly fields: AnalysisQuotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalysisQuota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalysisQuotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalysisQuota model
   */ 
  interface AnalysisQuotaFieldRefs {
    readonly id: FieldRef<"AnalysisQuota", 'String'>
    readonly userId: FieldRef<"AnalysisQuota", 'String'>
    readonly date: FieldRef<"AnalysisQuota", 'DateTime'>
    readonly count: FieldRef<"AnalysisQuota", 'Int'>
    readonly extraQuota: FieldRef<"AnalysisQuota", 'Int'>
    readonly initialFree: FieldRef<"AnalysisQuota", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AnalysisQuota findUnique
   */
  export type AnalysisQuotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuota
     */
    select?: AnalysisQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuotaInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisQuota to fetch.
     */
    where: AnalysisQuotaWhereUniqueInput
  }

  /**
   * AnalysisQuota findUniqueOrThrow
   */
  export type AnalysisQuotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuota
     */
    select?: AnalysisQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuotaInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisQuota to fetch.
     */
    where: AnalysisQuotaWhereUniqueInput
  }

  /**
   * AnalysisQuota findFirst
   */
  export type AnalysisQuotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuota
     */
    select?: AnalysisQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuotaInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisQuota to fetch.
     */
    where?: AnalysisQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisQuotas to fetch.
     */
    orderBy?: AnalysisQuotaOrderByWithRelationInput | AnalysisQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalysisQuotas.
     */
    cursor?: AnalysisQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalysisQuotas.
     */
    distinct?: AnalysisQuotaScalarFieldEnum | AnalysisQuotaScalarFieldEnum[]
  }

  /**
   * AnalysisQuota findFirstOrThrow
   */
  export type AnalysisQuotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuota
     */
    select?: AnalysisQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuotaInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisQuota to fetch.
     */
    where?: AnalysisQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisQuotas to fetch.
     */
    orderBy?: AnalysisQuotaOrderByWithRelationInput | AnalysisQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalysisQuotas.
     */
    cursor?: AnalysisQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalysisQuotas.
     */
    distinct?: AnalysisQuotaScalarFieldEnum | AnalysisQuotaScalarFieldEnum[]
  }

  /**
   * AnalysisQuota findMany
   */
  export type AnalysisQuotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuota
     */
    select?: AnalysisQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuotaInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisQuotas to fetch.
     */
    where?: AnalysisQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisQuotas to fetch.
     */
    orderBy?: AnalysisQuotaOrderByWithRelationInput | AnalysisQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalysisQuotas.
     */
    cursor?: AnalysisQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisQuotas.
     */
    skip?: number
    distinct?: AnalysisQuotaScalarFieldEnum | AnalysisQuotaScalarFieldEnum[]
  }

  /**
   * AnalysisQuota create
   */
  export type AnalysisQuotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuota
     */
    select?: AnalysisQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuotaInclude<ExtArgs> | null
    /**
     * The data needed to create a AnalysisQuota.
     */
    data: XOR<AnalysisQuotaCreateInput, AnalysisQuotaUncheckedCreateInput>
  }

  /**
   * AnalysisQuota createMany
   */
  export type AnalysisQuotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalysisQuotas.
     */
    data: AnalysisQuotaCreateManyInput | AnalysisQuotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalysisQuota createManyAndReturn
   */
  export type AnalysisQuotaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuota
     */
    select?: AnalysisQuotaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AnalysisQuotas.
     */
    data: AnalysisQuotaCreateManyInput | AnalysisQuotaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuotaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalysisQuota update
   */
  export type AnalysisQuotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuota
     */
    select?: AnalysisQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuotaInclude<ExtArgs> | null
    /**
     * The data needed to update a AnalysisQuota.
     */
    data: XOR<AnalysisQuotaUpdateInput, AnalysisQuotaUncheckedUpdateInput>
    /**
     * Choose, which AnalysisQuota to update.
     */
    where: AnalysisQuotaWhereUniqueInput
  }

  /**
   * AnalysisQuota updateMany
   */
  export type AnalysisQuotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalysisQuotas.
     */
    data: XOR<AnalysisQuotaUpdateManyMutationInput, AnalysisQuotaUncheckedUpdateManyInput>
    /**
     * Filter which AnalysisQuotas to update
     */
    where?: AnalysisQuotaWhereInput
  }

  /**
   * AnalysisQuota upsert
   */
  export type AnalysisQuotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuota
     */
    select?: AnalysisQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuotaInclude<ExtArgs> | null
    /**
     * The filter to search for the AnalysisQuota to update in case it exists.
     */
    where: AnalysisQuotaWhereUniqueInput
    /**
     * In case the AnalysisQuota found by the `where` argument doesn't exist, create a new AnalysisQuota with this data.
     */
    create: XOR<AnalysisQuotaCreateInput, AnalysisQuotaUncheckedCreateInput>
    /**
     * In case the AnalysisQuota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalysisQuotaUpdateInput, AnalysisQuotaUncheckedUpdateInput>
  }

  /**
   * AnalysisQuota delete
   */
  export type AnalysisQuotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuota
     */
    select?: AnalysisQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuotaInclude<ExtArgs> | null
    /**
     * Filter which AnalysisQuota to delete.
     */
    where: AnalysisQuotaWhereUniqueInput
  }

  /**
   * AnalysisQuota deleteMany
   */
  export type AnalysisQuotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalysisQuotas to delete
     */
    where?: AnalysisQuotaWhereInput
  }

  /**
   * AnalysisQuota without action
   */
  export type AnalysisQuotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuota
     */
    select?: AnalysisQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuotaInclude<ExtArgs> | null
  }


  /**
   * Model IAQuota
   */

  export type AggregateIAQuota = {
    _count: IAQuotaCountAggregateOutputType | null
    _avg: IAQuotaAvgAggregateOutputType | null
    _sum: IAQuotaSumAggregateOutputType | null
    _min: IAQuotaMinAggregateOutputType | null
    _max: IAQuotaMaxAggregateOutputType | null
  }

  export type IAQuotaAvgAggregateOutputType = {
    dailyQuota: number | null
    premiumQuota: number | null
    extrasUsed: number | null
  }

  export type IAQuotaSumAggregateOutputType = {
    dailyQuota: number | null
    premiumQuota: number | null
    extrasUsed: number | null
  }

  export type IAQuotaMinAggregateOutputType = {
    id: string | null
    userId: string | null
    dailyQuota: number | null
    premiumQuota: number | null
    extrasUsed: number | null
    resetAt: Date | null
  }

  export type IAQuotaMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    dailyQuota: number | null
    premiumQuota: number | null
    extrasUsed: number | null
    resetAt: Date | null
  }

  export type IAQuotaCountAggregateOutputType = {
    id: number
    userId: number
    dailyQuota: number
    premiumQuota: number
    extrasUsed: number
    resetAt: number
    _all: number
  }


  export type IAQuotaAvgAggregateInputType = {
    dailyQuota?: true
    premiumQuota?: true
    extrasUsed?: true
  }

  export type IAQuotaSumAggregateInputType = {
    dailyQuota?: true
    premiumQuota?: true
    extrasUsed?: true
  }

  export type IAQuotaMinAggregateInputType = {
    id?: true
    userId?: true
    dailyQuota?: true
    premiumQuota?: true
    extrasUsed?: true
    resetAt?: true
  }

  export type IAQuotaMaxAggregateInputType = {
    id?: true
    userId?: true
    dailyQuota?: true
    premiumQuota?: true
    extrasUsed?: true
    resetAt?: true
  }

  export type IAQuotaCountAggregateInputType = {
    id?: true
    userId?: true
    dailyQuota?: true
    premiumQuota?: true
    extrasUsed?: true
    resetAt?: true
    _all?: true
  }

  export type IAQuotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IAQuota to aggregate.
     */
    where?: IAQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IAQuotas to fetch.
     */
    orderBy?: IAQuotaOrderByWithRelationInput | IAQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IAQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IAQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IAQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IAQuotas
    **/
    _count?: true | IAQuotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IAQuotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IAQuotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IAQuotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IAQuotaMaxAggregateInputType
  }

  export type GetIAQuotaAggregateType<T extends IAQuotaAggregateArgs> = {
        [P in keyof T & keyof AggregateIAQuota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIAQuota[P]>
      : GetScalarType<T[P], AggregateIAQuota[P]>
  }




  export type IAQuotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IAQuotaWhereInput
    orderBy?: IAQuotaOrderByWithAggregationInput | IAQuotaOrderByWithAggregationInput[]
    by: IAQuotaScalarFieldEnum[] | IAQuotaScalarFieldEnum
    having?: IAQuotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IAQuotaCountAggregateInputType | true
    _avg?: IAQuotaAvgAggregateInputType
    _sum?: IAQuotaSumAggregateInputType
    _min?: IAQuotaMinAggregateInputType
    _max?: IAQuotaMaxAggregateInputType
  }

  export type IAQuotaGroupByOutputType = {
    id: string
    userId: string
    dailyQuota: number
    premiumQuota: number
    extrasUsed: number
    resetAt: Date
    _count: IAQuotaCountAggregateOutputType | null
    _avg: IAQuotaAvgAggregateOutputType | null
    _sum: IAQuotaSumAggregateOutputType | null
    _min: IAQuotaMinAggregateOutputType | null
    _max: IAQuotaMaxAggregateOutputType | null
  }

  type GetIAQuotaGroupByPayload<T extends IAQuotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IAQuotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IAQuotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IAQuotaGroupByOutputType[P]>
            : GetScalarType<T[P], IAQuotaGroupByOutputType[P]>
        }
      >
    >


  export type IAQuotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dailyQuota?: boolean
    premiumQuota?: boolean
    extrasUsed?: boolean
    resetAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iAQuota"]>

  export type IAQuotaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dailyQuota?: boolean
    premiumQuota?: boolean
    extrasUsed?: boolean
    resetAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iAQuota"]>

  export type IAQuotaSelectScalar = {
    id?: boolean
    userId?: boolean
    dailyQuota?: boolean
    premiumQuota?: boolean
    extrasUsed?: boolean
    resetAt?: boolean
  }

  export type IAQuotaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type IAQuotaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $IAQuotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IAQuota"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      dailyQuota: number
      premiumQuota: number
      extrasUsed: number
      resetAt: Date
    }, ExtArgs["result"]["iAQuota"]>
    composites: {}
  }

  type IAQuotaGetPayload<S extends boolean | null | undefined | IAQuotaDefaultArgs> = $Result.GetResult<Prisma.$IAQuotaPayload, S>

  type IAQuotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IAQuotaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IAQuotaCountAggregateInputType | true
    }

  export interface IAQuotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IAQuota'], meta: { name: 'IAQuota' } }
    /**
     * Find zero or one IAQuota that matches the filter.
     * @param {IAQuotaFindUniqueArgs} args - Arguments to find a IAQuota
     * @example
     * // Get one IAQuota
     * const iAQuota = await prisma.iAQuota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IAQuotaFindUniqueArgs>(args: SelectSubset<T, IAQuotaFindUniqueArgs<ExtArgs>>): Prisma__IAQuotaClient<$Result.GetResult<Prisma.$IAQuotaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IAQuota that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IAQuotaFindUniqueOrThrowArgs} args - Arguments to find a IAQuota
     * @example
     * // Get one IAQuota
     * const iAQuota = await prisma.iAQuota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IAQuotaFindUniqueOrThrowArgs>(args: SelectSubset<T, IAQuotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IAQuotaClient<$Result.GetResult<Prisma.$IAQuotaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IAQuota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IAQuotaFindFirstArgs} args - Arguments to find a IAQuota
     * @example
     * // Get one IAQuota
     * const iAQuota = await prisma.iAQuota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IAQuotaFindFirstArgs>(args?: SelectSubset<T, IAQuotaFindFirstArgs<ExtArgs>>): Prisma__IAQuotaClient<$Result.GetResult<Prisma.$IAQuotaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IAQuota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IAQuotaFindFirstOrThrowArgs} args - Arguments to find a IAQuota
     * @example
     * // Get one IAQuota
     * const iAQuota = await prisma.iAQuota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IAQuotaFindFirstOrThrowArgs>(args?: SelectSubset<T, IAQuotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__IAQuotaClient<$Result.GetResult<Prisma.$IAQuotaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IAQuotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IAQuotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IAQuotas
     * const iAQuotas = await prisma.iAQuota.findMany()
     * 
     * // Get first 10 IAQuotas
     * const iAQuotas = await prisma.iAQuota.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const iAQuotaWithIdOnly = await prisma.iAQuota.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IAQuotaFindManyArgs>(args?: SelectSubset<T, IAQuotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IAQuotaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IAQuota.
     * @param {IAQuotaCreateArgs} args - Arguments to create a IAQuota.
     * @example
     * // Create one IAQuota
     * const IAQuota = await prisma.iAQuota.create({
     *   data: {
     *     // ... data to create a IAQuota
     *   }
     * })
     * 
     */
    create<T extends IAQuotaCreateArgs>(args: SelectSubset<T, IAQuotaCreateArgs<ExtArgs>>): Prisma__IAQuotaClient<$Result.GetResult<Prisma.$IAQuotaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IAQuotas.
     * @param {IAQuotaCreateManyArgs} args - Arguments to create many IAQuotas.
     * @example
     * // Create many IAQuotas
     * const iAQuota = await prisma.iAQuota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IAQuotaCreateManyArgs>(args?: SelectSubset<T, IAQuotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IAQuotas and returns the data saved in the database.
     * @param {IAQuotaCreateManyAndReturnArgs} args - Arguments to create many IAQuotas.
     * @example
     * // Create many IAQuotas
     * const iAQuota = await prisma.iAQuota.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IAQuotas and only return the `id`
     * const iAQuotaWithIdOnly = await prisma.iAQuota.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IAQuotaCreateManyAndReturnArgs>(args?: SelectSubset<T, IAQuotaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IAQuotaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IAQuota.
     * @param {IAQuotaDeleteArgs} args - Arguments to delete one IAQuota.
     * @example
     * // Delete one IAQuota
     * const IAQuota = await prisma.iAQuota.delete({
     *   where: {
     *     // ... filter to delete one IAQuota
     *   }
     * })
     * 
     */
    delete<T extends IAQuotaDeleteArgs>(args: SelectSubset<T, IAQuotaDeleteArgs<ExtArgs>>): Prisma__IAQuotaClient<$Result.GetResult<Prisma.$IAQuotaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IAQuota.
     * @param {IAQuotaUpdateArgs} args - Arguments to update one IAQuota.
     * @example
     * // Update one IAQuota
     * const iAQuota = await prisma.iAQuota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IAQuotaUpdateArgs>(args: SelectSubset<T, IAQuotaUpdateArgs<ExtArgs>>): Prisma__IAQuotaClient<$Result.GetResult<Prisma.$IAQuotaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IAQuotas.
     * @param {IAQuotaDeleteManyArgs} args - Arguments to filter IAQuotas to delete.
     * @example
     * // Delete a few IAQuotas
     * const { count } = await prisma.iAQuota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IAQuotaDeleteManyArgs>(args?: SelectSubset<T, IAQuotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IAQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IAQuotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IAQuotas
     * const iAQuota = await prisma.iAQuota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IAQuotaUpdateManyArgs>(args: SelectSubset<T, IAQuotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IAQuota.
     * @param {IAQuotaUpsertArgs} args - Arguments to update or create a IAQuota.
     * @example
     * // Update or create a IAQuota
     * const iAQuota = await prisma.iAQuota.upsert({
     *   create: {
     *     // ... data to create a IAQuota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IAQuota we want to update
     *   }
     * })
     */
    upsert<T extends IAQuotaUpsertArgs>(args: SelectSubset<T, IAQuotaUpsertArgs<ExtArgs>>): Prisma__IAQuotaClient<$Result.GetResult<Prisma.$IAQuotaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IAQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IAQuotaCountArgs} args - Arguments to filter IAQuotas to count.
     * @example
     * // Count the number of IAQuotas
     * const count = await prisma.iAQuota.count({
     *   where: {
     *     // ... the filter for the IAQuotas we want to count
     *   }
     * })
    **/
    count<T extends IAQuotaCountArgs>(
      args?: Subset<T, IAQuotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IAQuotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IAQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IAQuotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IAQuotaAggregateArgs>(args: Subset<T, IAQuotaAggregateArgs>): Prisma.PrismaPromise<GetIAQuotaAggregateType<T>>

    /**
     * Group by IAQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IAQuotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IAQuotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IAQuotaGroupByArgs['orderBy'] }
        : { orderBy?: IAQuotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IAQuotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIAQuotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IAQuota model
   */
  readonly fields: IAQuotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IAQuota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IAQuotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IAQuota model
   */ 
  interface IAQuotaFieldRefs {
    readonly id: FieldRef<"IAQuota", 'String'>
    readonly userId: FieldRef<"IAQuota", 'String'>
    readonly dailyQuota: FieldRef<"IAQuota", 'Int'>
    readonly premiumQuota: FieldRef<"IAQuota", 'Int'>
    readonly extrasUsed: FieldRef<"IAQuota", 'Int'>
    readonly resetAt: FieldRef<"IAQuota", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IAQuota findUnique
   */
  export type IAQuotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IAQuota
     */
    select?: IAQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IAQuotaInclude<ExtArgs> | null
    /**
     * Filter, which IAQuota to fetch.
     */
    where: IAQuotaWhereUniqueInput
  }

  /**
   * IAQuota findUniqueOrThrow
   */
  export type IAQuotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IAQuota
     */
    select?: IAQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IAQuotaInclude<ExtArgs> | null
    /**
     * Filter, which IAQuota to fetch.
     */
    where: IAQuotaWhereUniqueInput
  }

  /**
   * IAQuota findFirst
   */
  export type IAQuotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IAQuota
     */
    select?: IAQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IAQuotaInclude<ExtArgs> | null
    /**
     * Filter, which IAQuota to fetch.
     */
    where?: IAQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IAQuotas to fetch.
     */
    orderBy?: IAQuotaOrderByWithRelationInput | IAQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IAQuotas.
     */
    cursor?: IAQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IAQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IAQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IAQuotas.
     */
    distinct?: IAQuotaScalarFieldEnum | IAQuotaScalarFieldEnum[]
  }

  /**
   * IAQuota findFirstOrThrow
   */
  export type IAQuotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IAQuota
     */
    select?: IAQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IAQuotaInclude<ExtArgs> | null
    /**
     * Filter, which IAQuota to fetch.
     */
    where?: IAQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IAQuotas to fetch.
     */
    orderBy?: IAQuotaOrderByWithRelationInput | IAQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IAQuotas.
     */
    cursor?: IAQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IAQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IAQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IAQuotas.
     */
    distinct?: IAQuotaScalarFieldEnum | IAQuotaScalarFieldEnum[]
  }

  /**
   * IAQuota findMany
   */
  export type IAQuotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IAQuota
     */
    select?: IAQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IAQuotaInclude<ExtArgs> | null
    /**
     * Filter, which IAQuotas to fetch.
     */
    where?: IAQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IAQuotas to fetch.
     */
    orderBy?: IAQuotaOrderByWithRelationInput | IAQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IAQuotas.
     */
    cursor?: IAQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IAQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IAQuotas.
     */
    skip?: number
    distinct?: IAQuotaScalarFieldEnum | IAQuotaScalarFieldEnum[]
  }

  /**
   * IAQuota create
   */
  export type IAQuotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IAQuota
     */
    select?: IAQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IAQuotaInclude<ExtArgs> | null
    /**
     * The data needed to create a IAQuota.
     */
    data: XOR<IAQuotaCreateInput, IAQuotaUncheckedCreateInput>
  }

  /**
   * IAQuota createMany
   */
  export type IAQuotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IAQuotas.
     */
    data: IAQuotaCreateManyInput | IAQuotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IAQuota createManyAndReturn
   */
  export type IAQuotaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IAQuota
     */
    select?: IAQuotaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IAQuotas.
     */
    data: IAQuotaCreateManyInput | IAQuotaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IAQuotaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IAQuota update
   */
  export type IAQuotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IAQuota
     */
    select?: IAQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IAQuotaInclude<ExtArgs> | null
    /**
     * The data needed to update a IAQuota.
     */
    data: XOR<IAQuotaUpdateInput, IAQuotaUncheckedUpdateInput>
    /**
     * Choose, which IAQuota to update.
     */
    where: IAQuotaWhereUniqueInput
  }

  /**
   * IAQuota updateMany
   */
  export type IAQuotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IAQuotas.
     */
    data: XOR<IAQuotaUpdateManyMutationInput, IAQuotaUncheckedUpdateManyInput>
    /**
     * Filter which IAQuotas to update
     */
    where?: IAQuotaWhereInput
  }

  /**
   * IAQuota upsert
   */
  export type IAQuotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IAQuota
     */
    select?: IAQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IAQuotaInclude<ExtArgs> | null
    /**
     * The filter to search for the IAQuota to update in case it exists.
     */
    where: IAQuotaWhereUniqueInput
    /**
     * In case the IAQuota found by the `where` argument doesn't exist, create a new IAQuota with this data.
     */
    create: XOR<IAQuotaCreateInput, IAQuotaUncheckedCreateInput>
    /**
     * In case the IAQuota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IAQuotaUpdateInput, IAQuotaUncheckedUpdateInput>
  }

  /**
   * IAQuota delete
   */
  export type IAQuotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IAQuota
     */
    select?: IAQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IAQuotaInclude<ExtArgs> | null
    /**
     * Filter which IAQuota to delete.
     */
    where: IAQuotaWhereUniqueInput
  }

  /**
   * IAQuota deleteMany
   */
  export type IAQuotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IAQuotas to delete
     */
    where?: IAQuotaWhereInput
  }

  /**
   * IAQuota without action
   */
  export type IAQuotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IAQuota
     */
    select?: IAQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IAQuotaInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    jti: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    jti: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    userId: number
    tokenHash: number
    jti: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    jti?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    jti?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    jti?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    userId: string
    tokenHash: string
    jti: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    jti?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    jti?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    jti?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tokenHash: string
      jti: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */ 
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly tokenHash: FieldRef<"UserSession", 'String'>
    readonly jti: FieldRef<"UserSession", 'String'>
    readonly expiresAt: FieldRef<"UserSession", 'DateTime'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model chat_messages
   */

  export type AggregateChat_messages = {
    _count: Chat_messagesCountAggregateOutputType | null
    _min: Chat_messagesMinAggregateOutputType | null
    _max: Chat_messagesMaxAggregateOutputType | null
  }

  export type Chat_messagesMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    userId: string | null
    message: string | null
    messageType: $Enums.MessageType | null
    createdAt: Date | null
  }

  export type Chat_messagesMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    userId: string | null
    message: string | null
    messageType: $Enums.MessageType | null
    createdAt: Date | null
  }

  export type Chat_messagesCountAggregateOutputType = {
    id: number
    gameId: number
    userId: number
    message: number
    messageType: number
    createdAt: number
    _all: number
  }


  export type Chat_messagesMinAggregateInputType = {
    id?: true
    gameId?: true
    userId?: true
    message?: true
    messageType?: true
    createdAt?: true
  }

  export type Chat_messagesMaxAggregateInputType = {
    id?: true
    gameId?: true
    userId?: true
    message?: true
    messageType?: true
    createdAt?: true
  }

  export type Chat_messagesCountAggregateInputType = {
    id?: true
    gameId?: true
    userId?: true
    message?: true
    messageType?: true
    createdAt?: true
    _all?: true
  }

  export type Chat_messagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_messages to aggregate.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chat_messages
    **/
    _count?: true | Chat_messagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Chat_messagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Chat_messagesMaxAggregateInputType
  }

  export type GetChat_messagesAggregateType<T extends Chat_messagesAggregateArgs> = {
        [P in keyof T & keyof AggregateChat_messages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat_messages[P]>
      : GetScalarType<T[P], AggregateChat_messages[P]>
  }




  export type chat_messagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_messagesWhereInput
    orderBy?: chat_messagesOrderByWithAggregationInput | chat_messagesOrderByWithAggregationInput[]
    by: Chat_messagesScalarFieldEnum[] | Chat_messagesScalarFieldEnum
    having?: chat_messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Chat_messagesCountAggregateInputType | true
    _min?: Chat_messagesMinAggregateInputType
    _max?: Chat_messagesMaxAggregateInputType
  }

  export type Chat_messagesGroupByOutputType = {
    id: string
    gameId: string
    userId: string | null
    message: string
    messageType: $Enums.MessageType
    createdAt: Date
    _count: Chat_messagesCountAggregateOutputType | null
    _min: Chat_messagesMinAggregateOutputType | null
    _max: Chat_messagesMaxAggregateOutputType | null
  }

  type GetChat_messagesGroupByPayload<T extends chat_messagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Chat_messagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Chat_messagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Chat_messagesGroupByOutputType[P]>
            : GetScalarType<T[P], Chat_messagesGroupByOutputType[P]>
        }
      >
    >


  export type chat_messagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    userId?: boolean
    message?: boolean
    messageType?: boolean
    createdAt?: boolean
    game?: boolean | gamesDefaultArgs<ExtArgs>
    user?: boolean | chat_messages$userArgs<ExtArgs>
  }, ExtArgs["result"]["chat_messages"]>

  export type chat_messagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    userId?: boolean
    message?: boolean
    messageType?: boolean
    createdAt?: boolean
    game?: boolean | gamesDefaultArgs<ExtArgs>
    user?: boolean | chat_messages$userArgs<ExtArgs>
  }, ExtArgs["result"]["chat_messages"]>

  export type chat_messagesSelectScalar = {
    id?: boolean
    gameId?: boolean
    userId?: boolean
    message?: boolean
    messageType?: boolean
    createdAt?: boolean
  }

  export type chat_messagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | gamesDefaultArgs<ExtArgs>
    user?: boolean | chat_messages$userArgs<ExtArgs>
  }
  export type chat_messagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | gamesDefaultArgs<ExtArgs>
    user?: boolean | chat_messages$userArgs<ExtArgs>
  }

  export type $chat_messagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chat_messages"
    objects: {
      game: Prisma.$gamesPayload<ExtArgs>
      user: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      userId: string | null
      message: string
      messageType: $Enums.MessageType
      createdAt: Date
    }, ExtArgs["result"]["chat_messages"]>
    composites: {}
  }

  type chat_messagesGetPayload<S extends boolean | null | undefined | chat_messagesDefaultArgs> = $Result.GetResult<Prisma.$chat_messagesPayload, S>

  type chat_messagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<chat_messagesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Chat_messagesCountAggregateInputType | true
    }

  export interface chat_messagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chat_messages'], meta: { name: 'chat_messages' } }
    /**
     * Find zero or one Chat_messages that matches the filter.
     * @param {chat_messagesFindUniqueArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chat_messagesFindUniqueArgs>(args: SelectSubset<T, chat_messagesFindUniqueArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Chat_messages that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {chat_messagesFindUniqueOrThrowArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chat_messagesFindUniqueOrThrowArgs>(args: SelectSubset<T, chat_messagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Chat_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesFindFirstArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chat_messagesFindFirstArgs>(args?: SelectSubset<T, chat_messagesFindFirstArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Chat_messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesFindFirstOrThrowArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chat_messagesFindFirstOrThrowArgs>(args?: SelectSubset<T, chat_messagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Chat_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chat_messages
     * const chat_messages = await prisma.chat_messages.findMany()
     * 
     * // Get first 10 Chat_messages
     * const chat_messages = await prisma.chat_messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chat_messagesWithIdOnly = await prisma.chat_messages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chat_messagesFindManyArgs>(args?: SelectSubset<T, chat_messagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Chat_messages.
     * @param {chat_messagesCreateArgs} args - Arguments to create a Chat_messages.
     * @example
     * // Create one Chat_messages
     * const Chat_messages = await prisma.chat_messages.create({
     *   data: {
     *     // ... data to create a Chat_messages
     *   }
     * })
     * 
     */
    create<T extends chat_messagesCreateArgs>(args: SelectSubset<T, chat_messagesCreateArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Chat_messages.
     * @param {chat_messagesCreateManyArgs} args - Arguments to create many Chat_messages.
     * @example
     * // Create many Chat_messages
     * const chat_messages = await prisma.chat_messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chat_messagesCreateManyArgs>(args?: SelectSubset<T, chat_messagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chat_messages and returns the data saved in the database.
     * @param {chat_messagesCreateManyAndReturnArgs} args - Arguments to create many Chat_messages.
     * @example
     * // Create many Chat_messages
     * const chat_messages = await prisma.chat_messages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chat_messages and only return the `id`
     * const chat_messagesWithIdOnly = await prisma.chat_messages.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chat_messagesCreateManyAndReturnArgs>(args?: SelectSubset<T, chat_messagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Chat_messages.
     * @param {chat_messagesDeleteArgs} args - Arguments to delete one Chat_messages.
     * @example
     * // Delete one Chat_messages
     * const Chat_messages = await prisma.chat_messages.delete({
     *   where: {
     *     // ... filter to delete one Chat_messages
     *   }
     * })
     * 
     */
    delete<T extends chat_messagesDeleteArgs>(args: SelectSubset<T, chat_messagesDeleteArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Chat_messages.
     * @param {chat_messagesUpdateArgs} args - Arguments to update one Chat_messages.
     * @example
     * // Update one Chat_messages
     * const chat_messages = await prisma.chat_messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chat_messagesUpdateArgs>(args: SelectSubset<T, chat_messagesUpdateArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Chat_messages.
     * @param {chat_messagesDeleteManyArgs} args - Arguments to filter Chat_messages to delete.
     * @example
     * // Delete a few Chat_messages
     * const { count } = await prisma.chat_messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chat_messagesDeleteManyArgs>(args?: SelectSubset<T, chat_messagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chat_messages
     * const chat_messages = await prisma.chat_messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chat_messagesUpdateManyArgs>(args: SelectSubset<T, chat_messagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chat_messages.
     * @param {chat_messagesUpsertArgs} args - Arguments to update or create a Chat_messages.
     * @example
     * // Update or create a Chat_messages
     * const chat_messages = await prisma.chat_messages.upsert({
     *   create: {
     *     // ... data to create a Chat_messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat_messages we want to update
     *   }
     * })
     */
    upsert<T extends chat_messagesUpsertArgs>(args: SelectSubset<T, chat_messagesUpsertArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesCountArgs} args - Arguments to filter Chat_messages to count.
     * @example
     * // Count the number of Chat_messages
     * const count = await prisma.chat_messages.count({
     *   where: {
     *     // ... the filter for the Chat_messages we want to count
     *   }
     * })
    **/
    count<T extends chat_messagesCountArgs>(
      args?: Subset<T, chat_messagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Chat_messagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chat_messagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Chat_messagesAggregateArgs>(args: Subset<T, Chat_messagesAggregateArgs>): Prisma.PrismaPromise<GetChat_messagesAggregateType<T>>

    /**
     * Group by Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chat_messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chat_messagesGroupByArgs['orderBy'] }
        : { orderBy?: chat_messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chat_messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChat_messagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chat_messages model
   */
  readonly fields: chat_messagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chat_messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chat_messagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends gamesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, gamesDefaultArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends chat_messages$userArgs<ExtArgs> = {}>(args?: Subset<T, chat_messages$userArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chat_messages model
   */ 
  interface chat_messagesFieldRefs {
    readonly id: FieldRef<"chat_messages", 'String'>
    readonly gameId: FieldRef<"chat_messages", 'String'>
    readonly userId: FieldRef<"chat_messages", 'String'>
    readonly message: FieldRef<"chat_messages", 'String'>
    readonly messageType: FieldRef<"chat_messages", 'MessageType'>
    readonly createdAt: FieldRef<"chat_messages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * chat_messages findUnique
   */
  export type chat_messagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages findUniqueOrThrow
   */
  export type chat_messagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages findFirst
   */
  export type chat_messagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_messages.
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_messages.
     */
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * chat_messages findFirstOrThrow
   */
  export type chat_messagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_messages.
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_messages.
     */
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * chat_messages findMany
   */
  export type chat_messagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chat_messages.
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * chat_messages create
   */
  export type chat_messagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * The data needed to create a chat_messages.
     */
    data: XOR<chat_messagesCreateInput, chat_messagesUncheckedCreateInput>
  }

  /**
   * chat_messages createMany
   */
  export type chat_messagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chat_messages.
     */
    data: chat_messagesCreateManyInput | chat_messagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chat_messages createManyAndReturn
   */
  export type chat_messagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many chat_messages.
     */
    data: chat_messagesCreateManyInput | chat_messagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chat_messages update
   */
  export type chat_messagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * The data needed to update a chat_messages.
     */
    data: XOR<chat_messagesUpdateInput, chat_messagesUncheckedUpdateInput>
    /**
     * Choose, which chat_messages to update.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages updateMany
   */
  export type chat_messagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chat_messages.
     */
    data: XOR<chat_messagesUpdateManyMutationInput, chat_messagesUncheckedUpdateManyInput>
    /**
     * Filter which chat_messages to update
     */
    where?: chat_messagesWhereInput
  }

  /**
   * chat_messages upsert
   */
  export type chat_messagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * The filter to search for the chat_messages to update in case it exists.
     */
    where: chat_messagesWhereUniqueInput
    /**
     * In case the chat_messages found by the `where` argument doesn't exist, create a new chat_messages with this data.
     */
    create: XOR<chat_messagesCreateInput, chat_messagesUncheckedCreateInput>
    /**
     * In case the chat_messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chat_messagesUpdateInput, chat_messagesUncheckedUpdateInput>
  }

  /**
   * chat_messages delete
   */
  export type chat_messagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter which chat_messages to delete.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages deleteMany
   */
  export type chat_messagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_messages to delete
     */
    where?: chat_messagesWhereInput
  }

  /**
   * chat_messages.user
   */
  export type chat_messages$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * chat_messages without action
   */
  export type chat_messagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
  }


  /**
   * Model game_moves
   */

  export type AggregateGame_moves = {
    _count: Game_movesCountAggregateOutputType | null
    _avg: Game_movesAvgAggregateOutputType | null
    _sum: Game_movesSumAggregateOutputType | null
    _min: Game_movesMinAggregateOutputType | null
    _max: Game_movesMaxAggregateOutputType | null
  }

  export type Game_movesAvgAggregateOutputType = {
    dice: number | null
    fromPoint: number | null
    toPoint: number | null
    equity: number | null
    pr: number | null
    thinkingTime: number | null
  }

  export type Game_movesSumAggregateOutputType = {
    dice: number[]
    fromPoint: number | null
    toPoint: number | null
    equity: number | null
    pr: number | null
    thinkingTime: number | null
  }

  export type Game_movesMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    userId: string | null
    player: $Enums.Player | null
    move: string | null
    fromPoint: number | null
    toPoint: number | null
    equity: number | null
    pr: number | null
    thinkingTime: number | null
    createdAt: Date | null
  }

  export type Game_movesMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    userId: string | null
    player: $Enums.Player | null
    move: string | null
    fromPoint: number | null
    toPoint: number | null
    equity: number | null
    pr: number | null
    thinkingTime: number | null
    createdAt: Date | null
  }

  export type Game_movesCountAggregateOutputType = {
    id: number
    gameId: number
    userId: number
    player: number
    dice: number
    move: number
    fromPoint: number
    toPoint: number
    equity: number
    pr: number
    thinkingTime: number
    createdAt: number
    _all: number
  }


  export type Game_movesAvgAggregateInputType = {
    dice?: true
    fromPoint?: true
    toPoint?: true
    equity?: true
    pr?: true
    thinkingTime?: true
  }

  export type Game_movesSumAggregateInputType = {
    dice?: true
    fromPoint?: true
    toPoint?: true
    equity?: true
    pr?: true
    thinkingTime?: true
  }

  export type Game_movesMinAggregateInputType = {
    id?: true
    gameId?: true
    userId?: true
    player?: true
    move?: true
    fromPoint?: true
    toPoint?: true
    equity?: true
    pr?: true
    thinkingTime?: true
    createdAt?: true
  }

  export type Game_movesMaxAggregateInputType = {
    id?: true
    gameId?: true
    userId?: true
    player?: true
    move?: true
    fromPoint?: true
    toPoint?: true
    equity?: true
    pr?: true
    thinkingTime?: true
    createdAt?: true
  }

  export type Game_movesCountAggregateInputType = {
    id?: true
    gameId?: true
    userId?: true
    player?: true
    dice?: true
    move?: true
    fromPoint?: true
    toPoint?: true
    equity?: true
    pr?: true
    thinkingTime?: true
    createdAt?: true
    _all?: true
  }

  export type Game_movesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which game_moves to aggregate.
     */
    where?: game_movesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_moves to fetch.
     */
    orderBy?: game_movesOrderByWithRelationInput | game_movesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: game_movesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_moves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_moves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned game_moves
    **/
    _count?: true | Game_movesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Game_movesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Game_movesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Game_movesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Game_movesMaxAggregateInputType
  }

  export type GetGame_movesAggregateType<T extends Game_movesAggregateArgs> = {
        [P in keyof T & keyof AggregateGame_moves]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame_moves[P]>
      : GetScalarType<T[P], AggregateGame_moves[P]>
  }




  export type game_movesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: game_movesWhereInput
    orderBy?: game_movesOrderByWithAggregationInput | game_movesOrderByWithAggregationInput[]
    by: Game_movesScalarFieldEnum[] | Game_movesScalarFieldEnum
    having?: game_movesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Game_movesCountAggregateInputType | true
    _avg?: Game_movesAvgAggregateInputType
    _sum?: Game_movesSumAggregateInputType
    _min?: Game_movesMinAggregateInputType
    _max?: Game_movesMaxAggregateInputType
  }

  export type Game_movesGroupByOutputType = {
    id: string
    gameId: string
    userId: string | null
    player: $Enums.Player
    dice: number[]
    move: string
    fromPoint: number | null
    toPoint: number | null
    equity: number | null
    pr: number | null
    thinkingTime: number | null
    createdAt: Date
    _count: Game_movesCountAggregateOutputType | null
    _avg: Game_movesAvgAggregateOutputType | null
    _sum: Game_movesSumAggregateOutputType | null
    _min: Game_movesMinAggregateOutputType | null
    _max: Game_movesMaxAggregateOutputType | null
  }

  type GetGame_movesGroupByPayload<T extends game_movesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Game_movesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Game_movesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Game_movesGroupByOutputType[P]>
            : GetScalarType<T[P], Game_movesGroupByOutputType[P]>
        }
      >
    >


  export type game_movesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    userId?: boolean
    player?: boolean
    dice?: boolean
    move?: boolean
    fromPoint?: boolean
    toPoint?: boolean
    equity?: boolean
    pr?: boolean
    thinkingTime?: boolean
    createdAt?: boolean
    game?: boolean | gamesDefaultArgs<ExtArgs>
    user?: boolean | game_moves$userArgs<ExtArgs>
  }, ExtArgs["result"]["game_moves"]>

  export type game_movesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    userId?: boolean
    player?: boolean
    dice?: boolean
    move?: boolean
    fromPoint?: boolean
    toPoint?: boolean
    equity?: boolean
    pr?: boolean
    thinkingTime?: boolean
    createdAt?: boolean
    game?: boolean | gamesDefaultArgs<ExtArgs>
    user?: boolean | game_moves$userArgs<ExtArgs>
  }, ExtArgs["result"]["game_moves"]>

  export type game_movesSelectScalar = {
    id?: boolean
    gameId?: boolean
    userId?: boolean
    player?: boolean
    dice?: boolean
    move?: boolean
    fromPoint?: boolean
    toPoint?: boolean
    equity?: boolean
    pr?: boolean
    thinkingTime?: boolean
    createdAt?: boolean
  }

  export type game_movesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | gamesDefaultArgs<ExtArgs>
    user?: boolean | game_moves$userArgs<ExtArgs>
  }
  export type game_movesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | gamesDefaultArgs<ExtArgs>
    user?: boolean | game_moves$userArgs<ExtArgs>
  }

  export type $game_movesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "game_moves"
    objects: {
      game: Prisma.$gamesPayload<ExtArgs>
      user: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      userId: string | null
      player: $Enums.Player
      dice: number[]
      move: string
      fromPoint: number | null
      toPoint: number | null
      equity: number | null
      pr: number | null
      thinkingTime: number | null
      createdAt: Date
    }, ExtArgs["result"]["game_moves"]>
    composites: {}
  }

  type game_movesGetPayload<S extends boolean | null | undefined | game_movesDefaultArgs> = $Result.GetResult<Prisma.$game_movesPayload, S>

  type game_movesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<game_movesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Game_movesCountAggregateInputType | true
    }

  export interface game_movesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['game_moves'], meta: { name: 'game_moves' } }
    /**
     * Find zero or one Game_moves that matches the filter.
     * @param {game_movesFindUniqueArgs} args - Arguments to find a Game_moves
     * @example
     * // Get one Game_moves
     * const game_moves = await prisma.game_moves.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends game_movesFindUniqueArgs>(args: SelectSubset<T, game_movesFindUniqueArgs<ExtArgs>>): Prisma__game_movesClient<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Game_moves that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {game_movesFindUniqueOrThrowArgs} args - Arguments to find a Game_moves
     * @example
     * // Get one Game_moves
     * const game_moves = await prisma.game_moves.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends game_movesFindUniqueOrThrowArgs>(args: SelectSubset<T, game_movesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__game_movesClient<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Game_moves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_movesFindFirstArgs} args - Arguments to find a Game_moves
     * @example
     * // Get one Game_moves
     * const game_moves = await prisma.game_moves.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends game_movesFindFirstArgs>(args?: SelectSubset<T, game_movesFindFirstArgs<ExtArgs>>): Prisma__game_movesClient<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Game_moves that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_movesFindFirstOrThrowArgs} args - Arguments to find a Game_moves
     * @example
     * // Get one Game_moves
     * const game_moves = await prisma.game_moves.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends game_movesFindFirstOrThrowArgs>(args?: SelectSubset<T, game_movesFindFirstOrThrowArgs<ExtArgs>>): Prisma__game_movesClient<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Game_moves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_movesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Game_moves
     * const game_moves = await prisma.game_moves.findMany()
     * 
     * // Get first 10 Game_moves
     * const game_moves = await prisma.game_moves.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const game_movesWithIdOnly = await prisma.game_moves.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends game_movesFindManyArgs>(args?: SelectSubset<T, game_movesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Game_moves.
     * @param {game_movesCreateArgs} args - Arguments to create a Game_moves.
     * @example
     * // Create one Game_moves
     * const Game_moves = await prisma.game_moves.create({
     *   data: {
     *     // ... data to create a Game_moves
     *   }
     * })
     * 
     */
    create<T extends game_movesCreateArgs>(args: SelectSubset<T, game_movesCreateArgs<ExtArgs>>): Prisma__game_movesClient<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Game_moves.
     * @param {game_movesCreateManyArgs} args - Arguments to create many Game_moves.
     * @example
     * // Create many Game_moves
     * const game_moves = await prisma.game_moves.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends game_movesCreateManyArgs>(args?: SelectSubset<T, game_movesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Game_moves and returns the data saved in the database.
     * @param {game_movesCreateManyAndReturnArgs} args - Arguments to create many Game_moves.
     * @example
     * // Create many Game_moves
     * const game_moves = await prisma.game_moves.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Game_moves and only return the `id`
     * const game_movesWithIdOnly = await prisma.game_moves.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends game_movesCreateManyAndReturnArgs>(args?: SelectSubset<T, game_movesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Game_moves.
     * @param {game_movesDeleteArgs} args - Arguments to delete one Game_moves.
     * @example
     * // Delete one Game_moves
     * const Game_moves = await prisma.game_moves.delete({
     *   where: {
     *     // ... filter to delete one Game_moves
     *   }
     * })
     * 
     */
    delete<T extends game_movesDeleteArgs>(args: SelectSubset<T, game_movesDeleteArgs<ExtArgs>>): Prisma__game_movesClient<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Game_moves.
     * @param {game_movesUpdateArgs} args - Arguments to update one Game_moves.
     * @example
     * // Update one Game_moves
     * const game_moves = await prisma.game_moves.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends game_movesUpdateArgs>(args: SelectSubset<T, game_movesUpdateArgs<ExtArgs>>): Prisma__game_movesClient<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Game_moves.
     * @param {game_movesDeleteManyArgs} args - Arguments to filter Game_moves to delete.
     * @example
     * // Delete a few Game_moves
     * const { count } = await prisma.game_moves.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends game_movesDeleteManyArgs>(args?: SelectSubset<T, game_movesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Game_moves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_movesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Game_moves
     * const game_moves = await prisma.game_moves.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends game_movesUpdateManyArgs>(args: SelectSubset<T, game_movesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Game_moves.
     * @param {game_movesUpsertArgs} args - Arguments to update or create a Game_moves.
     * @example
     * // Update or create a Game_moves
     * const game_moves = await prisma.game_moves.upsert({
     *   create: {
     *     // ... data to create a Game_moves
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game_moves we want to update
     *   }
     * })
     */
    upsert<T extends game_movesUpsertArgs>(args: SelectSubset<T, game_movesUpsertArgs<ExtArgs>>): Prisma__game_movesClient<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Game_moves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_movesCountArgs} args - Arguments to filter Game_moves to count.
     * @example
     * // Count the number of Game_moves
     * const count = await prisma.game_moves.count({
     *   where: {
     *     // ... the filter for the Game_moves we want to count
     *   }
     * })
    **/
    count<T extends game_movesCountArgs>(
      args?: Subset<T, game_movesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Game_movesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game_moves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_movesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Game_movesAggregateArgs>(args: Subset<T, Game_movesAggregateArgs>): Prisma.PrismaPromise<GetGame_movesAggregateType<T>>

    /**
     * Group by Game_moves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_movesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends game_movesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: game_movesGroupByArgs['orderBy'] }
        : { orderBy?: game_movesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, game_movesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGame_movesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the game_moves model
   */
  readonly fields: game_movesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for game_moves.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__game_movesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends gamesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, gamesDefaultArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends game_moves$userArgs<ExtArgs> = {}>(args?: Subset<T, game_moves$userArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the game_moves model
   */ 
  interface game_movesFieldRefs {
    readonly id: FieldRef<"game_moves", 'String'>
    readonly gameId: FieldRef<"game_moves", 'String'>
    readonly userId: FieldRef<"game_moves", 'String'>
    readonly player: FieldRef<"game_moves", 'Player'>
    readonly dice: FieldRef<"game_moves", 'Int[]'>
    readonly move: FieldRef<"game_moves", 'String'>
    readonly fromPoint: FieldRef<"game_moves", 'Int'>
    readonly toPoint: FieldRef<"game_moves", 'Int'>
    readonly equity: FieldRef<"game_moves", 'Float'>
    readonly pr: FieldRef<"game_moves", 'Float'>
    readonly thinkingTime: FieldRef<"game_moves", 'Int'>
    readonly createdAt: FieldRef<"game_moves", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * game_moves findUnique
   */
  export type game_movesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    /**
     * Filter, which game_moves to fetch.
     */
    where: game_movesWhereUniqueInput
  }

  /**
   * game_moves findUniqueOrThrow
   */
  export type game_movesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    /**
     * Filter, which game_moves to fetch.
     */
    where: game_movesWhereUniqueInput
  }

  /**
   * game_moves findFirst
   */
  export type game_movesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    /**
     * Filter, which game_moves to fetch.
     */
    where?: game_movesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_moves to fetch.
     */
    orderBy?: game_movesOrderByWithRelationInput | game_movesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for game_moves.
     */
    cursor?: game_movesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_moves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_moves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of game_moves.
     */
    distinct?: Game_movesScalarFieldEnum | Game_movesScalarFieldEnum[]
  }

  /**
   * game_moves findFirstOrThrow
   */
  export type game_movesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    /**
     * Filter, which game_moves to fetch.
     */
    where?: game_movesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_moves to fetch.
     */
    orderBy?: game_movesOrderByWithRelationInput | game_movesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for game_moves.
     */
    cursor?: game_movesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_moves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_moves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of game_moves.
     */
    distinct?: Game_movesScalarFieldEnum | Game_movesScalarFieldEnum[]
  }

  /**
   * game_moves findMany
   */
  export type game_movesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    /**
     * Filter, which game_moves to fetch.
     */
    where?: game_movesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_moves to fetch.
     */
    orderBy?: game_movesOrderByWithRelationInput | game_movesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing game_moves.
     */
    cursor?: game_movesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_moves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_moves.
     */
    skip?: number
    distinct?: Game_movesScalarFieldEnum | Game_movesScalarFieldEnum[]
  }

  /**
   * game_moves create
   */
  export type game_movesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    /**
     * The data needed to create a game_moves.
     */
    data: XOR<game_movesCreateInput, game_movesUncheckedCreateInput>
  }

  /**
   * game_moves createMany
   */
  export type game_movesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many game_moves.
     */
    data: game_movesCreateManyInput | game_movesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * game_moves createManyAndReturn
   */
  export type game_movesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many game_moves.
     */
    data: game_movesCreateManyInput | game_movesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * game_moves update
   */
  export type game_movesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    /**
     * The data needed to update a game_moves.
     */
    data: XOR<game_movesUpdateInput, game_movesUncheckedUpdateInput>
    /**
     * Choose, which game_moves to update.
     */
    where: game_movesWhereUniqueInput
  }

  /**
   * game_moves updateMany
   */
  export type game_movesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update game_moves.
     */
    data: XOR<game_movesUpdateManyMutationInput, game_movesUncheckedUpdateManyInput>
    /**
     * Filter which game_moves to update
     */
    where?: game_movesWhereInput
  }

  /**
   * game_moves upsert
   */
  export type game_movesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    /**
     * The filter to search for the game_moves to update in case it exists.
     */
    where: game_movesWhereUniqueInput
    /**
     * In case the game_moves found by the `where` argument doesn't exist, create a new game_moves with this data.
     */
    create: XOR<game_movesCreateInput, game_movesUncheckedCreateInput>
    /**
     * In case the game_moves was found with the provided `where` argument, update it with this data.
     */
    update: XOR<game_movesUpdateInput, game_movesUncheckedUpdateInput>
  }

  /**
   * game_moves delete
   */
  export type game_movesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    /**
     * Filter which game_moves to delete.
     */
    where: game_movesWhereUniqueInput
  }

  /**
   * game_moves deleteMany
   */
  export type game_movesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which game_moves to delete
     */
    where?: game_movesWhereInput
  }

  /**
   * game_moves.user
   */
  export type game_moves$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * game_moves without action
   */
  export type game_movesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
  }


  /**
   * Model subscriptions
   */

  export type AggregateSubscriptions = {
    _count: SubscriptionsCountAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  export type SubscriptionsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    stripe_subscription_id: string | null
    stripe_customer_id: string | null
    plan: $Enums.SubscriptionPlan | null
    status: $Enums.SubscriptionStatus | null
    current_period_start: Date | null
    current_period_end: Date | null
    cancel_at_period_end: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    stripe_subscription_id: string | null
    stripe_customer_id: string | null
    plan: $Enums.SubscriptionPlan | null
    status: $Enums.SubscriptionStatus | null
    current_period_start: Date | null
    current_period_end: Date | null
    cancel_at_period_end: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionsCountAggregateOutputType = {
    id: number
    user_id: number
    stripe_subscription_id: number
    stripe_customer_id: number
    plan: number
    status: number
    current_period_start: number
    current_period_end: number
    cancel_at_period_end: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionsMinAggregateInputType = {
    id?: true
    user_id?: true
    stripe_subscription_id?: true
    stripe_customer_id?: true
    plan?: true
    status?: true
    current_period_start?: true
    current_period_end?: true
    cancel_at_period_end?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionsMaxAggregateInputType = {
    id?: true
    user_id?: true
    stripe_subscription_id?: true
    stripe_customer_id?: true
    plan?: true
    status?: true
    current_period_start?: true
    current_period_end?: true
    cancel_at_period_end?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionsCountAggregateInputType = {
    id?: true
    user_id?: true
    stripe_subscription_id?: true
    stripe_customer_id?: true
    plan?: true
    status?: true
    current_period_start?: true
    current_period_end?: true
    cancel_at_period_end?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscriptions to aggregate.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subscriptions
    **/
    _count?: true | SubscriptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type GetSubscriptionsAggregateType<T extends SubscriptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptions[P]>
      : GetScalarType<T[P], AggregateSubscriptions[P]>
  }




  export type subscriptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subscriptionsWhereInput
    orderBy?: subscriptionsOrderByWithAggregationInput | subscriptionsOrderByWithAggregationInput[]
    by: SubscriptionsScalarFieldEnum[] | SubscriptionsScalarFieldEnum
    having?: subscriptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionsCountAggregateInputType | true
    _min?: SubscriptionsMinAggregateInputType
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type SubscriptionsGroupByOutputType = {
    id: string
    user_id: string
    stripe_subscription_id: string | null
    stripe_customer_id: string | null
    plan: $Enums.SubscriptionPlan
    status: $Enums.SubscriptionStatus
    current_period_start: Date | null
    current_period_end: Date | null
    cancel_at_period_end: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionsCountAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  type GetSubscriptionsGroupByPayload<T extends subscriptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
        }
      >
    >


  export type subscriptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    stripe_subscription_id?: boolean
    stripe_customer_id?: boolean
    plan?: boolean
    status?: boolean
    current_period_start?: boolean
    current_period_end?: boolean
    cancel_at_period_end?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptions"]>

  export type subscriptionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    stripe_subscription_id?: boolean
    stripe_customer_id?: boolean
    plan?: boolean
    status?: boolean
    current_period_start?: boolean
    current_period_end?: boolean
    cancel_at_period_end?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptions"]>

  export type subscriptionsSelectScalar = {
    id?: boolean
    user_id?: boolean
    stripe_subscription_id?: boolean
    stripe_customer_id?: boolean
    plan?: boolean
    status?: boolean
    current_period_start?: boolean
    current_period_end?: boolean
    cancel_at_period_end?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type subscriptionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type subscriptionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $subscriptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subscriptions"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      stripe_subscription_id: string | null
      stripe_customer_id: string | null
      plan: $Enums.SubscriptionPlan
      status: $Enums.SubscriptionStatus
      current_period_start: Date | null
      current_period_end: Date | null
      cancel_at_period_end: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriptions"]>
    composites: {}
  }

  type subscriptionsGetPayload<S extends boolean | null | undefined | subscriptionsDefaultArgs> = $Result.GetResult<Prisma.$subscriptionsPayload, S>

  type subscriptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<subscriptionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionsCountAggregateInputType | true
    }

  export interface subscriptionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subscriptions'], meta: { name: 'subscriptions' } }
    /**
     * Find zero or one Subscriptions that matches the filter.
     * @param {subscriptionsFindUniqueArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subscriptionsFindUniqueArgs>(args: SelectSubset<T, subscriptionsFindUniqueArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscriptions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {subscriptionsFindUniqueOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subscriptionsFindUniqueOrThrowArgs>(args: SelectSubset<T, subscriptionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindFirstArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subscriptionsFindFirstArgs>(args?: SelectSubset<T, subscriptionsFindFirstArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscriptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindFirstOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subscriptionsFindFirstOrThrowArgs>(args?: SelectSubset<T, subscriptionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends subscriptionsFindManyArgs>(args?: SelectSubset<T, subscriptionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscriptions.
     * @param {subscriptionsCreateArgs} args - Arguments to create a Subscriptions.
     * @example
     * // Create one Subscriptions
     * const Subscriptions = await prisma.subscriptions.create({
     *   data: {
     *     // ... data to create a Subscriptions
     *   }
     * })
     * 
     */
    create<T extends subscriptionsCreateArgs>(args: SelectSubset<T, subscriptionsCreateArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {subscriptionsCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subscriptionsCreateManyArgs>(args?: SelectSubset<T, subscriptionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {subscriptionsCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends subscriptionsCreateManyAndReturnArgs>(args?: SelectSubset<T, subscriptionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscriptions.
     * @param {subscriptionsDeleteArgs} args - Arguments to delete one Subscriptions.
     * @example
     * // Delete one Subscriptions
     * const Subscriptions = await prisma.subscriptions.delete({
     *   where: {
     *     // ... filter to delete one Subscriptions
     *   }
     * })
     * 
     */
    delete<T extends subscriptionsDeleteArgs>(args: SelectSubset<T, subscriptionsDeleteArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscriptions.
     * @param {subscriptionsUpdateArgs} args - Arguments to update one Subscriptions.
     * @example
     * // Update one Subscriptions
     * const subscriptions = await prisma.subscriptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subscriptionsUpdateArgs>(args: SelectSubset<T, subscriptionsUpdateArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {subscriptionsDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscriptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subscriptionsDeleteManyArgs>(args?: SelectSubset<T, subscriptionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscriptions = await prisma.subscriptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subscriptionsUpdateManyArgs>(args: SelectSubset<T, subscriptionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscriptions.
     * @param {subscriptionsUpsertArgs} args - Arguments to update or create a Subscriptions.
     * @example
     * // Update or create a Subscriptions
     * const subscriptions = await prisma.subscriptions.upsert({
     *   create: {
     *     // ... data to create a Subscriptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscriptions we want to update
     *   }
     * })
     */
    upsert<T extends subscriptionsUpsertArgs>(args: SelectSubset<T, subscriptionsUpsertArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscriptions.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends subscriptionsCountArgs>(
      args?: Subset<T, subscriptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionsAggregateArgs>(args: Subset<T, SubscriptionsAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionsAggregateType<T>>

    /**
     * Group by Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subscriptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subscriptionsGroupByArgs['orderBy'] }
        : { orderBy?: subscriptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subscriptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subscriptions model
   */
  readonly fields: subscriptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subscriptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subscriptionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subscriptions model
   */ 
  interface subscriptionsFieldRefs {
    readonly id: FieldRef<"subscriptions", 'String'>
    readonly user_id: FieldRef<"subscriptions", 'String'>
    readonly stripe_subscription_id: FieldRef<"subscriptions", 'String'>
    readonly stripe_customer_id: FieldRef<"subscriptions", 'String'>
    readonly plan: FieldRef<"subscriptions", 'SubscriptionPlan'>
    readonly status: FieldRef<"subscriptions", 'SubscriptionStatus'>
    readonly current_period_start: FieldRef<"subscriptions", 'DateTime'>
    readonly current_period_end: FieldRef<"subscriptions", 'DateTime'>
    readonly cancel_at_period_end: FieldRef<"subscriptions", 'Boolean'>
    readonly createdAt: FieldRef<"subscriptions", 'DateTime'>
    readonly updatedAt: FieldRef<"subscriptions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * subscriptions findUnique
   */
  export type subscriptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions findUniqueOrThrow
   */
  export type subscriptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions findFirst
   */
  export type subscriptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * subscriptions findFirstOrThrow
   */
  export type subscriptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * subscriptions findMany
   */
  export type subscriptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * subscriptions create
   */
  export type subscriptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to create a subscriptions.
     */
    data: XOR<subscriptionsCreateInput, subscriptionsUncheckedCreateInput>
  }

  /**
   * subscriptions createMany
   */
  export type subscriptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subscriptions.
     */
    data: subscriptionsCreateManyInput | subscriptionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subscriptions createManyAndReturn
   */
  export type subscriptionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many subscriptions.
     */
    data: subscriptionsCreateManyInput | subscriptionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * subscriptions update
   */
  export type subscriptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to update a subscriptions.
     */
    data: XOR<subscriptionsUpdateInput, subscriptionsUncheckedUpdateInput>
    /**
     * Choose, which subscriptions to update.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions updateMany
   */
  export type subscriptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subscriptions.
     */
    data: XOR<subscriptionsUpdateManyMutationInput, subscriptionsUncheckedUpdateManyInput>
    /**
     * Filter which subscriptions to update
     */
    where?: subscriptionsWhereInput
  }

  /**
   * subscriptions upsert
   */
  export type subscriptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * The filter to search for the subscriptions to update in case it exists.
     */
    where: subscriptionsWhereUniqueInput
    /**
     * In case the subscriptions found by the `where` argument doesn't exist, create a new subscriptions with this data.
     */
    create: XOR<subscriptionsCreateInput, subscriptionsUncheckedCreateInput>
    /**
     * In case the subscriptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subscriptionsUpdateInput, subscriptionsUncheckedUpdateInput>
  }

  /**
   * subscriptions delete
   */
  export type subscriptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter which subscriptions to delete.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions deleteMany
   */
  export type subscriptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscriptions to delete
     */
    where?: subscriptionsWhereInput
  }

  /**
   * subscriptions without action
   */
  export type subscriptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
  }


  /**
   * Model tournament_participants
   */

  export type AggregateTournament_participants = {
    _count: Tournament_participantsCountAggregateOutputType | null
    _avg: Tournament_participantsAvgAggregateOutputType | null
    _sum: Tournament_participantsSumAggregateOutputType | null
    _min: Tournament_participantsMinAggregateOutputType | null
    _max: Tournament_participantsMaxAggregateOutputType | null
  }

  export type Tournament_participantsAvgAggregateOutputType = {
    current_position: number | null
  }

  export type Tournament_participantsSumAggregateOutputType = {
    current_position: number | null
  }

  export type Tournament_participantsMinAggregateOutputType = {
    id: string | null
    tournament_id: string | null
    user_id: string | null
    registered_at: Date | null
    current_position: number | null
    eliminated_at: Date | null
  }

  export type Tournament_participantsMaxAggregateOutputType = {
    id: string | null
    tournament_id: string | null
    user_id: string | null
    registered_at: Date | null
    current_position: number | null
    eliminated_at: Date | null
  }

  export type Tournament_participantsCountAggregateOutputType = {
    id: number
    tournament_id: number
    user_id: number
    registered_at: number
    current_position: number
    eliminated_at: number
    _all: number
  }


  export type Tournament_participantsAvgAggregateInputType = {
    current_position?: true
  }

  export type Tournament_participantsSumAggregateInputType = {
    current_position?: true
  }

  export type Tournament_participantsMinAggregateInputType = {
    id?: true
    tournament_id?: true
    user_id?: true
    registered_at?: true
    current_position?: true
    eliminated_at?: true
  }

  export type Tournament_participantsMaxAggregateInputType = {
    id?: true
    tournament_id?: true
    user_id?: true
    registered_at?: true
    current_position?: true
    eliminated_at?: true
  }

  export type Tournament_participantsCountAggregateInputType = {
    id?: true
    tournament_id?: true
    user_id?: true
    registered_at?: true
    current_position?: true
    eliminated_at?: true
    _all?: true
  }

  export type Tournament_participantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournament_participants to aggregate.
     */
    where?: tournament_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournament_participants to fetch.
     */
    orderBy?: tournament_participantsOrderByWithRelationInput | tournament_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tournament_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournament_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournament_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tournament_participants
    **/
    _count?: true | Tournament_participantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tournament_participantsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tournament_participantsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tournament_participantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tournament_participantsMaxAggregateInputType
  }

  export type GetTournament_participantsAggregateType<T extends Tournament_participantsAggregateArgs> = {
        [P in keyof T & keyof AggregateTournament_participants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournament_participants[P]>
      : GetScalarType<T[P], AggregateTournament_participants[P]>
  }




  export type tournament_participantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournament_participantsWhereInput
    orderBy?: tournament_participantsOrderByWithAggregationInput | tournament_participantsOrderByWithAggregationInput[]
    by: Tournament_participantsScalarFieldEnum[] | Tournament_participantsScalarFieldEnum
    having?: tournament_participantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tournament_participantsCountAggregateInputType | true
    _avg?: Tournament_participantsAvgAggregateInputType
    _sum?: Tournament_participantsSumAggregateInputType
    _min?: Tournament_participantsMinAggregateInputType
    _max?: Tournament_participantsMaxAggregateInputType
  }

  export type Tournament_participantsGroupByOutputType = {
    id: string
    tournament_id: string
    user_id: string
    registered_at: Date
    current_position: number | null
    eliminated_at: Date | null
    _count: Tournament_participantsCountAggregateOutputType | null
    _avg: Tournament_participantsAvgAggregateOutputType | null
    _sum: Tournament_participantsSumAggregateOutputType | null
    _min: Tournament_participantsMinAggregateOutputType | null
    _max: Tournament_participantsMaxAggregateOutputType | null
  }

  type GetTournament_participantsGroupByPayload<T extends tournament_participantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tournament_participantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tournament_participantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tournament_participantsGroupByOutputType[P]>
            : GetScalarType<T[P], Tournament_participantsGroupByOutputType[P]>
        }
      >
    >


  export type tournament_participantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournament_id?: boolean
    user_id?: boolean
    registered_at?: boolean
    current_position?: boolean
    eliminated_at?: boolean
    tournaments?: boolean | tournamentsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    whiteMatches?: boolean | tournament_participants$whiteMatchesArgs<ExtArgs>
    blackMatches?: boolean | tournament_participants$blackMatchesArgs<ExtArgs>
    wonMatches?: boolean | tournament_participants$wonMatchesArgs<ExtArgs>
    _count?: boolean | Tournament_participantsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournament_participants"]>

  export type tournament_participantsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournament_id?: boolean
    user_id?: boolean
    registered_at?: boolean
    current_position?: boolean
    eliminated_at?: boolean
    tournaments?: boolean | tournamentsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournament_participants"]>

  export type tournament_participantsSelectScalar = {
    id?: boolean
    tournament_id?: boolean
    user_id?: boolean
    registered_at?: boolean
    current_position?: boolean
    eliminated_at?: boolean
  }

  export type tournament_participantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournaments?: boolean | tournamentsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    whiteMatches?: boolean | tournament_participants$whiteMatchesArgs<ExtArgs>
    blackMatches?: boolean | tournament_participants$blackMatchesArgs<ExtArgs>
    wonMatches?: boolean | tournament_participants$wonMatchesArgs<ExtArgs>
    _count?: boolean | Tournament_participantsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tournament_participantsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournaments?: boolean | tournamentsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $tournament_participantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tournament_participants"
    objects: {
      tournaments: Prisma.$tournamentsPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
      whiteMatches: Prisma.$tournament_matchesPayload<ExtArgs>[]
      blackMatches: Prisma.$tournament_matchesPayload<ExtArgs>[]
      wonMatches: Prisma.$tournament_matchesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tournament_id: string
      user_id: string
      registered_at: Date
      current_position: number | null
      eliminated_at: Date | null
    }, ExtArgs["result"]["tournament_participants"]>
    composites: {}
  }

  type tournament_participantsGetPayload<S extends boolean | null | undefined | tournament_participantsDefaultArgs> = $Result.GetResult<Prisma.$tournament_participantsPayload, S>

  type tournament_participantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tournament_participantsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tournament_participantsCountAggregateInputType | true
    }

  export interface tournament_participantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tournament_participants'], meta: { name: 'tournament_participants' } }
    /**
     * Find zero or one Tournament_participants that matches the filter.
     * @param {tournament_participantsFindUniqueArgs} args - Arguments to find a Tournament_participants
     * @example
     * // Get one Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tournament_participantsFindUniqueArgs>(args: SelectSubset<T, tournament_participantsFindUniqueArgs<ExtArgs>>): Prisma__tournament_participantsClient<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tournament_participants that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tournament_participantsFindUniqueOrThrowArgs} args - Arguments to find a Tournament_participants
     * @example
     * // Get one Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tournament_participantsFindUniqueOrThrowArgs>(args: SelectSubset<T, tournament_participantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tournament_participantsClient<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tournament_participants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournament_participantsFindFirstArgs} args - Arguments to find a Tournament_participants
     * @example
     * // Get one Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tournament_participantsFindFirstArgs>(args?: SelectSubset<T, tournament_participantsFindFirstArgs<ExtArgs>>): Prisma__tournament_participantsClient<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tournament_participants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournament_participantsFindFirstOrThrowArgs} args - Arguments to find a Tournament_participants
     * @example
     * // Get one Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tournament_participantsFindFirstOrThrowArgs>(args?: SelectSubset<T, tournament_participantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tournament_participantsClient<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tournament_participants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournament_participantsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.findMany()
     * 
     * // Get first 10 Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournament_participantsWithIdOnly = await prisma.tournament_participants.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tournament_participantsFindManyArgs>(args?: SelectSubset<T, tournament_participantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tournament_participants.
     * @param {tournament_participantsCreateArgs} args - Arguments to create a Tournament_participants.
     * @example
     * // Create one Tournament_participants
     * const Tournament_participants = await prisma.tournament_participants.create({
     *   data: {
     *     // ... data to create a Tournament_participants
     *   }
     * })
     * 
     */
    create<T extends tournament_participantsCreateArgs>(args: SelectSubset<T, tournament_participantsCreateArgs<ExtArgs>>): Prisma__tournament_participantsClient<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tournament_participants.
     * @param {tournament_participantsCreateManyArgs} args - Arguments to create many Tournament_participants.
     * @example
     * // Create many Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tournament_participantsCreateManyArgs>(args?: SelectSubset<T, tournament_participantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tournament_participants and returns the data saved in the database.
     * @param {tournament_participantsCreateManyAndReturnArgs} args - Arguments to create many Tournament_participants.
     * @example
     * // Create many Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tournament_participants and only return the `id`
     * const tournament_participantsWithIdOnly = await prisma.tournament_participants.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tournament_participantsCreateManyAndReturnArgs>(args?: SelectSubset<T, tournament_participantsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tournament_participants.
     * @param {tournament_participantsDeleteArgs} args - Arguments to delete one Tournament_participants.
     * @example
     * // Delete one Tournament_participants
     * const Tournament_participants = await prisma.tournament_participants.delete({
     *   where: {
     *     // ... filter to delete one Tournament_participants
     *   }
     * })
     * 
     */
    delete<T extends tournament_participantsDeleteArgs>(args: SelectSubset<T, tournament_participantsDeleteArgs<ExtArgs>>): Prisma__tournament_participantsClient<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tournament_participants.
     * @param {tournament_participantsUpdateArgs} args - Arguments to update one Tournament_participants.
     * @example
     * // Update one Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tournament_participantsUpdateArgs>(args: SelectSubset<T, tournament_participantsUpdateArgs<ExtArgs>>): Prisma__tournament_participantsClient<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tournament_participants.
     * @param {tournament_participantsDeleteManyArgs} args - Arguments to filter Tournament_participants to delete.
     * @example
     * // Delete a few Tournament_participants
     * const { count } = await prisma.tournament_participants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tournament_participantsDeleteManyArgs>(args?: SelectSubset<T, tournament_participantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournament_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournament_participantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tournament_participantsUpdateManyArgs>(args: SelectSubset<T, tournament_participantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tournament_participants.
     * @param {tournament_participantsUpsertArgs} args - Arguments to update or create a Tournament_participants.
     * @example
     * // Update or create a Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.upsert({
     *   create: {
     *     // ... data to create a Tournament_participants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournament_participants we want to update
     *   }
     * })
     */
    upsert<T extends tournament_participantsUpsertArgs>(args: SelectSubset<T, tournament_participantsUpsertArgs<ExtArgs>>): Prisma__tournament_participantsClient<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tournament_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournament_participantsCountArgs} args - Arguments to filter Tournament_participants to count.
     * @example
     * // Count the number of Tournament_participants
     * const count = await prisma.tournament_participants.count({
     *   where: {
     *     // ... the filter for the Tournament_participants we want to count
     *   }
     * })
    **/
    count<T extends tournament_participantsCountArgs>(
      args?: Subset<T, tournament_participantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tournament_participantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournament_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tournament_participantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tournament_participantsAggregateArgs>(args: Subset<T, Tournament_participantsAggregateArgs>): Prisma.PrismaPromise<GetTournament_participantsAggregateType<T>>

    /**
     * Group by Tournament_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournament_participantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tournament_participantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tournament_participantsGroupByArgs['orderBy'] }
        : { orderBy?: tournament_participantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tournament_participantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournament_participantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tournament_participants model
   */
  readonly fields: tournament_participantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tournament_participants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tournament_participantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tournaments<T extends tournamentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tournamentsDefaultArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    whiteMatches<T extends tournament_participants$whiteMatchesArgs<ExtArgs> = {}>(args?: Subset<T, tournament_participants$whiteMatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournament_matchesPayload<ExtArgs>, T, "findMany"> | Null>
    blackMatches<T extends tournament_participants$blackMatchesArgs<ExtArgs> = {}>(args?: Subset<T, tournament_participants$blackMatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournament_matchesPayload<ExtArgs>, T, "findMany"> | Null>
    wonMatches<T extends tournament_participants$wonMatchesArgs<ExtArgs> = {}>(args?: Subset<T, tournament_participants$wonMatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournament_matchesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tournament_participants model
   */ 
  interface tournament_participantsFieldRefs {
    readonly id: FieldRef<"tournament_participants", 'String'>
    readonly tournament_id: FieldRef<"tournament_participants", 'String'>
    readonly user_id: FieldRef<"tournament_participants", 'String'>
    readonly registered_at: FieldRef<"tournament_participants", 'DateTime'>
    readonly current_position: FieldRef<"tournament_participants", 'Int'>
    readonly eliminated_at: FieldRef<"tournament_participants", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tournament_participants findUnique
   */
  export type tournament_participantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    /**
     * Filter, which tournament_participants to fetch.
     */
    where: tournament_participantsWhereUniqueInput
  }

  /**
   * tournament_participants findUniqueOrThrow
   */
  export type tournament_participantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    /**
     * Filter, which tournament_participants to fetch.
     */
    where: tournament_participantsWhereUniqueInput
  }

  /**
   * tournament_participants findFirst
   */
  export type tournament_participantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    /**
     * Filter, which tournament_participants to fetch.
     */
    where?: tournament_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournament_participants to fetch.
     */
    orderBy?: tournament_participantsOrderByWithRelationInput | tournament_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournament_participants.
     */
    cursor?: tournament_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournament_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournament_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournament_participants.
     */
    distinct?: Tournament_participantsScalarFieldEnum | Tournament_participantsScalarFieldEnum[]
  }

  /**
   * tournament_participants findFirstOrThrow
   */
  export type tournament_participantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    /**
     * Filter, which tournament_participants to fetch.
     */
    where?: tournament_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournament_participants to fetch.
     */
    orderBy?: tournament_participantsOrderByWithRelationInput | tournament_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournament_participants.
     */
    cursor?: tournament_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournament_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournament_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournament_participants.
     */
    distinct?: Tournament_participantsScalarFieldEnum | Tournament_participantsScalarFieldEnum[]
  }

  /**
   * tournament_participants findMany
   */
  export type tournament_participantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    /**
     * Filter, which tournament_participants to fetch.
     */
    where?: tournament_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournament_participants to fetch.
     */
    orderBy?: tournament_participantsOrderByWithRelationInput | tournament_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tournament_participants.
     */
    cursor?: tournament_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournament_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournament_participants.
     */
    skip?: number
    distinct?: Tournament_participantsScalarFieldEnum | Tournament_participantsScalarFieldEnum[]
  }

  /**
   * tournament_participants create
   */
  export type tournament_participantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    /**
     * The data needed to create a tournament_participants.
     */
    data: XOR<tournament_participantsCreateInput, tournament_participantsUncheckedCreateInput>
  }

  /**
   * tournament_participants createMany
   */
  export type tournament_participantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tournament_participants.
     */
    data: tournament_participantsCreateManyInput | tournament_participantsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tournament_participants createManyAndReturn
   */
  export type tournament_participantsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many tournament_participants.
     */
    data: tournament_participantsCreateManyInput | tournament_participantsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tournament_participants update
   */
  export type tournament_participantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    /**
     * The data needed to update a tournament_participants.
     */
    data: XOR<tournament_participantsUpdateInput, tournament_participantsUncheckedUpdateInput>
    /**
     * Choose, which tournament_participants to update.
     */
    where: tournament_participantsWhereUniqueInput
  }

  /**
   * tournament_participants updateMany
   */
  export type tournament_participantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tournament_participants.
     */
    data: XOR<tournament_participantsUpdateManyMutationInput, tournament_participantsUncheckedUpdateManyInput>
    /**
     * Filter which tournament_participants to update
     */
    where?: tournament_participantsWhereInput
  }

  /**
   * tournament_participants upsert
   */
  export type tournament_participantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    /**
     * The filter to search for the tournament_participants to update in case it exists.
     */
    where: tournament_participantsWhereUniqueInput
    /**
     * In case the tournament_participants found by the `where` argument doesn't exist, create a new tournament_participants with this data.
     */
    create: XOR<tournament_participantsCreateInput, tournament_participantsUncheckedCreateInput>
    /**
     * In case the tournament_participants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tournament_participantsUpdateInput, tournament_participantsUncheckedUpdateInput>
  }

  /**
   * tournament_participants delete
   */
  export type tournament_participantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    /**
     * Filter which tournament_participants to delete.
     */
    where: tournament_participantsWhereUniqueInput
  }

  /**
   * tournament_participants deleteMany
   */
  export type tournament_participantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournament_participants to delete
     */
    where?: tournament_participantsWhereInput
  }

  /**
   * tournament_participants.whiteMatches
   */
  export type tournament_participants$whiteMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_matches
     */
    select?: tournament_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_matchesInclude<ExtArgs> | null
    where?: tournament_matchesWhereInput
    orderBy?: tournament_matchesOrderByWithRelationInput | tournament_matchesOrderByWithRelationInput[]
    cursor?: tournament_matchesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tournament_matchesScalarFieldEnum | Tournament_matchesScalarFieldEnum[]
  }

  /**
   * tournament_participants.blackMatches
   */
  export type tournament_participants$blackMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_matches
     */
    select?: tournament_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_matchesInclude<ExtArgs> | null
    where?: tournament_matchesWhereInput
    orderBy?: tournament_matchesOrderByWithRelationInput | tournament_matchesOrderByWithRelationInput[]
    cursor?: tournament_matchesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tournament_matchesScalarFieldEnum | Tournament_matchesScalarFieldEnum[]
  }

  /**
   * tournament_participants.wonMatches
   */
  export type tournament_participants$wonMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_matches
     */
    select?: tournament_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_matchesInclude<ExtArgs> | null
    where?: tournament_matchesWhereInput
    orderBy?: tournament_matchesOrderByWithRelationInput | tournament_matchesOrderByWithRelationInput[]
    cursor?: tournament_matchesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tournament_matchesScalarFieldEnum | Tournament_matchesScalarFieldEnum[]
  }

  /**
   * tournament_participants without action
   */
  export type tournament_participantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
  }


  /**
   * Model tournament_matches
   */

  export type AggregateTournament_matches = {
    _count: Tournament_matchesCountAggregateOutputType | null
    _avg: Tournament_matchesAvgAggregateOutputType | null
    _sum: Tournament_matchesSumAggregateOutputType | null
    _min: Tournament_matchesMinAggregateOutputType | null
    _max: Tournament_matchesMaxAggregateOutputType | null
  }

  export type Tournament_matchesAvgAggregateOutputType = {
    round: number | null
    matchNumber: number | null
  }

  export type Tournament_matchesSumAggregateOutputType = {
    round: number | null
    matchNumber: number | null
  }

  export type Tournament_matchesMinAggregateOutputType = {
    id: string | null
    tournamentId: string | null
    round: number | null
    matchNumber: number | null
    whiteParticipantId: string | null
    blackParticipantId: string | null
    winnerParticipantId: string | null
    status: $Enums.TournamentMatchStatus | null
    scheduledAt: Date | null
    startedAt: Date | null
    finishedAt: Date | null
    gameId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tournament_matchesMaxAggregateOutputType = {
    id: string | null
    tournamentId: string | null
    round: number | null
    matchNumber: number | null
    whiteParticipantId: string | null
    blackParticipantId: string | null
    winnerParticipantId: string | null
    status: $Enums.TournamentMatchStatus | null
    scheduledAt: Date | null
    startedAt: Date | null
    finishedAt: Date | null
    gameId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tournament_matchesCountAggregateOutputType = {
    id: number
    tournamentId: number
    round: number
    matchNumber: number
    whiteParticipantId: number
    blackParticipantId: number
    winnerParticipantId: number
    status: number
    scheduledAt: number
    startedAt: number
    finishedAt: number
    gameId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Tournament_matchesAvgAggregateInputType = {
    round?: true
    matchNumber?: true
  }

  export type Tournament_matchesSumAggregateInputType = {
    round?: true
    matchNumber?: true
  }

  export type Tournament_matchesMinAggregateInputType = {
    id?: true
    tournamentId?: true
    round?: true
    matchNumber?: true
    whiteParticipantId?: true
    blackParticipantId?: true
    winnerParticipantId?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    finishedAt?: true
    gameId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tournament_matchesMaxAggregateInputType = {
    id?: true
    tournamentId?: true
    round?: true
    matchNumber?: true
    whiteParticipantId?: true
    blackParticipantId?: true
    winnerParticipantId?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    finishedAt?: true
    gameId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tournament_matchesCountAggregateInputType = {
    id?: true
    tournamentId?: true
    round?: true
    matchNumber?: true
    whiteParticipantId?: true
    blackParticipantId?: true
    winnerParticipantId?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    finishedAt?: true
    gameId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Tournament_matchesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournament_matches to aggregate.
     */
    where?: tournament_matchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournament_matches to fetch.
     */
    orderBy?: tournament_matchesOrderByWithRelationInput | tournament_matchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tournament_matchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournament_matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournament_matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tournament_matches
    **/
    _count?: true | Tournament_matchesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tournament_matchesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tournament_matchesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tournament_matchesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tournament_matchesMaxAggregateInputType
  }

  export type GetTournament_matchesAggregateType<T extends Tournament_matchesAggregateArgs> = {
        [P in keyof T & keyof AggregateTournament_matches]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournament_matches[P]>
      : GetScalarType<T[P], AggregateTournament_matches[P]>
  }




  export type tournament_matchesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournament_matchesWhereInput
    orderBy?: tournament_matchesOrderByWithAggregationInput | tournament_matchesOrderByWithAggregationInput[]
    by: Tournament_matchesScalarFieldEnum[] | Tournament_matchesScalarFieldEnum
    having?: tournament_matchesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tournament_matchesCountAggregateInputType | true
    _avg?: Tournament_matchesAvgAggregateInputType
    _sum?: Tournament_matchesSumAggregateInputType
    _min?: Tournament_matchesMinAggregateInputType
    _max?: Tournament_matchesMaxAggregateInputType
  }

  export type Tournament_matchesGroupByOutputType = {
    id: string
    tournamentId: string
    round: number
    matchNumber: number
    whiteParticipantId: string | null
    blackParticipantId: string | null
    winnerParticipantId: string | null
    status: $Enums.TournamentMatchStatus
    scheduledAt: Date | null
    startedAt: Date | null
    finishedAt: Date | null
    gameId: string | null
    createdAt: Date
    updatedAt: Date
    _count: Tournament_matchesCountAggregateOutputType | null
    _avg: Tournament_matchesAvgAggregateOutputType | null
    _sum: Tournament_matchesSumAggregateOutputType | null
    _min: Tournament_matchesMinAggregateOutputType | null
    _max: Tournament_matchesMaxAggregateOutputType | null
  }

  type GetTournament_matchesGroupByPayload<T extends tournament_matchesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tournament_matchesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tournament_matchesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tournament_matchesGroupByOutputType[P]>
            : GetScalarType<T[P], Tournament_matchesGroupByOutputType[P]>
        }
      >
    >


  export type tournament_matchesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentId?: boolean
    round?: boolean
    matchNumber?: boolean
    whiteParticipantId?: boolean
    blackParticipantId?: boolean
    winnerParticipantId?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    gameId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tournament?: boolean | tournamentsDefaultArgs<ExtArgs>
    white?: boolean | tournament_matches$whiteArgs<ExtArgs>
    black?: boolean | tournament_matches$blackArgs<ExtArgs>
    winner?: boolean | tournament_matches$winnerArgs<ExtArgs>
    game?: boolean | tournament_matches$gameArgs<ExtArgs>
  }, ExtArgs["result"]["tournament_matches"]>

  export type tournament_matchesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentId?: boolean
    round?: boolean
    matchNumber?: boolean
    whiteParticipantId?: boolean
    blackParticipantId?: boolean
    winnerParticipantId?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    gameId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tournament?: boolean | tournamentsDefaultArgs<ExtArgs>
    white?: boolean | tournament_matches$whiteArgs<ExtArgs>
    black?: boolean | tournament_matches$blackArgs<ExtArgs>
    winner?: boolean | tournament_matches$winnerArgs<ExtArgs>
    game?: boolean | tournament_matches$gameArgs<ExtArgs>
  }, ExtArgs["result"]["tournament_matches"]>

  export type tournament_matchesSelectScalar = {
    id?: boolean
    tournamentId?: boolean
    round?: boolean
    matchNumber?: boolean
    whiteParticipantId?: boolean
    blackParticipantId?: boolean
    winnerParticipantId?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    gameId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type tournament_matchesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournament?: boolean | tournamentsDefaultArgs<ExtArgs>
    white?: boolean | tournament_matches$whiteArgs<ExtArgs>
    black?: boolean | tournament_matches$blackArgs<ExtArgs>
    winner?: boolean | tournament_matches$winnerArgs<ExtArgs>
    game?: boolean | tournament_matches$gameArgs<ExtArgs>
  }
  export type tournament_matchesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournament?: boolean | tournamentsDefaultArgs<ExtArgs>
    white?: boolean | tournament_matches$whiteArgs<ExtArgs>
    black?: boolean | tournament_matches$blackArgs<ExtArgs>
    winner?: boolean | tournament_matches$winnerArgs<ExtArgs>
    game?: boolean | tournament_matches$gameArgs<ExtArgs>
  }

  export type $tournament_matchesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tournament_matches"
    objects: {
      tournament: Prisma.$tournamentsPayload<ExtArgs>
      white: Prisma.$tournament_participantsPayload<ExtArgs> | null
      black: Prisma.$tournament_participantsPayload<ExtArgs> | null
      winner: Prisma.$tournament_participantsPayload<ExtArgs> | null
      game: Prisma.$gamesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tournamentId: string
      round: number
      matchNumber: number
      whiteParticipantId: string | null
      blackParticipantId: string | null
      winnerParticipantId: string | null
      status: $Enums.TournamentMatchStatus
      scheduledAt: Date | null
      startedAt: Date | null
      finishedAt: Date | null
      gameId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tournament_matches"]>
    composites: {}
  }

  type tournament_matchesGetPayload<S extends boolean | null | undefined | tournament_matchesDefaultArgs> = $Result.GetResult<Prisma.$tournament_matchesPayload, S>

  type tournament_matchesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tournament_matchesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tournament_matchesCountAggregateInputType | true
    }

  export interface tournament_matchesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tournament_matches'], meta: { name: 'tournament_matches' } }
    /**
     * Find zero or one Tournament_matches that matches the filter.
     * @param {tournament_matchesFindUniqueArgs} args - Arguments to find a Tournament_matches
     * @example
     * // Get one Tournament_matches
     * const tournament_matches = await prisma.tournament_matches.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tournament_matchesFindUniqueArgs>(args: SelectSubset<T, tournament_matchesFindUniqueArgs<ExtArgs>>): Prisma__tournament_matchesClient<$Result.GetResult<Prisma.$tournament_matchesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tournament_matches that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tournament_matchesFindUniqueOrThrowArgs} args - Arguments to find a Tournament_matches
     * @example
     * // Get one Tournament_matches
     * const tournament_matches = await prisma.tournament_matches.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tournament_matchesFindUniqueOrThrowArgs>(args: SelectSubset<T, tournament_matchesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tournament_matchesClient<$Result.GetResult<Prisma.$tournament_matchesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tournament_matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournament_matchesFindFirstArgs} args - Arguments to find a Tournament_matches
     * @example
     * // Get one Tournament_matches
     * const tournament_matches = await prisma.tournament_matches.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tournament_matchesFindFirstArgs>(args?: SelectSubset<T, tournament_matchesFindFirstArgs<ExtArgs>>): Prisma__tournament_matchesClient<$Result.GetResult<Prisma.$tournament_matchesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tournament_matches that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournament_matchesFindFirstOrThrowArgs} args - Arguments to find a Tournament_matches
     * @example
     * // Get one Tournament_matches
     * const tournament_matches = await prisma.tournament_matches.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tournament_matchesFindFirstOrThrowArgs>(args?: SelectSubset<T, tournament_matchesFindFirstOrThrowArgs<ExtArgs>>): Prisma__tournament_matchesClient<$Result.GetResult<Prisma.$tournament_matchesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tournament_matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournament_matchesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournament_matches
     * const tournament_matches = await prisma.tournament_matches.findMany()
     * 
     * // Get first 10 Tournament_matches
     * const tournament_matches = await prisma.tournament_matches.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournament_matchesWithIdOnly = await prisma.tournament_matches.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tournament_matchesFindManyArgs>(args?: SelectSubset<T, tournament_matchesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournament_matchesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tournament_matches.
     * @param {tournament_matchesCreateArgs} args - Arguments to create a Tournament_matches.
     * @example
     * // Create one Tournament_matches
     * const Tournament_matches = await prisma.tournament_matches.create({
     *   data: {
     *     // ... data to create a Tournament_matches
     *   }
     * })
     * 
     */
    create<T extends tournament_matchesCreateArgs>(args: SelectSubset<T, tournament_matchesCreateArgs<ExtArgs>>): Prisma__tournament_matchesClient<$Result.GetResult<Prisma.$tournament_matchesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tournament_matches.
     * @param {tournament_matchesCreateManyArgs} args - Arguments to create many Tournament_matches.
     * @example
     * // Create many Tournament_matches
     * const tournament_matches = await prisma.tournament_matches.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tournament_matchesCreateManyArgs>(args?: SelectSubset<T, tournament_matchesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tournament_matches and returns the data saved in the database.
     * @param {tournament_matchesCreateManyAndReturnArgs} args - Arguments to create many Tournament_matches.
     * @example
     * // Create many Tournament_matches
     * const tournament_matches = await prisma.tournament_matches.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tournament_matches and only return the `id`
     * const tournament_matchesWithIdOnly = await prisma.tournament_matches.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tournament_matchesCreateManyAndReturnArgs>(args?: SelectSubset<T, tournament_matchesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournament_matchesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tournament_matches.
     * @param {tournament_matchesDeleteArgs} args - Arguments to delete one Tournament_matches.
     * @example
     * // Delete one Tournament_matches
     * const Tournament_matches = await prisma.tournament_matches.delete({
     *   where: {
     *     // ... filter to delete one Tournament_matches
     *   }
     * })
     * 
     */
    delete<T extends tournament_matchesDeleteArgs>(args: SelectSubset<T, tournament_matchesDeleteArgs<ExtArgs>>): Prisma__tournament_matchesClient<$Result.GetResult<Prisma.$tournament_matchesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tournament_matches.
     * @param {tournament_matchesUpdateArgs} args - Arguments to update one Tournament_matches.
     * @example
     * // Update one Tournament_matches
     * const tournament_matches = await prisma.tournament_matches.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tournament_matchesUpdateArgs>(args: SelectSubset<T, tournament_matchesUpdateArgs<ExtArgs>>): Prisma__tournament_matchesClient<$Result.GetResult<Prisma.$tournament_matchesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tournament_matches.
     * @param {tournament_matchesDeleteManyArgs} args - Arguments to filter Tournament_matches to delete.
     * @example
     * // Delete a few Tournament_matches
     * const { count } = await prisma.tournament_matches.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tournament_matchesDeleteManyArgs>(args?: SelectSubset<T, tournament_matchesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournament_matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournament_matchesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournament_matches
     * const tournament_matches = await prisma.tournament_matches.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tournament_matchesUpdateManyArgs>(args: SelectSubset<T, tournament_matchesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tournament_matches.
     * @param {tournament_matchesUpsertArgs} args - Arguments to update or create a Tournament_matches.
     * @example
     * // Update or create a Tournament_matches
     * const tournament_matches = await prisma.tournament_matches.upsert({
     *   create: {
     *     // ... data to create a Tournament_matches
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournament_matches we want to update
     *   }
     * })
     */
    upsert<T extends tournament_matchesUpsertArgs>(args: SelectSubset<T, tournament_matchesUpsertArgs<ExtArgs>>): Prisma__tournament_matchesClient<$Result.GetResult<Prisma.$tournament_matchesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tournament_matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournament_matchesCountArgs} args - Arguments to filter Tournament_matches to count.
     * @example
     * // Count the number of Tournament_matches
     * const count = await prisma.tournament_matches.count({
     *   where: {
     *     // ... the filter for the Tournament_matches we want to count
     *   }
     * })
    **/
    count<T extends tournament_matchesCountArgs>(
      args?: Subset<T, tournament_matchesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tournament_matchesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournament_matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tournament_matchesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tournament_matchesAggregateArgs>(args: Subset<T, Tournament_matchesAggregateArgs>): Prisma.PrismaPromise<GetTournament_matchesAggregateType<T>>

    /**
     * Group by Tournament_matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournament_matchesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tournament_matchesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tournament_matchesGroupByArgs['orderBy'] }
        : { orderBy?: tournament_matchesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tournament_matchesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournament_matchesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tournament_matches model
   */
  readonly fields: tournament_matchesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tournament_matches.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tournament_matchesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tournament<T extends tournamentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tournamentsDefaultArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    white<T extends tournament_matches$whiteArgs<ExtArgs> = {}>(args?: Subset<T, tournament_matches$whiteArgs<ExtArgs>>): Prisma__tournament_participantsClient<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    black<T extends tournament_matches$blackArgs<ExtArgs> = {}>(args?: Subset<T, tournament_matches$blackArgs<ExtArgs>>): Prisma__tournament_participantsClient<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    winner<T extends tournament_matches$winnerArgs<ExtArgs> = {}>(args?: Subset<T, tournament_matches$winnerArgs<ExtArgs>>): Prisma__tournament_participantsClient<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    game<T extends tournament_matches$gameArgs<ExtArgs> = {}>(args?: Subset<T, tournament_matches$gameArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tournament_matches model
   */ 
  interface tournament_matchesFieldRefs {
    readonly id: FieldRef<"tournament_matches", 'String'>
    readonly tournamentId: FieldRef<"tournament_matches", 'String'>
    readonly round: FieldRef<"tournament_matches", 'Int'>
    readonly matchNumber: FieldRef<"tournament_matches", 'Int'>
    readonly whiteParticipantId: FieldRef<"tournament_matches", 'String'>
    readonly blackParticipantId: FieldRef<"tournament_matches", 'String'>
    readonly winnerParticipantId: FieldRef<"tournament_matches", 'String'>
    readonly status: FieldRef<"tournament_matches", 'TournamentMatchStatus'>
    readonly scheduledAt: FieldRef<"tournament_matches", 'DateTime'>
    readonly startedAt: FieldRef<"tournament_matches", 'DateTime'>
    readonly finishedAt: FieldRef<"tournament_matches", 'DateTime'>
    readonly gameId: FieldRef<"tournament_matches", 'String'>
    readonly createdAt: FieldRef<"tournament_matches", 'DateTime'>
    readonly updatedAt: FieldRef<"tournament_matches", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tournament_matches findUnique
   */
  export type tournament_matchesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_matches
     */
    select?: tournament_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_matchesInclude<ExtArgs> | null
    /**
     * Filter, which tournament_matches to fetch.
     */
    where: tournament_matchesWhereUniqueInput
  }

  /**
   * tournament_matches findUniqueOrThrow
   */
  export type tournament_matchesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_matches
     */
    select?: tournament_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_matchesInclude<ExtArgs> | null
    /**
     * Filter, which tournament_matches to fetch.
     */
    where: tournament_matchesWhereUniqueInput
  }

  /**
   * tournament_matches findFirst
   */
  export type tournament_matchesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_matches
     */
    select?: tournament_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_matchesInclude<ExtArgs> | null
    /**
     * Filter, which tournament_matches to fetch.
     */
    where?: tournament_matchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournament_matches to fetch.
     */
    orderBy?: tournament_matchesOrderByWithRelationInput | tournament_matchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournament_matches.
     */
    cursor?: tournament_matchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournament_matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournament_matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournament_matches.
     */
    distinct?: Tournament_matchesScalarFieldEnum | Tournament_matchesScalarFieldEnum[]
  }

  /**
   * tournament_matches findFirstOrThrow
   */
  export type tournament_matchesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_matches
     */
    select?: tournament_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_matchesInclude<ExtArgs> | null
    /**
     * Filter, which tournament_matches to fetch.
     */
    where?: tournament_matchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournament_matches to fetch.
     */
    orderBy?: tournament_matchesOrderByWithRelationInput | tournament_matchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournament_matches.
     */
    cursor?: tournament_matchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournament_matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournament_matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournament_matches.
     */
    distinct?: Tournament_matchesScalarFieldEnum | Tournament_matchesScalarFieldEnum[]
  }

  /**
   * tournament_matches findMany
   */
  export type tournament_matchesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_matches
     */
    select?: tournament_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_matchesInclude<ExtArgs> | null
    /**
     * Filter, which tournament_matches to fetch.
     */
    where?: tournament_matchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournament_matches to fetch.
     */
    orderBy?: tournament_matchesOrderByWithRelationInput | tournament_matchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tournament_matches.
     */
    cursor?: tournament_matchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournament_matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournament_matches.
     */
    skip?: number
    distinct?: Tournament_matchesScalarFieldEnum | Tournament_matchesScalarFieldEnum[]
  }

  /**
   * tournament_matches create
   */
  export type tournament_matchesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_matches
     */
    select?: tournament_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_matchesInclude<ExtArgs> | null
    /**
     * The data needed to create a tournament_matches.
     */
    data: XOR<tournament_matchesCreateInput, tournament_matchesUncheckedCreateInput>
  }

  /**
   * tournament_matches createMany
   */
  export type tournament_matchesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tournament_matches.
     */
    data: tournament_matchesCreateManyInput | tournament_matchesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tournament_matches createManyAndReturn
   */
  export type tournament_matchesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_matches
     */
    select?: tournament_matchesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many tournament_matches.
     */
    data: tournament_matchesCreateManyInput | tournament_matchesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_matchesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tournament_matches update
   */
  export type tournament_matchesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_matches
     */
    select?: tournament_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_matchesInclude<ExtArgs> | null
    /**
     * The data needed to update a tournament_matches.
     */
    data: XOR<tournament_matchesUpdateInput, tournament_matchesUncheckedUpdateInput>
    /**
     * Choose, which tournament_matches to update.
     */
    where: tournament_matchesWhereUniqueInput
  }

  /**
   * tournament_matches updateMany
   */
  export type tournament_matchesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tournament_matches.
     */
    data: XOR<tournament_matchesUpdateManyMutationInput, tournament_matchesUncheckedUpdateManyInput>
    /**
     * Filter which tournament_matches to update
     */
    where?: tournament_matchesWhereInput
  }

  /**
   * tournament_matches upsert
   */
  export type tournament_matchesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_matches
     */
    select?: tournament_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_matchesInclude<ExtArgs> | null
    /**
     * The filter to search for the tournament_matches to update in case it exists.
     */
    where: tournament_matchesWhereUniqueInput
    /**
     * In case the tournament_matches found by the `where` argument doesn't exist, create a new tournament_matches with this data.
     */
    create: XOR<tournament_matchesCreateInput, tournament_matchesUncheckedCreateInput>
    /**
     * In case the tournament_matches was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tournament_matchesUpdateInput, tournament_matchesUncheckedUpdateInput>
  }

  /**
   * tournament_matches delete
   */
  export type tournament_matchesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_matches
     */
    select?: tournament_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_matchesInclude<ExtArgs> | null
    /**
     * Filter which tournament_matches to delete.
     */
    where: tournament_matchesWhereUniqueInput
  }

  /**
   * tournament_matches deleteMany
   */
  export type tournament_matchesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournament_matches to delete
     */
    where?: tournament_matchesWhereInput
  }

  /**
   * tournament_matches.white
   */
  export type tournament_matches$whiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    where?: tournament_participantsWhereInput
  }

  /**
   * tournament_matches.black
   */
  export type tournament_matches$blackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    where?: tournament_participantsWhereInput
  }

  /**
   * tournament_matches.winner
   */
  export type tournament_matches$winnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    where?: tournament_participantsWhereInput
  }

  /**
   * tournament_matches.game
   */
  export type tournament_matches$gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    where?: gamesWhereInput
  }

  /**
   * tournament_matches without action
   */
  export type tournament_matchesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_matches
     */
    select?: tournament_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_matchesInclude<ExtArgs> | null
  }


  /**
   * Model tournaments
   */

  export type AggregateTournaments = {
    _count: TournamentsCountAggregateOutputType | null
    _avg: TournamentsAvgAggregateOutputType | null
    _sum: TournamentsSumAggregateOutputType | null
    _min: TournamentsMinAggregateOutputType | null
    _max: TournamentsMaxAggregateOutputType | null
  }

  export type TournamentsAvgAggregateOutputType = {
    entryFee: number | null
    prizePool: number | null
    maxPlayers: number | null
  }

  export type TournamentsSumAggregateOutputType = {
    entryFee: number | null
    prizePool: number | null
    maxPlayers: number | null
  }

  export type TournamentsMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    entryFee: number | null
    prizePool: number | null
    maxPlayers: number | null
    status: $Enums.TournamentStatus | null
    startTime: Date | null
    endTime: Date | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type TournamentsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    entryFee: number | null
    prizePool: number | null
    maxPlayers: number | null
    status: $Enums.TournamentStatus | null
    startTime: Date | null
    endTime: Date | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type TournamentsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    entryFee: number
    prizePool: number
    maxPlayers: number
    status: number
    startTime: number
    endTime: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type TournamentsAvgAggregateInputType = {
    entryFee?: true
    prizePool?: true
    maxPlayers?: true
  }

  export type TournamentsSumAggregateInputType = {
    entryFee?: true
    prizePool?: true
    maxPlayers?: true
  }

  export type TournamentsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    entryFee?: true
    prizePool?: true
    maxPlayers?: true
    status?: true
    startTime?: true
    endTime?: true
    createdBy?: true
    createdAt?: true
  }

  export type TournamentsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    entryFee?: true
    prizePool?: true
    maxPlayers?: true
    status?: true
    startTime?: true
    endTime?: true
    createdBy?: true
    createdAt?: true
  }

  export type TournamentsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    entryFee?: true
    prizePool?: true
    maxPlayers?: true
    status?: true
    startTime?: true
    endTime?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type TournamentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournaments to aggregate.
     */
    where?: tournamentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentsOrderByWithRelationInput | tournamentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tournamentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tournaments
    **/
    _count?: true | TournamentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamentsMaxAggregateInputType
  }

  export type GetTournamentsAggregateType<T extends TournamentsAggregateArgs> = {
        [P in keyof T & keyof AggregateTournaments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournaments[P]>
      : GetScalarType<T[P], AggregateTournaments[P]>
  }




  export type tournamentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamentsWhereInput
    orderBy?: tournamentsOrderByWithAggregationInput | tournamentsOrderByWithAggregationInput[]
    by: TournamentsScalarFieldEnum[] | TournamentsScalarFieldEnum
    having?: tournamentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamentsCountAggregateInputType | true
    _avg?: TournamentsAvgAggregateInputType
    _sum?: TournamentsSumAggregateInputType
    _min?: TournamentsMinAggregateInputType
    _max?: TournamentsMaxAggregateInputType
  }

  export type TournamentsGroupByOutputType = {
    id: string
    name: string
    description: string | null
    entryFee: number
    prizePool: number
    maxPlayers: number | null
    status: $Enums.TournamentStatus
    startTime: Date | null
    endTime: Date | null
    createdBy: string
    createdAt: Date
    _count: TournamentsCountAggregateOutputType | null
    _avg: TournamentsAvgAggregateOutputType | null
    _sum: TournamentsSumAggregateOutputType | null
    _min: TournamentsMinAggregateOutputType | null
    _max: TournamentsMaxAggregateOutputType | null
  }

  type GetTournamentsGroupByPayload<T extends tournamentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamentsGroupByOutputType[P]>
            : GetScalarType<T[P], TournamentsGroupByOutputType[P]>
        }
      >
    >


  export type tournamentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    entryFee?: boolean
    prizePool?: boolean
    maxPlayers?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    createdBy?: boolean
    createdAt?: boolean
    games?: boolean | tournaments$gamesArgs<ExtArgs>
    participants?: boolean | tournaments$participantsArgs<ExtArgs>
    matches?: boolean | tournaments$matchesArgs<ExtArgs>
    creator?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | TournamentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournaments"]>

  export type tournamentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    entryFee?: boolean
    prizePool?: boolean
    maxPlayers?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournaments"]>

  export type tournamentsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    entryFee?: boolean
    prizePool?: boolean
    maxPlayers?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type tournamentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | tournaments$gamesArgs<ExtArgs>
    participants?: boolean | tournaments$participantsArgs<ExtArgs>
    matches?: boolean | tournaments$matchesArgs<ExtArgs>
    creator?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | TournamentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tournamentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $tournamentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tournaments"
    objects: {
      games: Prisma.$gamesPayload<ExtArgs>[]
      participants: Prisma.$tournament_participantsPayload<ExtArgs>[]
      matches: Prisma.$tournament_matchesPayload<ExtArgs>[]
      creator: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      entryFee: number
      prizePool: number
      maxPlayers: number | null
      status: $Enums.TournamentStatus
      startTime: Date | null
      endTime: Date | null
      createdBy: string
      createdAt: Date
    }, ExtArgs["result"]["tournaments"]>
    composites: {}
  }

  type tournamentsGetPayload<S extends boolean | null | undefined | tournamentsDefaultArgs> = $Result.GetResult<Prisma.$tournamentsPayload, S>

  type tournamentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tournamentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TournamentsCountAggregateInputType | true
    }

  export interface tournamentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tournaments'], meta: { name: 'tournaments' } }
    /**
     * Find zero or one Tournaments that matches the filter.
     * @param {tournamentsFindUniqueArgs} args - Arguments to find a Tournaments
     * @example
     * // Get one Tournaments
     * const tournaments = await prisma.tournaments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tournamentsFindUniqueArgs>(args: SelectSubset<T, tournamentsFindUniqueArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tournaments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tournamentsFindUniqueOrThrowArgs} args - Arguments to find a Tournaments
     * @example
     * // Get one Tournaments
     * const tournaments = await prisma.tournaments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tournamentsFindUniqueOrThrowArgs>(args: SelectSubset<T, tournamentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tournaments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentsFindFirstArgs} args - Arguments to find a Tournaments
     * @example
     * // Get one Tournaments
     * const tournaments = await prisma.tournaments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tournamentsFindFirstArgs>(args?: SelectSubset<T, tournamentsFindFirstArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tournaments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentsFindFirstOrThrowArgs} args - Arguments to find a Tournaments
     * @example
     * // Get one Tournaments
     * const tournaments = await prisma.tournaments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tournamentsFindFirstOrThrowArgs>(args?: SelectSubset<T, tournamentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tournaments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournaments
     * const tournaments = await prisma.tournaments.findMany()
     * 
     * // Get first 10 Tournaments
     * const tournaments = await prisma.tournaments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentsWithIdOnly = await prisma.tournaments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tournamentsFindManyArgs>(args?: SelectSubset<T, tournamentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tournaments.
     * @param {tournamentsCreateArgs} args - Arguments to create a Tournaments.
     * @example
     * // Create one Tournaments
     * const Tournaments = await prisma.tournaments.create({
     *   data: {
     *     // ... data to create a Tournaments
     *   }
     * })
     * 
     */
    create<T extends tournamentsCreateArgs>(args: SelectSubset<T, tournamentsCreateArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tournaments.
     * @param {tournamentsCreateManyArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournaments = await prisma.tournaments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tournamentsCreateManyArgs>(args?: SelectSubset<T, tournamentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tournaments and returns the data saved in the database.
     * @param {tournamentsCreateManyAndReturnArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournaments = await prisma.tournaments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tournaments and only return the `id`
     * const tournamentsWithIdOnly = await prisma.tournaments.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tournamentsCreateManyAndReturnArgs>(args?: SelectSubset<T, tournamentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tournaments.
     * @param {tournamentsDeleteArgs} args - Arguments to delete one Tournaments.
     * @example
     * // Delete one Tournaments
     * const Tournaments = await prisma.tournaments.delete({
     *   where: {
     *     // ... filter to delete one Tournaments
     *   }
     * })
     * 
     */
    delete<T extends tournamentsDeleteArgs>(args: SelectSubset<T, tournamentsDeleteArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tournaments.
     * @param {tournamentsUpdateArgs} args - Arguments to update one Tournaments.
     * @example
     * // Update one Tournaments
     * const tournaments = await prisma.tournaments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tournamentsUpdateArgs>(args: SelectSubset<T, tournamentsUpdateArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tournaments.
     * @param {tournamentsDeleteManyArgs} args - Arguments to filter Tournaments to delete.
     * @example
     * // Delete a few Tournaments
     * const { count } = await prisma.tournaments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tournamentsDeleteManyArgs>(args?: SelectSubset<T, tournamentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournaments
     * const tournaments = await prisma.tournaments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tournamentsUpdateManyArgs>(args: SelectSubset<T, tournamentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tournaments.
     * @param {tournamentsUpsertArgs} args - Arguments to update or create a Tournaments.
     * @example
     * // Update or create a Tournaments
     * const tournaments = await prisma.tournaments.upsert({
     *   create: {
     *     // ... data to create a Tournaments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournaments we want to update
     *   }
     * })
     */
    upsert<T extends tournamentsUpsertArgs>(args: SelectSubset<T, tournamentsUpsertArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentsCountArgs} args - Arguments to filter Tournaments to count.
     * @example
     * // Count the number of Tournaments
     * const count = await prisma.tournaments.count({
     *   where: {
     *     // ... the filter for the Tournaments we want to count
     *   }
     * })
    **/
    count<T extends tournamentsCountArgs>(
      args?: Subset<T, tournamentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentsAggregateArgs>(args: Subset<T, TournamentsAggregateArgs>): Prisma.PrismaPromise<GetTournamentsAggregateType<T>>

    /**
     * Group by Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tournamentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tournamentsGroupByArgs['orderBy'] }
        : { orderBy?: tournamentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tournamentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tournaments model
   */
  readonly fields: tournamentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tournaments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tournamentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    games<T extends tournaments$gamesArgs<ExtArgs> = {}>(args?: Subset<T, tournaments$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findMany"> | Null>
    participants<T extends tournaments$participantsArgs<ExtArgs> = {}>(args?: Subset<T, tournaments$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "findMany"> | Null>
    matches<T extends tournaments$matchesArgs<ExtArgs> = {}>(args?: Subset<T, tournaments$matchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournament_matchesPayload<ExtArgs>, T, "findMany"> | Null>
    creator<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tournaments model
   */ 
  interface tournamentsFieldRefs {
    readonly id: FieldRef<"tournaments", 'String'>
    readonly name: FieldRef<"tournaments", 'String'>
    readonly description: FieldRef<"tournaments", 'String'>
    readonly entryFee: FieldRef<"tournaments", 'Int'>
    readonly prizePool: FieldRef<"tournaments", 'Int'>
    readonly maxPlayers: FieldRef<"tournaments", 'Int'>
    readonly status: FieldRef<"tournaments", 'TournamentStatus'>
    readonly startTime: FieldRef<"tournaments", 'DateTime'>
    readonly endTime: FieldRef<"tournaments", 'DateTime'>
    readonly createdBy: FieldRef<"tournaments", 'String'>
    readonly createdAt: FieldRef<"tournaments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tournaments findUnique
   */
  export type tournamentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    /**
     * Filter, which tournaments to fetch.
     */
    where: tournamentsWhereUniqueInput
  }

  /**
   * tournaments findUniqueOrThrow
   */
  export type tournamentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    /**
     * Filter, which tournaments to fetch.
     */
    where: tournamentsWhereUniqueInput
  }

  /**
   * tournaments findFirst
   */
  export type tournamentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    /**
     * Filter, which tournaments to fetch.
     */
    where?: tournamentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentsOrderByWithRelationInput | tournamentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournaments.
     */
    cursor?: tournamentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournaments.
     */
    distinct?: TournamentsScalarFieldEnum | TournamentsScalarFieldEnum[]
  }

  /**
   * tournaments findFirstOrThrow
   */
  export type tournamentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    /**
     * Filter, which tournaments to fetch.
     */
    where?: tournamentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentsOrderByWithRelationInput | tournamentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournaments.
     */
    cursor?: tournamentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournaments.
     */
    distinct?: TournamentsScalarFieldEnum | TournamentsScalarFieldEnum[]
  }

  /**
   * tournaments findMany
   */
  export type tournamentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    /**
     * Filter, which tournaments to fetch.
     */
    where?: tournamentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentsOrderByWithRelationInput | tournamentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tournaments.
     */
    cursor?: tournamentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    distinct?: TournamentsScalarFieldEnum | TournamentsScalarFieldEnum[]
  }

  /**
   * tournaments create
   */
  export type tournamentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    /**
     * The data needed to create a tournaments.
     */
    data: XOR<tournamentsCreateInput, tournamentsUncheckedCreateInput>
  }

  /**
   * tournaments createMany
   */
  export type tournamentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tournaments.
     */
    data: tournamentsCreateManyInput | tournamentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tournaments createManyAndReturn
   */
  export type tournamentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many tournaments.
     */
    data: tournamentsCreateManyInput | tournamentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tournaments update
   */
  export type tournamentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    /**
     * The data needed to update a tournaments.
     */
    data: XOR<tournamentsUpdateInput, tournamentsUncheckedUpdateInput>
    /**
     * Choose, which tournaments to update.
     */
    where: tournamentsWhereUniqueInput
  }

  /**
   * tournaments updateMany
   */
  export type tournamentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tournaments.
     */
    data: XOR<tournamentsUpdateManyMutationInput, tournamentsUncheckedUpdateManyInput>
    /**
     * Filter which tournaments to update
     */
    where?: tournamentsWhereInput
  }

  /**
   * tournaments upsert
   */
  export type tournamentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    /**
     * The filter to search for the tournaments to update in case it exists.
     */
    where: tournamentsWhereUniqueInput
    /**
     * In case the tournaments found by the `where` argument doesn't exist, create a new tournaments with this data.
     */
    create: XOR<tournamentsCreateInput, tournamentsUncheckedCreateInput>
    /**
     * In case the tournaments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tournamentsUpdateInput, tournamentsUncheckedUpdateInput>
  }

  /**
   * tournaments delete
   */
  export type tournamentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    /**
     * Filter which tournaments to delete.
     */
    where: tournamentsWhereUniqueInput
  }

  /**
   * tournaments deleteMany
   */
  export type tournamentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournaments to delete
     */
    where?: tournamentsWhereInput
  }

  /**
   * tournaments.games
   */
  export type tournaments$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    where?: gamesWhereInput
    orderBy?: gamesOrderByWithRelationInput | gamesOrderByWithRelationInput[]
    cursor?: gamesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamesScalarFieldEnum | GamesScalarFieldEnum[]
  }

  /**
   * tournaments.participants
   */
  export type tournaments$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    where?: tournament_participantsWhereInput
    orderBy?: tournament_participantsOrderByWithRelationInput | tournament_participantsOrderByWithRelationInput[]
    cursor?: tournament_participantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tournament_participantsScalarFieldEnum | Tournament_participantsScalarFieldEnum[]
  }

  /**
   * tournaments.matches
   */
  export type tournaments$matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_matches
     */
    select?: tournament_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_matchesInclude<ExtArgs> | null
    where?: tournament_matchesWhereInput
    orderBy?: tournament_matchesOrderByWithRelationInput | tournament_matchesOrderByWithRelationInput[]
    cursor?: tournament_matchesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tournament_matchesScalarFieldEnum | Tournament_matchesScalarFieldEnum[]
  }

  /**
   * tournaments without action
   */
  export type tournamentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
  }


  /**
   * Model user_analytics
   */

  export type AggregateUser_analytics = {
    _count: User_analyticsCountAggregateOutputType | null
    _avg: User_analyticsAvgAggregateOutputType | null
    _sum: User_analyticsSumAggregateOutputType | null
    _min: User_analyticsMinAggregateOutputType | null
    _max: User_analyticsMaxAggregateOutputType | null
  }

  export type User_analyticsAvgAggregateOutputType = {
    games_played: number | null
    games_won: number | null
    analyses_completed: number | null
    time_played: number | null
    avg_equity: number | null
    elo_change: number | null
    claude_requests_today: number | null
    claude_requests_this_month: number | null
    claude_quota_remaining: number | null
    chatgpt_requests_today: number | null
    chatgpt_requests_this_month: number | null
    gurubot_requests_today: number | null
    gurubot_requests_this_month: number | null
    gurubot_quota_remaining: number | null
    easybot_requests_today: number | null
  }

  export type User_analyticsSumAggregateOutputType = {
    games_played: number | null
    games_won: number | null
    analyses_completed: number | null
    time_played: number | null
    avg_equity: number | null
    elo_change: number | null
    claude_requests_today: number | null
    claude_requests_this_month: number | null
    claude_quota_remaining: number | null
    chatgpt_requests_today: number | null
    chatgpt_requests_this_month: number | null
    gurubot_requests_today: number | null
    gurubot_requests_this_month: number | null
    gurubot_quota_remaining: number | null
    easybot_requests_today: number | null
  }

  export type User_analyticsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    date: Date | null
    games_played: number | null
    games_won: number | null
    analyses_completed: number | null
    time_played: number | null
    avg_equity: number | null
    elo_change: number | null
    claude_requests_today: number | null
    claude_requests_this_month: number | null
    claude_quota_remaining: number | null
    chatgpt_requests_today: number | null
    chatgpt_requests_this_month: number | null
    gurubot_requests_today: number | null
    gurubot_requests_this_month: number | null
    gurubot_quota_remaining: number | null
    easybot_requests_today: number | null
    createdAt: Date | null
  }

  export type User_analyticsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    date: Date | null
    games_played: number | null
    games_won: number | null
    analyses_completed: number | null
    time_played: number | null
    avg_equity: number | null
    elo_change: number | null
    claude_requests_today: number | null
    claude_requests_this_month: number | null
    claude_quota_remaining: number | null
    chatgpt_requests_today: number | null
    chatgpt_requests_this_month: number | null
    gurubot_requests_today: number | null
    gurubot_requests_this_month: number | null
    gurubot_quota_remaining: number | null
    easybot_requests_today: number | null
    createdAt: Date | null
  }

  export type User_analyticsCountAggregateOutputType = {
    id: number
    user_id: number
    date: number
    games_played: number
    games_won: number
    analyses_completed: number
    time_played: number
    avg_equity: number
    elo_change: number
    claude_requests_today: number
    claude_requests_this_month: number
    claude_quota_remaining: number
    chatgpt_requests_today: number
    chatgpt_requests_this_month: number
    gurubot_requests_today: number
    gurubot_requests_this_month: number
    gurubot_quota_remaining: number
    easybot_requests_today: number
    createdAt: number
    _all: number
  }


  export type User_analyticsAvgAggregateInputType = {
    games_played?: true
    games_won?: true
    analyses_completed?: true
    time_played?: true
    avg_equity?: true
    elo_change?: true
    claude_requests_today?: true
    claude_requests_this_month?: true
    claude_quota_remaining?: true
    chatgpt_requests_today?: true
    chatgpt_requests_this_month?: true
    gurubot_requests_today?: true
    gurubot_requests_this_month?: true
    gurubot_quota_remaining?: true
    easybot_requests_today?: true
  }

  export type User_analyticsSumAggregateInputType = {
    games_played?: true
    games_won?: true
    analyses_completed?: true
    time_played?: true
    avg_equity?: true
    elo_change?: true
    claude_requests_today?: true
    claude_requests_this_month?: true
    claude_quota_remaining?: true
    chatgpt_requests_today?: true
    chatgpt_requests_this_month?: true
    gurubot_requests_today?: true
    gurubot_requests_this_month?: true
    gurubot_quota_remaining?: true
    easybot_requests_today?: true
  }

  export type User_analyticsMinAggregateInputType = {
    id?: true
    user_id?: true
    date?: true
    games_played?: true
    games_won?: true
    analyses_completed?: true
    time_played?: true
    avg_equity?: true
    elo_change?: true
    claude_requests_today?: true
    claude_requests_this_month?: true
    claude_quota_remaining?: true
    chatgpt_requests_today?: true
    chatgpt_requests_this_month?: true
    gurubot_requests_today?: true
    gurubot_requests_this_month?: true
    gurubot_quota_remaining?: true
    easybot_requests_today?: true
    createdAt?: true
  }

  export type User_analyticsMaxAggregateInputType = {
    id?: true
    user_id?: true
    date?: true
    games_played?: true
    games_won?: true
    analyses_completed?: true
    time_played?: true
    avg_equity?: true
    elo_change?: true
    claude_requests_today?: true
    claude_requests_this_month?: true
    claude_quota_remaining?: true
    chatgpt_requests_today?: true
    chatgpt_requests_this_month?: true
    gurubot_requests_today?: true
    gurubot_requests_this_month?: true
    gurubot_quota_remaining?: true
    easybot_requests_today?: true
    createdAt?: true
  }

  export type User_analyticsCountAggregateInputType = {
    id?: true
    user_id?: true
    date?: true
    games_played?: true
    games_won?: true
    analyses_completed?: true
    time_played?: true
    avg_equity?: true
    elo_change?: true
    claude_requests_today?: true
    claude_requests_this_month?: true
    claude_quota_remaining?: true
    chatgpt_requests_today?: true
    chatgpt_requests_this_month?: true
    gurubot_requests_today?: true
    gurubot_requests_this_month?: true
    gurubot_quota_remaining?: true
    easybot_requests_today?: true
    createdAt?: true
    _all?: true
  }

  export type User_analyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_analytics to aggregate.
     */
    where?: user_analyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_analytics to fetch.
     */
    orderBy?: user_analyticsOrderByWithRelationInput | user_analyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_analyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_analytics
    **/
    _count?: true | User_analyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_analyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_analyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_analyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_analyticsMaxAggregateInputType
  }

  export type GetUser_analyticsAggregateType<T extends User_analyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_analytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_analytics[P]>
      : GetScalarType<T[P], AggregateUser_analytics[P]>
  }




  export type user_analyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_analyticsWhereInput
    orderBy?: user_analyticsOrderByWithAggregationInput | user_analyticsOrderByWithAggregationInput[]
    by: User_analyticsScalarFieldEnum[] | User_analyticsScalarFieldEnum
    having?: user_analyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_analyticsCountAggregateInputType | true
    _avg?: User_analyticsAvgAggregateInputType
    _sum?: User_analyticsSumAggregateInputType
    _min?: User_analyticsMinAggregateInputType
    _max?: User_analyticsMaxAggregateInputType
  }

  export type User_analyticsGroupByOutputType = {
    id: string
    user_id: string
    date: Date
    games_played: number
    games_won: number
    analyses_completed: number
    time_played: number
    avg_equity: number
    elo_change: number
    claude_requests_today: number
    claude_requests_this_month: number
    claude_quota_remaining: number
    chatgpt_requests_today: number
    chatgpt_requests_this_month: number
    gurubot_requests_today: number
    gurubot_requests_this_month: number
    gurubot_quota_remaining: number
    easybot_requests_today: number
    createdAt: Date
    _count: User_analyticsCountAggregateOutputType | null
    _avg: User_analyticsAvgAggregateOutputType | null
    _sum: User_analyticsSumAggregateOutputType | null
    _min: User_analyticsMinAggregateOutputType | null
    _max: User_analyticsMaxAggregateOutputType | null
  }

  type GetUser_analyticsGroupByPayload<T extends user_analyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_analyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_analyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_analyticsGroupByOutputType[P]>
            : GetScalarType<T[P], User_analyticsGroupByOutputType[P]>
        }
      >
    >


  export type user_analyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    date?: boolean
    games_played?: boolean
    games_won?: boolean
    analyses_completed?: boolean
    time_played?: boolean
    avg_equity?: boolean
    elo_change?: boolean
    claude_requests_today?: boolean
    claude_requests_this_month?: boolean
    claude_quota_remaining?: boolean
    chatgpt_requests_today?: boolean
    chatgpt_requests_this_month?: boolean
    gurubot_requests_today?: boolean
    gurubot_requests_this_month?: boolean
    gurubot_quota_remaining?: boolean
    easybot_requests_today?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_analytics"]>

  export type user_analyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    date?: boolean
    games_played?: boolean
    games_won?: boolean
    analyses_completed?: boolean
    time_played?: boolean
    avg_equity?: boolean
    elo_change?: boolean
    claude_requests_today?: boolean
    claude_requests_this_month?: boolean
    claude_quota_remaining?: boolean
    chatgpt_requests_today?: boolean
    chatgpt_requests_this_month?: boolean
    gurubot_requests_today?: boolean
    gurubot_requests_this_month?: boolean
    gurubot_quota_remaining?: boolean
    easybot_requests_today?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_analytics"]>

  export type user_analyticsSelectScalar = {
    id?: boolean
    user_id?: boolean
    date?: boolean
    games_played?: boolean
    games_won?: boolean
    analyses_completed?: boolean
    time_played?: boolean
    avg_equity?: boolean
    elo_change?: boolean
    claude_requests_today?: boolean
    claude_requests_this_month?: boolean
    claude_quota_remaining?: boolean
    chatgpt_requests_today?: boolean
    chatgpt_requests_this_month?: boolean
    gurubot_requests_today?: boolean
    gurubot_requests_this_month?: boolean
    gurubot_quota_remaining?: boolean
    easybot_requests_today?: boolean
    createdAt?: boolean
  }

  export type user_analyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_analyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $user_analyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_analytics"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      date: Date
      games_played: number
      games_won: number
      analyses_completed: number
      time_played: number
      avg_equity: number
      elo_change: number
      claude_requests_today: number
      claude_requests_this_month: number
      claude_quota_remaining: number
      chatgpt_requests_today: number
      chatgpt_requests_this_month: number
      gurubot_requests_today: number
      gurubot_requests_this_month: number
      gurubot_quota_remaining: number
      easybot_requests_today: number
      createdAt: Date
    }, ExtArgs["result"]["user_analytics"]>
    composites: {}
  }

  type user_analyticsGetPayload<S extends boolean | null | undefined | user_analyticsDefaultArgs> = $Result.GetResult<Prisma.$user_analyticsPayload, S>

  type user_analyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_analyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_analyticsCountAggregateInputType | true
    }

  export interface user_analyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_analytics'], meta: { name: 'user_analytics' } }
    /**
     * Find zero or one User_analytics that matches the filter.
     * @param {user_analyticsFindUniqueArgs} args - Arguments to find a User_analytics
     * @example
     * // Get one User_analytics
     * const user_analytics = await prisma.user_analytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_analyticsFindUniqueArgs>(args: SelectSubset<T, user_analyticsFindUniqueArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_analytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_analyticsFindUniqueOrThrowArgs} args - Arguments to find a User_analytics
     * @example
     * // Get one User_analytics
     * const user_analytics = await prisma.user_analytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_analyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_analyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_analyticsFindFirstArgs} args - Arguments to find a User_analytics
     * @example
     * // Get one User_analytics
     * const user_analytics = await prisma.user_analytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_analyticsFindFirstArgs>(args?: SelectSubset<T, user_analyticsFindFirstArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_analytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_analyticsFindFirstOrThrowArgs} args - Arguments to find a User_analytics
     * @example
     * // Get one User_analytics
     * const user_analytics = await prisma.user_analytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_analyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_analyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_analyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_analytics
     * const user_analytics = await prisma.user_analytics.findMany()
     * 
     * // Get first 10 User_analytics
     * const user_analytics = await prisma.user_analytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_analyticsWithIdOnly = await prisma.user_analytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_analyticsFindManyArgs>(args?: SelectSubset<T, user_analyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_analytics.
     * @param {user_analyticsCreateArgs} args - Arguments to create a User_analytics.
     * @example
     * // Create one User_analytics
     * const User_analytics = await prisma.user_analytics.create({
     *   data: {
     *     // ... data to create a User_analytics
     *   }
     * })
     * 
     */
    create<T extends user_analyticsCreateArgs>(args: SelectSubset<T, user_analyticsCreateArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_analytics.
     * @param {user_analyticsCreateManyArgs} args - Arguments to create many User_analytics.
     * @example
     * // Create many User_analytics
     * const user_analytics = await prisma.user_analytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_analyticsCreateManyArgs>(args?: SelectSubset<T, user_analyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_analytics and returns the data saved in the database.
     * @param {user_analyticsCreateManyAndReturnArgs} args - Arguments to create many User_analytics.
     * @example
     * // Create many User_analytics
     * const user_analytics = await prisma.user_analytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_analytics and only return the `id`
     * const user_analyticsWithIdOnly = await prisma.user_analytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_analyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_analyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User_analytics.
     * @param {user_analyticsDeleteArgs} args - Arguments to delete one User_analytics.
     * @example
     * // Delete one User_analytics
     * const User_analytics = await prisma.user_analytics.delete({
     *   where: {
     *     // ... filter to delete one User_analytics
     *   }
     * })
     * 
     */
    delete<T extends user_analyticsDeleteArgs>(args: SelectSubset<T, user_analyticsDeleteArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_analytics.
     * @param {user_analyticsUpdateArgs} args - Arguments to update one User_analytics.
     * @example
     * // Update one User_analytics
     * const user_analytics = await prisma.user_analytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_analyticsUpdateArgs>(args: SelectSubset<T, user_analyticsUpdateArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_analytics.
     * @param {user_analyticsDeleteManyArgs} args - Arguments to filter User_analytics to delete.
     * @example
     * // Delete a few User_analytics
     * const { count } = await prisma.user_analytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_analyticsDeleteManyArgs>(args?: SelectSubset<T, user_analyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_analyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_analytics
     * const user_analytics = await prisma.user_analytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_analyticsUpdateManyArgs>(args: SelectSubset<T, user_analyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_analytics.
     * @param {user_analyticsUpsertArgs} args - Arguments to update or create a User_analytics.
     * @example
     * // Update or create a User_analytics
     * const user_analytics = await prisma.user_analytics.upsert({
     *   create: {
     *     // ... data to create a User_analytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_analytics we want to update
     *   }
     * })
     */
    upsert<T extends user_analyticsUpsertArgs>(args: SelectSubset<T, user_analyticsUpsertArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_analyticsCountArgs} args - Arguments to filter User_analytics to count.
     * @example
     * // Count the number of User_analytics
     * const count = await prisma.user_analytics.count({
     *   where: {
     *     // ... the filter for the User_analytics we want to count
     *   }
     * })
    **/
    count<T extends user_analyticsCountArgs>(
      args?: Subset<T, user_analyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_analyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_analyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_analyticsAggregateArgs>(args: Subset<T, User_analyticsAggregateArgs>): Prisma.PrismaPromise<GetUser_analyticsAggregateType<T>>

    /**
     * Group by User_analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_analyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_analyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_analyticsGroupByArgs['orderBy'] }
        : { orderBy?: user_analyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_analyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_analyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_analytics model
   */
  readonly fields: user_analyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_analytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_analyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_analytics model
   */ 
  interface user_analyticsFieldRefs {
    readonly id: FieldRef<"user_analytics", 'String'>
    readonly user_id: FieldRef<"user_analytics", 'String'>
    readonly date: FieldRef<"user_analytics", 'DateTime'>
    readonly games_played: FieldRef<"user_analytics", 'Int'>
    readonly games_won: FieldRef<"user_analytics", 'Int'>
    readonly analyses_completed: FieldRef<"user_analytics", 'Int'>
    readonly time_played: FieldRef<"user_analytics", 'Int'>
    readonly avg_equity: FieldRef<"user_analytics", 'Float'>
    readonly elo_change: FieldRef<"user_analytics", 'Int'>
    readonly claude_requests_today: FieldRef<"user_analytics", 'Int'>
    readonly claude_requests_this_month: FieldRef<"user_analytics", 'Int'>
    readonly claude_quota_remaining: FieldRef<"user_analytics", 'Int'>
    readonly chatgpt_requests_today: FieldRef<"user_analytics", 'Int'>
    readonly chatgpt_requests_this_month: FieldRef<"user_analytics", 'Int'>
    readonly gurubot_requests_today: FieldRef<"user_analytics", 'Int'>
    readonly gurubot_requests_this_month: FieldRef<"user_analytics", 'Int'>
    readonly gurubot_quota_remaining: FieldRef<"user_analytics", 'Int'>
    readonly easybot_requests_today: FieldRef<"user_analytics", 'Int'>
    readonly createdAt: FieldRef<"user_analytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_analytics findUnique
   */
  export type user_analyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which user_analytics to fetch.
     */
    where: user_analyticsWhereUniqueInput
  }

  /**
   * user_analytics findUniqueOrThrow
   */
  export type user_analyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which user_analytics to fetch.
     */
    where: user_analyticsWhereUniqueInput
  }

  /**
   * user_analytics findFirst
   */
  export type user_analyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which user_analytics to fetch.
     */
    where?: user_analyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_analytics to fetch.
     */
    orderBy?: user_analyticsOrderByWithRelationInput | user_analyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_analytics.
     */
    cursor?: user_analyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_analytics.
     */
    distinct?: User_analyticsScalarFieldEnum | User_analyticsScalarFieldEnum[]
  }

  /**
   * user_analytics findFirstOrThrow
   */
  export type user_analyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which user_analytics to fetch.
     */
    where?: user_analyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_analytics to fetch.
     */
    orderBy?: user_analyticsOrderByWithRelationInput | user_analyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_analytics.
     */
    cursor?: user_analyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_analytics.
     */
    distinct?: User_analyticsScalarFieldEnum | User_analyticsScalarFieldEnum[]
  }

  /**
   * user_analytics findMany
   */
  export type user_analyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which user_analytics to fetch.
     */
    where?: user_analyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_analytics to fetch.
     */
    orderBy?: user_analyticsOrderByWithRelationInput | user_analyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_analytics.
     */
    cursor?: user_analyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_analytics.
     */
    skip?: number
    distinct?: User_analyticsScalarFieldEnum | User_analyticsScalarFieldEnum[]
  }

  /**
   * user_analytics create
   */
  export type user_analyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_analytics.
     */
    data: XOR<user_analyticsCreateInput, user_analyticsUncheckedCreateInput>
  }

  /**
   * user_analytics createMany
   */
  export type user_analyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_analytics.
     */
    data: user_analyticsCreateManyInput | user_analyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_analytics createManyAndReturn
   */
  export type user_analyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many user_analytics.
     */
    data: user_analyticsCreateManyInput | user_analyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_analytics update
   */
  export type user_analyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_analytics.
     */
    data: XOR<user_analyticsUpdateInput, user_analyticsUncheckedUpdateInput>
    /**
     * Choose, which user_analytics to update.
     */
    where: user_analyticsWhereUniqueInput
  }

  /**
   * user_analytics updateMany
   */
  export type user_analyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_analytics.
     */
    data: XOR<user_analyticsUpdateManyMutationInput, user_analyticsUncheckedUpdateManyInput>
    /**
     * Filter which user_analytics to update
     */
    where?: user_analyticsWhereInput
  }

  /**
   * user_analytics upsert
   */
  export type user_analyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_analytics to update in case it exists.
     */
    where: user_analyticsWhereUniqueInput
    /**
     * In case the user_analytics found by the `where` argument doesn't exist, create a new user_analytics with this data.
     */
    create: XOR<user_analyticsCreateInput, user_analyticsUncheckedCreateInput>
    /**
     * In case the user_analytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_analyticsUpdateInput, user_analyticsUncheckedUpdateInput>
  }

  /**
   * user_analytics delete
   */
  export type user_analyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * Filter which user_analytics to delete.
     */
    where: user_analyticsWhereUniqueInput
  }

  /**
   * user_analytics deleteMany
   */
  export type user_analyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_analytics to delete
     */
    where?: user_analyticsWhereInput
  }

  /**
   * user_analytics without action
   */
  export type user_analyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
  }


  /**
   * Model game_analyses
   */

  export type AggregateGame_analyses = {
    _count: Game_analysesCountAggregateOutputType | null
    _min: Game_analysesMinAggregateOutputType | null
    _max: Game_analysesMaxAggregateOutputType | null
  }

  export type Game_analysesMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    game_id: string | null
    created_at: Date | null
  }

  export type Game_analysesMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    game_id: string | null
    created_at: Date | null
  }

  export type Game_analysesCountAggregateOutputType = {
    id: number
    user_id: number
    game_id: number
    analysis_report: number
    ai_services_used: number
    created_at: number
    _all: number
  }


  export type Game_analysesMinAggregateInputType = {
    id?: true
    user_id?: true
    game_id?: true
    created_at?: true
  }

  export type Game_analysesMaxAggregateInputType = {
    id?: true
    user_id?: true
    game_id?: true
    created_at?: true
  }

  export type Game_analysesCountAggregateInputType = {
    id?: true
    user_id?: true
    game_id?: true
    analysis_report?: true
    ai_services_used?: true
    created_at?: true
    _all?: true
  }

  export type Game_analysesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which game_analyses to aggregate.
     */
    where?: game_analysesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_analyses to fetch.
     */
    orderBy?: game_analysesOrderByWithRelationInput | game_analysesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: game_analysesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_analyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned game_analyses
    **/
    _count?: true | Game_analysesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Game_analysesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Game_analysesMaxAggregateInputType
  }

  export type GetGame_analysesAggregateType<T extends Game_analysesAggregateArgs> = {
        [P in keyof T & keyof AggregateGame_analyses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame_analyses[P]>
      : GetScalarType<T[P], AggregateGame_analyses[P]>
  }




  export type game_analysesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: game_analysesWhereInput
    orderBy?: game_analysesOrderByWithAggregationInput | game_analysesOrderByWithAggregationInput[]
    by: Game_analysesScalarFieldEnum[] | Game_analysesScalarFieldEnum
    having?: game_analysesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Game_analysesCountAggregateInputType | true
    _min?: Game_analysesMinAggregateInputType
    _max?: Game_analysesMaxAggregateInputType
  }

  export type Game_analysesGroupByOutputType = {
    id: string
    user_id: string
    game_id: string
    analysis_report: JsonValue
    ai_services_used: string[]
    created_at: Date
    _count: Game_analysesCountAggregateOutputType | null
    _min: Game_analysesMinAggregateOutputType | null
    _max: Game_analysesMaxAggregateOutputType | null
  }

  type GetGame_analysesGroupByPayload<T extends game_analysesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Game_analysesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Game_analysesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Game_analysesGroupByOutputType[P]>
            : GetScalarType<T[P], Game_analysesGroupByOutputType[P]>
        }
      >
    >


  export type game_analysesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    game_id?: boolean
    analysis_report?: boolean
    ai_services_used?: boolean
    created_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game_analyses"]>

  export type game_analysesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    game_id?: boolean
    analysis_report?: boolean
    ai_services_used?: boolean
    created_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game_analyses"]>

  export type game_analysesSelectScalar = {
    id?: boolean
    user_id?: boolean
    game_id?: boolean
    analysis_report?: boolean
    ai_services_used?: boolean
    created_at?: boolean
  }

  export type game_analysesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type game_analysesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $game_analysesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "game_analyses"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      game_id: string
      analysis_report: Prisma.JsonValue
      ai_services_used: string[]
      created_at: Date
    }, ExtArgs["result"]["game_analyses"]>
    composites: {}
  }

  type game_analysesGetPayload<S extends boolean | null | undefined | game_analysesDefaultArgs> = $Result.GetResult<Prisma.$game_analysesPayload, S>

  type game_analysesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<game_analysesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Game_analysesCountAggregateInputType | true
    }

  export interface game_analysesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['game_analyses'], meta: { name: 'game_analyses' } }
    /**
     * Find zero or one Game_analyses that matches the filter.
     * @param {game_analysesFindUniqueArgs} args - Arguments to find a Game_analyses
     * @example
     * // Get one Game_analyses
     * const game_analyses = await prisma.game_analyses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends game_analysesFindUniqueArgs>(args: SelectSubset<T, game_analysesFindUniqueArgs<ExtArgs>>): Prisma__game_analysesClient<$Result.GetResult<Prisma.$game_analysesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Game_analyses that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {game_analysesFindUniqueOrThrowArgs} args - Arguments to find a Game_analyses
     * @example
     * // Get one Game_analyses
     * const game_analyses = await prisma.game_analyses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends game_analysesFindUniqueOrThrowArgs>(args: SelectSubset<T, game_analysesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__game_analysesClient<$Result.GetResult<Prisma.$game_analysesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Game_analyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_analysesFindFirstArgs} args - Arguments to find a Game_analyses
     * @example
     * // Get one Game_analyses
     * const game_analyses = await prisma.game_analyses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends game_analysesFindFirstArgs>(args?: SelectSubset<T, game_analysesFindFirstArgs<ExtArgs>>): Prisma__game_analysesClient<$Result.GetResult<Prisma.$game_analysesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Game_analyses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_analysesFindFirstOrThrowArgs} args - Arguments to find a Game_analyses
     * @example
     * // Get one Game_analyses
     * const game_analyses = await prisma.game_analyses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends game_analysesFindFirstOrThrowArgs>(args?: SelectSubset<T, game_analysesFindFirstOrThrowArgs<ExtArgs>>): Prisma__game_analysesClient<$Result.GetResult<Prisma.$game_analysesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Game_analyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_analysesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Game_analyses
     * const game_analyses = await prisma.game_analyses.findMany()
     * 
     * // Get first 10 Game_analyses
     * const game_analyses = await prisma.game_analyses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const game_analysesWithIdOnly = await prisma.game_analyses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends game_analysesFindManyArgs>(args?: SelectSubset<T, game_analysesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_analysesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Game_analyses.
     * @param {game_analysesCreateArgs} args - Arguments to create a Game_analyses.
     * @example
     * // Create one Game_analyses
     * const Game_analyses = await prisma.game_analyses.create({
     *   data: {
     *     // ... data to create a Game_analyses
     *   }
     * })
     * 
     */
    create<T extends game_analysesCreateArgs>(args: SelectSubset<T, game_analysesCreateArgs<ExtArgs>>): Prisma__game_analysesClient<$Result.GetResult<Prisma.$game_analysesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Game_analyses.
     * @param {game_analysesCreateManyArgs} args - Arguments to create many Game_analyses.
     * @example
     * // Create many Game_analyses
     * const game_analyses = await prisma.game_analyses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends game_analysesCreateManyArgs>(args?: SelectSubset<T, game_analysesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Game_analyses and returns the data saved in the database.
     * @param {game_analysesCreateManyAndReturnArgs} args - Arguments to create many Game_analyses.
     * @example
     * // Create many Game_analyses
     * const game_analyses = await prisma.game_analyses.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Game_analyses and only return the `id`
     * const game_analysesWithIdOnly = await prisma.game_analyses.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends game_analysesCreateManyAndReturnArgs>(args?: SelectSubset<T, game_analysesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_analysesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Game_analyses.
     * @param {game_analysesDeleteArgs} args - Arguments to delete one Game_analyses.
     * @example
     * // Delete one Game_analyses
     * const Game_analyses = await prisma.game_analyses.delete({
     *   where: {
     *     // ... filter to delete one Game_analyses
     *   }
     * })
     * 
     */
    delete<T extends game_analysesDeleteArgs>(args: SelectSubset<T, game_analysesDeleteArgs<ExtArgs>>): Prisma__game_analysesClient<$Result.GetResult<Prisma.$game_analysesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Game_analyses.
     * @param {game_analysesUpdateArgs} args - Arguments to update one Game_analyses.
     * @example
     * // Update one Game_analyses
     * const game_analyses = await prisma.game_analyses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends game_analysesUpdateArgs>(args: SelectSubset<T, game_analysesUpdateArgs<ExtArgs>>): Prisma__game_analysesClient<$Result.GetResult<Prisma.$game_analysesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Game_analyses.
     * @param {game_analysesDeleteManyArgs} args - Arguments to filter Game_analyses to delete.
     * @example
     * // Delete a few Game_analyses
     * const { count } = await prisma.game_analyses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends game_analysesDeleteManyArgs>(args?: SelectSubset<T, game_analysesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Game_analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_analysesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Game_analyses
     * const game_analyses = await prisma.game_analyses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends game_analysesUpdateManyArgs>(args: SelectSubset<T, game_analysesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Game_analyses.
     * @param {game_analysesUpsertArgs} args - Arguments to update or create a Game_analyses.
     * @example
     * // Update or create a Game_analyses
     * const game_analyses = await prisma.game_analyses.upsert({
     *   create: {
     *     // ... data to create a Game_analyses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game_analyses we want to update
     *   }
     * })
     */
    upsert<T extends game_analysesUpsertArgs>(args: SelectSubset<T, game_analysesUpsertArgs<ExtArgs>>): Prisma__game_analysesClient<$Result.GetResult<Prisma.$game_analysesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Game_analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_analysesCountArgs} args - Arguments to filter Game_analyses to count.
     * @example
     * // Count the number of Game_analyses
     * const count = await prisma.game_analyses.count({
     *   where: {
     *     // ... the filter for the Game_analyses we want to count
     *   }
     * })
    **/
    count<T extends game_analysesCountArgs>(
      args?: Subset<T, game_analysesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Game_analysesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game_analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_analysesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Game_analysesAggregateArgs>(args: Subset<T, Game_analysesAggregateArgs>): Prisma.PrismaPromise<GetGame_analysesAggregateType<T>>

    /**
     * Group by Game_analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_analysesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends game_analysesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: game_analysesGroupByArgs['orderBy'] }
        : { orderBy?: game_analysesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, game_analysesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGame_analysesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the game_analyses model
   */
  readonly fields: game_analysesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for game_analyses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__game_analysesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the game_analyses model
   */ 
  interface game_analysesFieldRefs {
    readonly id: FieldRef<"game_analyses", 'String'>
    readonly user_id: FieldRef<"game_analyses", 'String'>
    readonly game_id: FieldRef<"game_analyses", 'String'>
    readonly analysis_report: FieldRef<"game_analyses", 'Json'>
    readonly ai_services_used: FieldRef<"game_analyses", 'String[]'>
    readonly created_at: FieldRef<"game_analyses", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * game_analyses findUnique
   */
  export type game_analysesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_analyses
     */
    select?: game_analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_analysesInclude<ExtArgs> | null
    /**
     * Filter, which game_analyses to fetch.
     */
    where: game_analysesWhereUniqueInput
  }

  /**
   * game_analyses findUniqueOrThrow
   */
  export type game_analysesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_analyses
     */
    select?: game_analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_analysesInclude<ExtArgs> | null
    /**
     * Filter, which game_analyses to fetch.
     */
    where: game_analysesWhereUniqueInput
  }

  /**
   * game_analyses findFirst
   */
  export type game_analysesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_analyses
     */
    select?: game_analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_analysesInclude<ExtArgs> | null
    /**
     * Filter, which game_analyses to fetch.
     */
    where?: game_analysesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_analyses to fetch.
     */
    orderBy?: game_analysesOrderByWithRelationInput | game_analysesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for game_analyses.
     */
    cursor?: game_analysesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_analyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of game_analyses.
     */
    distinct?: Game_analysesScalarFieldEnum | Game_analysesScalarFieldEnum[]
  }

  /**
   * game_analyses findFirstOrThrow
   */
  export type game_analysesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_analyses
     */
    select?: game_analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_analysesInclude<ExtArgs> | null
    /**
     * Filter, which game_analyses to fetch.
     */
    where?: game_analysesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_analyses to fetch.
     */
    orderBy?: game_analysesOrderByWithRelationInput | game_analysesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for game_analyses.
     */
    cursor?: game_analysesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_analyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of game_analyses.
     */
    distinct?: Game_analysesScalarFieldEnum | Game_analysesScalarFieldEnum[]
  }

  /**
   * game_analyses findMany
   */
  export type game_analysesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_analyses
     */
    select?: game_analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_analysesInclude<ExtArgs> | null
    /**
     * Filter, which game_analyses to fetch.
     */
    where?: game_analysesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_analyses to fetch.
     */
    orderBy?: game_analysesOrderByWithRelationInput | game_analysesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing game_analyses.
     */
    cursor?: game_analysesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_analyses.
     */
    skip?: number
    distinct?: Game_analysesScalarFieldEnum | Game_analysesScalarFieldEnum[]
  }

  /**
   * game_analyses create
   */
  export type game_analysesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_analyses
     */
    select?: game_analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_analysesInclude<ExtArgs> | null
    /**
     * The data needed to create a game_analyses.
     */
    data: XOR<game_analysesCreateInput, game_analysesUncheckedCreateInput>
  }

  /**
   * game_analyses createMany
   */
  export type game_analysesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many game_analyses.
     */
    data: game_analysesCreateManyInput | game_analysesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * game_analyses createManyAndReturn
   */
  export type game_analysesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_analyses
     */
    select?: game_analysesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many game_analyses.
     */
    data: game_analysesCreateManyInput | game_analysesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_analysesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * game_analyses update
   */
  export type game_analysesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_analyses
     */
    select?: game_analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_analysesInclude<ExtArgs> | null
    /**
     * The data needed to update a game_analyses.
     */
    data: XOR<game_analysesUpdateInput, game_analysesUncheckedUpdateInput>
    /**
     * Choose, which game_analyses to update.
     */
    where: game_analysesWhereUniqueInput
  }

  /**
   * game_analyses updateMany
   */
  export type game_analysesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update game_analyses.
     */
    data: XOR<game_analysesUpdateManyMutationInput, game_analysesUncheckedUpdateManyInput>
    /**
     * Filter which game_analyses to update
     */
    where?: game_analysesWhereInput
  }

  /**
   * game_analyses upsert
   */
  export type game_analysesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_analyses
     */
    select?: game_analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_analysesInclude<ExtArgs> | null
    /**
     * The filter to search for the game_analyses to update in case it exists.
     */
    where: game_analysesWhereUniqueInput
    /**
     * In case the game_analyses found by the `where` argument doesn't exist, create a new game_analyses with this data.
     */
    create: XOR<game_analysesCreateInput, game_analysesUncheckedCreateInput>
    /**
     * In case the game_analyses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<game_analysesUpdateInput, game_analysesUncheckedUpdateInput>
  }

  /**
   * game_analyses delete
   */
  export type game_analysesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_analyses
     */
    select?: game_analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_analysesInclude<ExtArgs> | null
    /**
     * Filter which game_analyses to delete.
     */
    where: game_analysesWhereUniqueInput
  }

  /**
   * game_analyses deleteMany
   */
  export type game_analysesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which game_analyses to delete
     */
    where?: game_analysesWhereInput
  }

  /**
   * game_analyses without action
   */
  export type game_analysesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_analyses
     */
    select?: game_analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_analysesInclude<ExtArgs> | null
  }


  /**
   * Model games
   */

  export type AggregateGames = {
    _count: GamesCountAggregateOutputType | null
    _avg: GamesAvgAggregateOutputType | null
    _sum: GamesSumAggregateOutputType | null
    _min: GamesMinAggregateOutputType | null
    _max: GamesMaxAggregateOutputType | null
  }

  export type GamesAvgAggregateOutputType = {
    stake: number | null
    whiteScore: number | null
    blackScore: number | null
    dice: number | null
    cubeLevel: number | null
    matchLength: number | null
    timeControlTotalMs: number | null
    timeControlIncrementMs: number | null
    timeControlDelayMs: number | null
    whiteTimeRemainingMs: number | null
    blackTimeRemainingMs: number | null
  }

  export type GamesSumAggregateOutputType = {
    stake: number | null
    whiteScore: number | null
    blackScore: number | null
    dice: number[]
    cubeLevel: number | null
    matchLength: number | null
    timeControlTotalMs: number | null
    timeControlIncrementMs: number | null
    timeControlDelayMs: number | null
    whiteTimeRemainingMs: number | null
    blackTimeRemainingMs: number | null
  }

  export type GamesMinAggregateOutputType = {
    id: string | null
    whitePlayerId: string | null
    blackPlayerId: string | null
    tournamentId: string | null
    gameMode: $Enums.GameMode | null
    status: $Enums.GameStatus | null
    stake: number | null
    winner: $Enums.Player | null
    drawOfferedBy: $Enums.Player | null
    whiteScore: number | null
    blackScore: number | null
    currentPlayer: $Enums.Player | null
    cubeLevel: number | null
    cubeOwner: $Enums.Player | null
    matchLength: number | null
    doubleOfferedBy: string | null
    doublePending: boolean | null
    timeControlPreset: $Enums.TimeControlPreset | null
    timeControlTotalMs: number | null
    timeControlIncrementMs: number | null
    timeControlDelayMs: number | null
    whiteTimeRemainingMs: number | null
    blackTimeRemainingMs: number | null
    activeTimer: $Enums.Player | null
    timerUpdatedAt: Date | null
    createdAt: Date | null
    finishedAt: Date | null
    updatedAt: Date | null
    resignationType: $Enums.ResignationType | null
  }

  export type GamesMaxAggregateOutputType = {
    id: string | null
    whitePlayerId: string | null
    blackPlayerId: string | null
    tournamentId: string | null
    gameMode: $Enums.GameMode | null
    status: $Enums.GameStatus | null
    stake: number | null
    winner: $Enums.Player | null
    drawOfferedBy: $Enums.Player | null
    whiteScore: number | null
    blackScore: number | null
    currentPlayer: $Enums.Player | null
    cubeLevel: number | null
    cubeOwner: $Enums.Player | null
    matchLength: number | null
    doubleOfferedBy: string | null
    doublePending: boolean | null
    timeControlPreset: $Enums.TimeControlPreset | null
    timeControlTotalMs: number | null
    timeControlIncrementMs: number | null
    timeControlDelayMs: number | null
    whiteTimeRemainingMs: number | null
    blackTimeRemainingMs: number | null
    activeTimer: $Enums.Player | null
    timerUpdatedAt: Date | null
    createdAt: Date | null
    finishedAt: Date | null
    updatedAt: Date | null
    resignationType: $Enums.ResignationType | null
  }

  export type GamesCountAggregateOutputType = {
    id: number
    whitePlayerId: number
    blackPlayerId: number
    tournamentId: number
    gameMode: number
    status: number
    stake: number
    winner: number
    drawOfferedBy: number
    whiteScore: number
    blackScore: number
    boardState: number
    currentPlayer: number
    dice: number
    cubeLevel: number
    cubeOwner: number
    matchLength: number
    doubleOfferedBy: number
    doublePending: number
    cubeHistory: number
    timeControlPreset: number
    timeControlTotalMs: number
    timeControlIncrementMs: number
    timeControlDelayMs: number
    whiteTimeRemainingMs: number
    blackTimeRemainingMs: number
    activeTimer: number
    timerUpdatedAt: number
    createdAt: number
    finishedAt: number
    updatedAt: number
    resignationType: number
    _all: number
  }


  export type GamesAvgAggregateInputType = {
    stake?: true
    whiteScore?: true
    blackScore?: true
    dice?: true
    cubeLevel?: true
    matchLength?: true
    timeControlTotalMs?: true
    timeControlIncrementMs?: true
    timeControlDelayMs?: true
    whiteTimeRemainingMs?: true
    blackTimeRemainingMs?: true
  }

  export type GamesSumAggregateInputType = {
    stake?: true
    whiteScore?: true
    blackScore?: true
    dice?: true
    cubeLevel?: true
    matchLength?: true
    timeControlTotalMs?: true
    timeControlIncrementMs?: true
    timeControlDelayMs?: true
    whiteTimeRemainingMs?: true
    blackTimeRemainingMs?: true
  }

  export type GamesMinAggregateInputType = {
    id?: true
    whitePlayerId?: true
    blackPlayerId?: true
    tournamentId?: true
    gameMode?: true
    status?: true
    stake?: true
    winner?: true
    drawOfferedBy?: true
    whiteScore?: true
    blackScore?: true
    currentPlayer?: true
    cubeLevel?: true
    cubeOwner?: true
    matchLength?: true
    doubleOfferedBy?: true
    doublePending?: true
    timeControlPreset?: true
    timeControlTotalMs?: true
    timeControlIncrementMs?: true
    timeControlDelayMs?: true
    whiteTimeRemainingMs?: true
    blackTimeRemainingMs?: true
    activeTimer?: true
    timerUpdatedAt?: true
    createdAt?: true
    finishedAt?: true
    updatedAt?: true
    resignationType?: true
  }

  export type GamesMaxAggregateInputType = {
    id?: true
    whitePlayerId?: true
    blackPlayerId?: true
    tournamentId?: true
    gameMode?: true
    status?: true
    stake?: true
    winner?: true
    drawOfferedBy?: true
    whiteScore?: true
    blackScore?: true
    currentPlayer?: true
    cubeLevel?: true
    cubeOwner?: true
    matchLength?: true
    doubleOfferedBy?: true
    doublePending?: true
    timeControlPreset?: true
    timeControlTotalMs?: true
    timeControlIncrementMs?: true
    timeControlDelayMs?: true
    whiteTimeRemainingMs?: true
    blackTimeRemainingMs?: true
    activeTimer?: true
    timerUpdatedAt?: true
    createdAt?: true
    finishedAt?: true
    updatedAt?: true
    resignationType?: true
  }

  export type GamesCountAggregateInputType = {
    id?: true
    whitePlayerId?: true
    blackPlayerId?: true
    tournamentId?: true
    gameMode?: true
    status?: true
    stake?: true
    winner?: true
    drawOfferedBy?: true
    whiteScore?: true
    blackScore?: true
    boardState?: true
    currentPlayer?: true
    dice?: true
    cubeLevel?: true
    cubeOwner?: true
    matchLength?: true
    doubleOfferedBy?: true
    doublePending?: true
    cubeHistory?: true
    timeControlPreset?: true
    timeControlTotalMs?: true
    timeControlIncrementMs?: true
    timeControlDelayMs?: true
    whiteTimeRemainingMs?: true
    blackTimeRemainingMs?: true
    activeTimer?: true
    timerUpdatedAt?: true
    createdAt?: true
    finishedAt?: true
    updatedAt?: true
    resignationType?: true
    _all?: true
  }

  export type GamesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which games to aggregate.
     */
    where?: gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of games to fetch.
     */
    orderBy?: gamesOrderByWithRelationInput | gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned games
    **/
    _count?: true | GamesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GamesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GamesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GamesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GamesMaxAggregateInputType
  }

  export type GetGamesAggregateType<T extends GamesAggregateArgs> = {
        [P in keyof T & keyof AggregateGames]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGames[P]>
      : GetScalarType<T[P], AggregateGames[P]>
  }




  export type gamesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gamesWhereInput
    orderBy?: gamesOrderByWithAggregationInput | gamesOrderByWithAggregationInput[]
    by: GamesScalarFieldEnum[] | GamesScalarFieldEnum
    having?: gamesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GamesCountAggregateInputType | true
    _avg?: GamesAvgAggregateInputType
    _sum?: GamesSumAggregateInputType
    _min?: GamesMinAggregateInputType
    _max?: GamesMaxAggregateInputType
  }

  export type GamesGroupByOutputType = {
    id: string
    whitePlayerId: string
    blackPlayerId: string | null
    tournamentId: string | null
    gameMode: $Enums.GameMode
    status: $Enums.GameStatus
    stake: number
    winner: $Enums.Player | null
    drawOfferedBy: $Enums.Player | null
    whiteScore: number
    blackScore: number
    boardState: JsonValue
    currentPlayer: $Enums.Player
    dice: number[]
    cubeLevel: number
    cubeOwner: $Enums.Player | null
    matchLength: number | null
    doubleOfferedBy: string | null
    doublePending: boolean
    cubeHistory: JsonValue
    timeControlPreset: $Enums.TimeControlPreset | null
    timeControlTotalMs: number | null
    timeControlIncrementMs: number | null
    timeControlDelayMs: number | null
    whiteTimeRemainingMs: number | null
    blackTimeRemainingMs: number | null
    activeTimer: $Enums.Player | null
    timerUpdatedAt: Date | null
    createdAt: Date
    finishedAt: Date | null
    updatedAt: Date
    resignationType: $Enums.ResignationType | null
    _count: GamesCountAggregateOutputType | null
    _avg: GamesAvgAggregateOutputType | null
    _sum: GamesSumAggregateOutputType | null
    _min: GamesMinAggregateOutputType | null
    _max: GamesMaxAggregateOutputType | null
  }

  type GetGamesGroupByPayload<T extends gamesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GamesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GamesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GamesGroupByOutputType[P]>
            : GetScalarType<T[P], GamesGroupByOutputType[P]>
        }
      >
    >


  export type gamesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    whitePlayerId?: boolean
    blackPlayerId?: boolean
    tournamentId?: boolean
    gameMode?: boolean
    status?: boolean
    stake?: boolean
    winner?: boolean
    drawOfferedBy?: boolean
    whiteScore?: boolean
    blackScore?: boolean
    boardState?: boolean
    currentPlayer?: boolean
    dice?: boolean
    cubeLevel?: boolean
    cubeOwner?: boolean
    matchLength?: boolean
    doubleOfferedBy?: boolean
    doublePending?: boolean
    cubeHistory?: boolean
    timeControlPreset?: boolean
    timeControlTotalMs?: boolean
    timeControlIncrementMs?: boolean
    timeControlDelayMs?: boolean
    whiteTimeRemainingMs?: boolean
    blackTimeRemainingMs?: boolean
    activeTimer?: boolean
    timerUpdatedAt?: boolean
    createdAt?: boolean
    finishedAt?: boolean
    updatedAt?: boolean
    resignationType?: boolean
    chatMessages?: boolean | games$chatMessagesArgs<ExtArgs>
    gameMoves?: boolean | games$gameMovesArgs<ExtArgs>
    tournament?: boolean | games$tournamentArgs<ExtArgs>
    websocketConnections?: boolean | games$websocketConnectionsArgs<ExtArgs>
    whitePlayer?: boolean | usersDefaultArgs<ExtArgs>
    blackPlayer?: boolean | games$blackPlayerArgs<ExtArgs>
    match?: boolean | games$matchArgs<ExtArgs>
    tournamentMatch?: boolean | games$tournamentMatchArgs<ExtArgs>
    sessions?: boolean | games$sessionsArgs<ExtArgs>
    events?: boolean | games$eventsArgs<ExtArgs>
    _count?: boolean | GamesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["games"]>

  export type gamesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    whitePlayerId?: boolean
    blackPlayerId?: boolean
    tournamentId?: boolean
    gameMode?: boolean
    status?: boolean
    stake?: boolean
    winner?: boolean
    drawOfferedBy?: boolean
    whiteScore?: boolean
    blackScore?: boolean
    boardState?: boolean
    currentPlayer?: boolean
    dice?: boolean
    cubeLevel?: boolean
    cubeOwner?: boolean
    matchLength?: boolean
    doubleOfferedBy?: boolean
    doublePending?: boolean
    cubeHistory?: boolean
    timeControlPreset?: boolean
    timeControlTotalMs?: boolean
    timeControlIncrementMs?: boolean
    timeControlDelayMs?: boolean
    whiteTimeRemainingMs?: boolean
    blackTimeRemainingMs?: boolean
    activeTimer?: boolean
    timerUpdatedAt?: boolean
    createdAt?: boolean
    finishedAt?: boolean
    updatedAt?: boolean
    resignationType?: boolean
    tournament?: boolean | games$tournamentArgs<ExtArgs>
    whitePlayer?: boolean | usersDefaultArgs<ExtArgs>
    blackPlayer?: boolean | games$blackPlayerArgs<ExtArgs>
  }, ExtArgs["result"]["games"]>

  export type gamesSelectScalar = {
    id?: boolean
    whitePlayerId?: boolean
    blackPlayerId?: boolean
    tournamentId?: boolean
    gameMode?: boolean
    status?: boolean
    stake?: boolean
    winner?: boolean
    drawOfferedBy?: boolean
    whiteScore?: boolean
    blackScore?: boolean
    boardState?: boolean
    currentPlayer?: boolean
    dice?: boolean
    cubeLevel?: boolean
    cubeOwner?: boolean
    matchLength?: boolean
    doubleOfferedBy?: boolean
    doublePending?: boolean
    cubeHistory?: boolean
    timeControlPreset?: boolean
    timeControlTotalMs?: boolean
    timeControlIncrementMs?: boolean
    timeControlDelayMs?: boolean
    whiteTimeRemainingMs?: boolean
    blackTimeRemainingMs?: boolean
    activeTimer?: boolean
    timerUpdatedAt?: boolean
    createdAt?: boolean
    finishedAt?: boolean
    updatedAt?: boolean
    resignationType?: boolean
  }

  export type gamesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatMessages?: boolean | games$chatMessagesArgs<ExtArgs>
    gameMoves?: boolean | games$gameMovesArgs<ExtArgs>
    tournament?: boolean | games$tournamentArgs<ExtArgs>
    websocketConnections?: boolean | games$websocketConnectionsArgs<ExtArgs>
    whitePlayer?: boolean | usersDefaultArgs<ExtArgs>
    blackPlayer?: boolean | games$blackPlayerArgs<ExtArgs>
    match?: boolean | games$matchArgs<ExtArgs>
    tournamentMatch?: boolean | games$tournamentMatchArgs<ExtArgs>
    sessions?: boolean | games$sessionsArgs<ExtArgs>
    events?: boolean | games$eventsArgs<ExtArgs>
    _count?: boolean | GamesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type gamesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournament?: boolean | games$tournamentArgs<ExtArgs>
    whitePlayer?: boolean | usersDefaultArgs<ExtArgs>
    blackPlayer?: boolean | games$blackPlayerArgs<ExtArgs>
  }

  export type $gamesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "games"
    objects: {
      chatMessages: Prisma.$chat_messagesPayload<ExtArgs>[]
      gameMoves: Prisma.$game_movesPayload<ExtArgs>[]
      tournament: Prisma.$tournamentsPayload<ExtArgs> | null
      websocketConnections: Prisma.$websocket_connectionsPayload<ExtArgs>[]
      whitePlayer: Prisma.$usersPayload<ExtArgs>
      blackPlayer: Prisma.$usersPayload<ExtArgs> | null
      match: Prisma.$matchesPayload<ExtArgs> | null
      tournamentMatch: Prisma.$tournament_matchesPayload<ExtArgs> | null
      sessions: Prisma.$GameSessionPayload<ExtArgs>[]
      events: Prisma.$GameEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      whitePlayerId: string
      blackPlayerId: string | null
      tournamentId: string | null
      gameMode: $Enums.GameMode
      status: $Enums.GameStatus
      stake: number
      winner: $Enums.Player | null
      drawOfferedBy: $Enums.Player | null
      whiteScore: number
      blackScore: number
      boardState: Prisma.JsonValue
      currentPlayer: $Enums.Player
      dice: number[]
      cubeLevel: number
      cubeOwner: $Enums.Player | null
      matchLength: number | null
      doubleOfferedBy: string | null
      doublePending: boolean
      cubeHistory: Prisma.JsonValue
      timeControlPreset: $Enums.TimeControlPreset | null
      timeControlTotalMs: number | null
      timeControlIncrementMs: number | null
      timeControlDelayMs: number | null
      whiteTimeRemainingMs: number | null
      blackTimeRemainingMs: number | null
      activeTimer: $Enums.Player | null
      timerUpdatedAt: Date | null
      createdAt: Date
      finishedAt: Date | null
      updatedAt: Date
      resignationType: $Enums.ResignationType | null
    }, ExtArgs["result"]["games"]>
    composites: {}
  }

  type gamesGetPayload<S extends boolean | null | undefined | gamesDefaultArgs> = $Result.GetResult<Prisma.$gamesPayload, S>

  type gamesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<gamesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GamesCountAggregateInputType | true
    }

  export interface gamesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['games'], meta: { name: 'games' } }
    /**
     * Find zero or one Games that matches the filter.
     * @param {gamesFindUniqueArgs} args - Arguments to find a Games
     * @example
     * // Get one Games
     * const games = await prisma.games.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends gamesFindUniqueArgs>(args: SelectSubset<T, gamesFindUniqueArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Games that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {gamesFindUniqueOrThrowArgs} args - Arguments to find a Games
     * @example
     * // Get one Games
     * const games = await prisma.games.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends gamesFindUniqueOrThrowArgs>(args: SelectSubset<T, gamesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesFindFirstArgs} args - Arguments to find a Games
     * @example
     * // Get one Games
     * const games = await prisma.games.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends gamesFindFirstArgs>(args?: SelectSubset<T, gamesFindFirstArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Games that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesFindFirstOrThrowArgs} args - Arguments to find a Games
     * @example
     * // Get one Games
     * const games = await prisma.games.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends gamesFindFirstOrThrowArgs>(args?: SelectSubset<T, gamesFindFirstOrThrowArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.games.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.games.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gamesWithIdOnly = await prisma.games.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends gamesFindManyArgs>(args?: SelectSubset<T, gamesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Games.
     * @param {gamesCreateArgs} args - Arguments to create a Games.
     * @example
     * // Create one Games
     * const Games = await prisma.games.create({
     *   data: {
     *     // ... data to create a Games
     *   }
     * })
     * 
     */
    create<T extends gamesCreateArgs>(args: SelectSubset<T, gamesCreateArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Games.
     * @param {gamesCreateManyArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const games = await prisma.games.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends gamesCreateManyArgs>(args?: SelectSubset<T, gamesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Games and returns the data saved in the database.
     * @param {gamesCreateManyAndReturnArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const games = await prisma.games.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Games and only return the `id`
     * const gamesWithIdOnly = await prisma.games.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends gamesCreateManyAndReturnArgs>(args?: SelectSubset<T, gamesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Games.
     * @param {gamesDeleteArgs} args - Arguments to delete one Games.
     * @example
     * // Delete one Games
     * const Games = await prisma.games.delete({
     *   where: {
     *     // ... filter to delete one Games
     *   }
     * })
     * 
     */
    delete<T extends gamesDeleteArgs>(args: SelectSubset<T, gamesDeleteArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Games.
     * @param {gamesUpdateArgs} args - Arguments to update one Games.
     * @example
     * // Update one Games
     * const games = await prisma.games.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends gamesUpdateArgs>(args: SelectSubset<T, gamesUpdateArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Games.
     * @param {gamesDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.games.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends gamesDeleteManyArgs>(args?: SelectSubset<T, gamesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const games = await prisma.games.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends gamesUpdateManyArgs>(args: SelectSubset<T, gamesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Games.
     * @param {gamesUpsertArgs} args - Arguments to update or create a Games.
     * @example
     * // Update or create a Games
     * const games = await prisma.games.upsert({
     *   create: {
     *     // ... data to create a Games
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Games we want to update
     *   }
     * })
     */
    upsert<T extends gamesUpsertArgs>(args: SelectSubset<T, gamesUpsertArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.games.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends gamesCountArgs>(
      args?: Subset<T, gamesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GamesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GamesAggregateArgs>(args: Subset<T, GamesAggregateArgs>): Prisma.PrismaPromise<GetGamesAggregateType<T>>

    /**
     * Group by Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gamesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gamesGroupByArgs['orderBy'] }
        : { orderBy?: gamesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gamesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGamesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the games model
   */
  readonly fields: gamesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for games.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__gamesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chatMessages<T extends games$chatMessagesArgs<ExtArgs> = {}>(args?: Subset<T, games$chatMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findMany"> | Null>
    gameMoves<T extends games$gameMovesArgs<ExtArgs> = {}>(args?: Subset<T, games$gameMovesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "findMany"> | Null>
    tournament<T extends games$tournamentArgs<ExtArgs> = {}>(args?: Subset<T, games$tournamentArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    websocketConnections<T extends games$websocketConnectionsArgs<ExtArgs> = {}>(args?: Subset<T, games$websocketConnectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "findMany"> | Null>
    whitePlayer<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    blackPlayer<T extends games$blackPlayerArgs<ExtArgs> = {}>(args?: Subset<T, games$blackPlayerArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    match<T extends games$matchArgs<ExtArgs> = {}>(args?: Subset<T, games$matchArgs<ExtArgs>>): Prisma__matchesClient<$Result.GetResult<Prisma.$matchesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tournamentMatch<T extends games$tournamentMatchArgs<ExtArgs> = {}>(args?: Subset<T, games$tournamentMatchArgs<ExtArgs>>): Prisma__tournament_matchesClient<$Result.GetResult<Prisma.$tournament_matchesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sessions<T extends games$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, games$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends games$eventsArgs<ExtArgs> = {}>(args?: Subset<T, games$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the games model
   */ 
  interface gamesFieldRefs {
    readonly id: FieldRef<"games", 'String'>
    readonly whitePlayerId: FieldRef<"games", 'String'>
    readonly blackPlayerId: FieldRef<"games", 'String'>
    readonly tournamentId: FieldRef<"games", 'String'>
    readonly gameMode: FieldRef<"games", 'GameMode'>
    readonly status: FieldRef<"games", 'GameStatus'>
    readonly stake: FieldRef<"games", 'Int'>
    readonly winner: FieldRef<"games", 'Player'>
    readonly drawOfferedBy: FieldRef<"games", 'Player'>
    readonly whiteScore: FieldRef<"games", 'Int'>
    readonly blackScore: FieldRef<"games", 'Int'>
    readonly boardState: FieldRef<"games", 'Json'>
    readonly currentPlayer: FieldRef<"games", 'Player'>
    readonly dice: FieldRef<"games", 'Int[]'>
    readonly cubeLevel: FieldRef<"games", 'Int'>
    readonly cubeOwner: FieldRef<"games", 'Player'>
    readonly matchLength: FieldRef<"games", 'Int'>
    readonly doubleOfferedBy: FieldRef<"games", 'String'>
    readonly doublePending: FieldRef<"games", 'Boolean'>
    readonly cubeHistory: FieldRef<"games", 'Json'>
    readonly timeControlPreset: FieldRef<"games", 'TimeControlPreset'>
    readonly timeControlTotalMs: FieldRef<"games", 'Int'>
    readonly timeControlIncrementMs: FieldRef<"games", 'Int'>
    readonly timeControlDelayMs: FieldRef<"games", 'Int'>
    readonly whiteTimeRemainingMs: FieldRef<"games", 'Int'>
    readonly blackTimeRemainingMs: FieldRef<"games", 'Int'>
    readonly activeTimer: FieldRef<"games", 'Player'>
    readonly timerUpdatedAt: FieldRef<"games", 'DateTime'>
    readonly createdAt: FieldRef<"games", 'DateTime'>
    readonly finishedAt: FieldRef<"games", 'DateTime'>
    readonly updatedAt: FieldRef<"games", 'DateTime'>
    readonly resignationType: FieldRef<"games", 'ResignationType'>
  }
    

  // Custom InputTypes
  /**
   * games findUnique
   */
  export type gamesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    /**
     * Filter, which games to fetch.
     */
    where: gamesWhereUniqueInput
  }

  /**
   * games findUniqueOrThrow
   */
  export type gamesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    /**
     * Filter, which games to fetch.
     */
    where: gamesWhereUniqueInput
  }

  /**
   * games findFirst
   */
  export type gamesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    /**
     * Filter, which games to fetch.
     */
    where?: gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of games to fetch.
     */
    orderBy?: gamesOrderByWithRelationInput | gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for games.
     */
    cursor?: gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of games.
     */
    distinct?: GamesScalarFieldEnum | GamesScalarFieldEnum[]
  }

  /**
   * games findFirstOrThrow
   */
  export type gamesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    /**
     * Filter, which games to fetch.
     */
    where?: gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of games to fetch.
     */
    orderBy?: gamesOrderByWithRelationInput | gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for games.
     */
    cursor?: gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of games.
     */
    distinct?: GamesScalarFieldEnum | GamesScalarFieldEnum[]
  }

  /**
   * games findMany
   */
  export type gamesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    /**
     * Filter, which games to fetch.
     */
    where?: gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of games to fetch.
     */
    orderBy?: gamesOrderByWithRelationInput | gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing games.
     */
    cursor?: gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` games.
     */
    skip?: number
    distinct?: GamesScalarFieldEnum | GamesScalarFieldEnum[]
  }

  /**
   * games create
   */
  export type gamesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    /**
     * The data needed to create a games.
     */
    data: XOR<gamesCreateInput, gamesUncheckedCreateInput>
  }

  /**
   * games createMany
   */
  export type gamesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many games.
     */
    data: gamesCreateManyInput | gamesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * games createManyAndReturn
   */
  export type gamesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many games.
     */
    data: gamesCreateManyInput | gamesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * games update
   */
  export type gamesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    /**
     * The data needed to update a games.
     */
    data: XOR<gamesUpdateInput, gamesUncheckedUpdateInput>
    /**
     * Choose, which games to update.
     */
    where: gamesWhereUniqueInput
  }

  /**
   * games updateMany
   */
  export type gamesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update games.
     */
    data: XOR<gamesUpdateManyMutationInput, gamesUncheckedUpdateManyInput>
    /**
     * Filter which games to update
     */
    where?: gamesWhereInput
  }

  /**
   * games upsert
   */
  export type gamesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    /**
     * The filter to search for the games to update in case it exists.
     */
    where: gamesWhereUniqueInput
    /**
     * In case the games found by the `where` argument doesn't exist, create a new games with this data.
     */
    create: XOR<gamesCreateInput, gamesUncheckedCreateInput>
    /**
     * In case the games was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gamesUpdateInput, gamesUncheckedUpdateInput>
  }

  /**
   * games delete
   */
  export type gamesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    /**
     * Filter which games to delete.
     */
    where: gamesWhereUniqueInput
  }

  /**
   * games deleteMany
   */
  export type gamesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which games to delete
     */
    where?: gamesWhereInput
  }

  /**
   * games.chatMessages
   */
  export type games$chatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    where?: chat_messagesWhereInput
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    cursor?: chat_messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * games.gameMoves
   */
  export type games$gameMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    where?: game_movesWhereInput
    orderBy?: game_movesOrderByWithRelationInput | game_movesOrderByWithRelationInput[]
    cursor?: game_movesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Game_movesScalarFieldEnum | Game_movesScalarFieldEnum[]
  }

  /**
   * games.tournament
   */
  export type games$tournamentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    where?: tournamentsWhereInput
  }

  /**
   * games.websocketConnections
   */
  export type games$websocketConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    where?: websocket_connectionsWhereInput
    orderBy?: websocket_connectionsOrderByWithRelationInput | websocket_connectionsOrderByWithRelationInput[]
    cursor?: websocket_connectionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Websocket_connectionsScalarFieldEnum | Websocket_connectionsScalarFieldEnum[]
  }

  /**
   * games.blackPlayer
   */
  export type games$blackPlayerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * games.match
   */
  export type games$matchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matches
     */
    select?: matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matchesInclude<ExtArgs> | null
    where?: matchesWhereInput
  }

  /**
   * games.tournamentMatch
   */
  export type games$tournamentMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_matches
     */
    select?: tournament_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_matchesInclude<ExtArgs> | null
    where?: tournament_matchesWhereInput
  }

  /**
   * games.sessions
   */
  export type games$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    where?: GameSessionWhereInput
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    cursor?: GameSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * games.events
   */
  export type games$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    where?: GameEventWhereInput
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    cursor?: GameEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameEventScalarFieldEnum | GameEventScalarFieldEnum[]
  }

  /**
   * games without action
   */
  export type gamesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
  }


  /**
   * Model GameSession
   */

  export type AggregateGameSession = {
    _count: GameSessionCountAggregateOutputType | null
    _avg: GameSessionAvgAggregateOutputType | null
    _sum: GameSessionSumAggregateOutputType | null
    _min: GameSessionMinAggregateOutputType | null
    _max: GameSessionMaxAggregateOutputType | null
  }

  export type GameSessionAvgAggregateOutputType = {
    lastAckSequence: number | null
  }

  export type GameSessionSumAggregateOutputType = {
    lastAckSequence: number | null
  }

  export type GameSessionMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    userId: string | null
    resumeTokenHash: string | null
    lastAckSequence: number | null
    lastHeartbeatAt: Date | null
    issuedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type GameSessionMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    userId: string | null
    resumeTokenHash: string | null
    lastAckSequence: number | null
    lastHeartbeatAt: Date | null
    issuedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type GameSessionCountAggregateOutputType = {
    id: number
    gameId: number
    userId: number
    resumeTokenHash: number
    lastAckSequence: number
    lastHeartbeatAt: number
    issuedAt: number
    expiresAt: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type GameSessionAvgAggregateInputType = {
    lastAckSequence?: true
  }

  export type GameSessionSumAggregateInputType = {
    lastAckSequence?: true
  }

  export type GameSessionMinAggregateInputType = {
    id?: true
    gameId?: true
    userId?: true
    resumeTokenHash?: true
    lastAckSequence?: true
    lastHeartbeatAt?: true
    issuedAt?: true
    expiresAt?: true
    createdAt?: true
  }

  export type GameSessionMaxAggregateInputType = {
    id?: true
    gameId?: true
    userId?: true
    resumeTokenHash?: true
    lastAckSequence?: true
    lastHeartbeatAt?: true
    issuedAt?: true
    expiresAt?: true
    createdAt?: true
  }

  export type GameSessionCountAggregateInputType = {
    id?: true
    gameId?: true
    userId?: true
    resumeTokenHash?: true
    lastAckSequence?: true
    lastHeartbeatAt?: true
    issuedAt?: true
    expiresAt?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type GameSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameSession to aggregate.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameSessions
    **/
    _count?: true | GameSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameSessionMaxAggregateInputType
  }

  export type GetGameSessionAggregateType<T extends GameSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateGameSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameSession[P]>
      : GetScalarType<T[P], AggregateGameSession[P]>
  }




  export type GameSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameSessionWhereInput
    orderBy?: GameSessionOrderByWithAggregationInput | GameSessionOrderByWithAggregationInput[]
    by: GameSessionScalarFieldEnum[] | GameSessionScalarFieldEnum
    having?: GameSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameSessionCountAggregateInputType | true
    _avg?: GameSessionAvgAggregateInputType
    _sum?: GameSessionSumAggregateInputType
    _min?: GameSessionMinAggregateInputType
    _max?: GameSessionMaxAggregateInputType
  }

  export type GameSessionGroupByOutputType = {
    id: string
    gameId: string
    userId: string
    resumeTokenHash: string
    lastAckSequence: number
    lastHeartbeatAt: Date | null
    issuedAt: Date
    expiresAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    _count: GameSessionCountAggregateOutputType | null
    _avg: GameSessionAvgAggregateOutputType | null
    _sum: GameSessionSumAggregateOutputType | null
    _min: GameSessionMinAggregateOutputType | null
    _max: GameSessionMaxAggregateOutputType | null
  }

  type GetGameSessionGroupByPayload<T extends GameSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameSessionGroupByOutputType[P]>
            : GetScalarType<T[P], GameSessionGroupByOutputType[P]>
        }
      >
    >


  export type GameSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    userId?: boolean
    resumeTokenHash?: boolean
    lastAckSequence?: boolean
    lastHeartbeatAt?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    game?: boolean | gamesDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameSession"]>

  export type GameSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    userId?: boolean
    resumeTokenHash?: boolean
    lastAckSequence?: boolean
    lastHeartbeatAt?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    game?: boolean | gamesDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameSession"]>

  export type GameSessionSelectScalar = {
    id?: boolean
    gameId?: boolean
    userId?: boolean
    resumeTokenHash?: boolean
    lastAckSequence?: boolean
    lastHeartbeatAt?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type GameSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | gamesDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type GameSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | gamesDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $GameSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameSession"
    objects: {
      game: Prisma.$gamesPayload<ExtArgs>
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      userId: string
      resumeTokenHash: string
      lastAckSequence: number
      lastHeartbeatAt: Date | null
      issuedAt: Date
      expiresAt: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["gameSession"]>
    composites: {}
  }

  type GameSessionGetPayload<S extends boolean | null | undefined | GameSessionDefaultArgs> = $Result.GetResult<Prisma.$GameSessionPayload, S>

  type GameSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GameSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GameSessionCountAggregateInputType | true
    }

  export interface GameSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameSession'], meta: { name: 'GameSession' } }
    /**
     * Find zero or one GameSession that matches the filter.
     * @param {GameSessionFindUniqueArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameSessionFindUniqueArgs>(args: SelectSubset<T, GameSessionFindUniqueArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GameSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GameSessionFindUniqueOrThrowArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, GameSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GameSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionFindFirstArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameSessionFindFirstArgs>(args?: SelectSubset<T, GameSessionFindFirstArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GameSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionFindFirstOrThrowArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, GameSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GameSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameSessions
     * const gameSessions = await prisma.gameSession.findMany()
     * 
     * // Get first 10 GameSessions
     * const gameSessions = await prisma.gameSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameSessionWithIdOnly = await prisma.gameSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameSessionFindManyArgs>(args?: SelectSubset<T, GameSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GameSession.
     * @param {GameSessionCreateArgs} args - Arguments to create a GameSession.
     * @example
     * // Create one GameSession
     * const GameSession = await prisma.gameSession.create({
     *   data: {
     *     // ... data to create a GameSession
     *   }
     * })
     * 
     */
    create<T extends GameSessionCreateArgs>(args: SelectSubset<T, GameSessionCreateArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GameSessions.
     * @param {GameSessionCreateManyArgs} args - Arguments to create many GameSessions.
     * @example
     * // Create many GameSessions
     * const gameSession = await prisma.gameSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameSessionCreateManyArgs>(args?: SelectSubset<T, GameSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameSessions and returns the data saved in the database.
     * @param {GameSessionCreateManyAndReturnArgs} args - Arguments to create many GameSessions.
     * @example
     * // Create many GameSessions
     * const gameSession = await prisma.gameSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameSessions and only return the `id`
     * const gameSessionWithIdOnly = await prisma.gameSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, GameSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GameSession.
     * @param {GameSessionDeleteArgs} args - Arguments to delete one GameSession.
     * @example
     * // Delete one GameSession
     * const GameSession = await prisma.gameSession.delete({
     *   where: {
     *     // ... filter to delete one GameSession
     *   }
     * })
     * 
     */
    delete<T extends GameSessionDeleteArgs>(args: SelectSubset<T, GameSessionDeleteArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GameSession.
     * @param {GameSessionUpdateArgs} args - Arguments to update one GameSession.
     * @example
     * // Update one GameSession
     * const gameSession = await prisma.gameSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameSessionUpdateArgs>(args: SelectSubset<T, GameSessionUpdateArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GameSessions.
     * @param {GameSessionDeleteManyArgs} args - Arguments to filter GameSessions to delete.
     * @example
     * // Delete a few GameSessions
     * const { count } = await prisma.gameSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameSessionDeleteManyArgs>(args?: SelectSubset<T, GameSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameSessions
     * const gameSession = await prisma.gameSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameSessionUpdateManyArgs>(args: SelectSubset<T, GameSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GameSession.
     * @param {GameSessionUpsertArgs} args - Arguments to update or create a GameSession.
     * @example
     * // Update or create a GameSession
     * const gameSession = await prisma.gameSession.upsert({
     *   create: {
     *     // ... data to create a GameSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameSession we want to update
     *   }
     * })
     */
    upsert<T extends GameSessionUpsertArgs>(args: SelectSubset<T, GameSessionUpsertArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GameSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionCountArgs} args - Arguments to filter GameSessions to count.
     * @example
     * // Count the number of GameSessions
     * const count = await prisma.gameSession.count({
     *   where: {
     *     // ... the filter for the GameSessions we want to count
     *   }
     * })
    **/
    count<T extends GameSessionCountArgs>(
      args?: Subset<T, GameSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameSessionAggregateArgs>(args: Subset<T, GameSessionAggregateArgs>): Prisma.PrismaPromise<GetGameSessionAggregateType<T>>

    /**
     * Group by GameSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameSessionGroupByArgs['orderBy'] }
        : { orderBy?: GameSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameSession model
   */
  readonly fields: GameSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends gamesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, gamesDefaultArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameSession model
   */ 
  interface GameSessionFieldRefs {
    readonly id: FieldRef<"GameSession", 'String'>
    readonly gameId: FieldRef<"GameSession", 'String'>
    readonly userId: FieldRef<"GameSession", 'String'>
    readonly resumeTokenHash: FieldRef<"GameSession", 'String'>
    readonly lastAckSequence: FieldRef<"GameSession", 'Int'>
    readonly lastHeartbeatAt: FieldRef<"GameSession", 'DateTime'>
    readonly issuedAt: FieldRef<"GameSession", 'DateTime'>
    readonly expiresAt: FieldRef<"GameSession", 'DateTime'>
    readonly metadata: FieldRef<"GameSession", 'Json'>
    readonly createdAt: FieldRef<"GameSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameSession findUnique
   */
  export type GameSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession findUniqueOrThrow
   */
  export type GameSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession findFirst
   */
  export type GameSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameSessions.
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameSessions.
     */
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * GameSession findFirstOrThrow
   */
  export type GameSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameSessions.
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameSessions.
     */
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * GameSession findMany
   */
  export type GameSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSessions to fetch.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameSessions.
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * GameSession create
   */
  export type GameSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a GameSession.
     */
    data: XOR<GameSessionCreateInput, GameSessionUncheckedCreateInput>
  }

  /**
   * GameSession createMany
   */
  export type GameSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameSessions.
     */
    data: GameSessionCreateManyInput | GameSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameSession createManyAndReturn
   */
  export type GameSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GameSessions.
     */
    data: GameSessionCreateManyInput | GameSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameSession update
   */
  export type GameSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a GameSession.
     */
    data: XOR<GameSessionUpdateInput, GameSessionUncheckedUpdateInput>
    /**
     * Choose, which GameSession to update.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession updateMany
   */
  export type GameSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameSessions.
     */
    data: XOR<GameSessionUpdateManyMutationInput, GameSessionUncheckedUpdateManyInput>
    /**
     * Filter which GameSessions to update
     */
    where?: GameSessionWhereInput
  }

  /**
   * GameSession upsert
   */
  export type GameSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the GameSession to update in case it exists.
     */
    where: GameSessionWhereUniqueInput
    /**
     * In case the GameSession found by the `where` argument doesn't exist, create a new GameSession with this data.
     */
    create: XOR<GameSessionCreateInput, GameSessionUncheckedCreateInput>
    /**
     * In case the GameSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameSessionUpdateInput, GameSessionUncheckedUpdateInput>
  }

  /**
   * GameSession delete
   */
  export type GameSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter which GameSession to delete.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession deleteMany
   */
  export type GameSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameSessions to delete
     */
    where?: GameSessionWhereInput
  }

  /**
   * GameSession without action
   */
  export type GameSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
  }


  /**
   * Model GameEvent
   */

  export type AggregateGameEvent = {
    _count: GameEventCountAggregateOutputType | null
    _avg: GameEventAvgAggregateOutputType | null
    _sum: GameEventSumAggregateOutputType | null
    _min: GameEventMinAggregateOutputType | null
    _max: GameEventMaxAggregateOutputType | null
  }

  export type GameEventAvgAggregateOutputType = {
    sequence: number | null
  }

  export type GameEventSumAggregateOutputType = {
    sequence: number | null
  }

  export type GameEventMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    sequence: number | null
    type: string | null
    createdAt: Date | null
  }

  export type GameEventMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    sequence: number | null
    type: string | null
    createdAt: Date | null
  }

  export type GameEventCountAggregateOutputType = {
    id: number
    gameId: number
    sequence: number
    type: number
    payload: number
    createdAt: number
    _all: number
  }


  export type GameEventAvgAggregateInputType = {
    sequence?: true
  }

  export type GameEventSumAggregateInputType = {
    sequence?: true
  }

  export type GameEventMinAggregateInputType = {
    id?: true
    gameId?: true
    sequence?: true
    type?: true
    createdAt?: true
  }

  export type GameEventMaxAggregateInputType = {
    id?: true
    gameId?: true
    sequence?: true
    type?: true
    createdAt?: true
  }

  export type GameEventCountAggregateInputType = {
    id?: true
    gameId?: true
    sequence?: true
    type?: true
    payload?: true
    createdAt?: true
    _all?: true
  }

  export type GameEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameEvent to aggregate.
     */
    where?: GameEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameEvents to fetch.
     */
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameEvents
    **/
    _count?: true | GameEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameEventMaxAggregateInputType
  }

  export type GetGameEventAggregateType<T extends GameEventAggregateArgs> = {
        [P in keyof T & keyof AggregateGameEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameEvent[P]>
      : GetScalarType<T[P], AggregateGameEvent[P]>
  }




  export type GameEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameEventWhereInput
    orderBy?: GameEventOrderByWithAggregationInput | GameEventOrderByWithAggregationInput[]
    by: GameEventScalarFieldEnum[] | GameEventScalarFieldEnum
    having?: GameEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameEventCountAggregateInputType | true
    _avg?: GameEventAvgAggregateInputType
    _sum?: GameEventSumAggregateInputType
    _min?: GameEventMinAggregateInputType
    _max?: GameEventMaxAggregateInputType
  }

  export type GameEventGroupByOutputType = {
    id: string
    gameId: string
    sequence: number
    type: string
    payload: JsonValue
    createdAt: Date
    _count: GameEventCountAggregateOutputType | null
    _avg: GameEventAvgAggregateOutputType | null
    _sum: GameEventSumAggregateOutputType | null
    _min: GameEventMinAggregateOutputType | null
    _max: GameEventMaxAggregateOutputType | null
  }

  type GetGameEventGroupByPayload<T extends GameEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameEventGroupByOutputType[P]>
            : GetScalarType<T[P], GameEventGroupByOutputType[P]>
        }
      >
    >


  export type GameEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    sequence?: boolean
    type?: boolean
    payload?: boolean
    createdAt?: boolean
    game?: boolean | gamesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameEvent"]>

  export type GameEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    sequence?: boolean
    type?: boolean
    payload?: boolean
    createdAt?: boolean
    game?: boolean | gamesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameEvent"]>

  export type GameEventSelectScalar = {
    id?: boolean
    gameId?: boolean
    sequence?: boolean
    type?: boolean
    payload?: boolean
    createdAt?: boolean
  }

  export type GameEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | gamesDefaultArgs<ExtArgs>
  }
  export type GameEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | gamesDefaultArgs<ExtArgs>
  }

  export type $GameEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameEvent"
    objects: {
      game: Prisma.$gamesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      sequence: number
      type: string
      payload: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["gameEvent"]>
    composites: {}
  }

  type GameEventGetPayload<S extends boolean | null | undefined | GameEventDefaultArgs> = $Result.GetResult<Prisma.$GameEventPayload, S>

  type GameEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GameEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GameEventCountAggregateInputType | true
    }

  export interface GameEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameEvent'], meta: { name: 'GameEvent' } }
    /**
     * Find zero or one GameEvent that matches the filter.
     * @param {GameEventFindUniqueArgs} args - Arguments to find a GameEvent
     * @example
     * // Get one GameEvent
     * const gameEvent = await prisma.gameEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameEventFindUniqueArgs>(args: SelectSubset<T, GameEventFindUniqueArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GameEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GameEventFindUniqueOrThrowArgs} args - Arguments to find a GameEvent
     * @example
     * // Get one GameEvent
     * const gameEvent = await prisma.gameEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameEventFindUniqueOrThrowArgs>(args: SelectSubset<T, GameEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GameEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventFindFirstArgs} args - Arguments to find a GameEvent
     * @example
     * // Get one GameEvent
     * const gameEvent = await prisma.gameEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameEventFindFirstArgs>(args?: SelectSubset<T, GameEventFindFirstArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GameEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventFindFirstOrThrowArgs} args - Arguments to find a GameEvent
     * @example
     * // Get one GameEvent
     * const gameEvent = await prisma.gameEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameEventFindFirstOrThrowArgs>(args?: SelectSubset<T, GameEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GameEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameEvents
     * const gameEvents = await prisma.gameEvent.findMany()
     * 
     * // Get first 10 GameEvents
     * const gameEvents = await prisma.gameEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameEventWithIdOnly = await prisma.gameEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameEventFindManyArgs>(args?: SelectSubset<T, GameEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GameEvent.
     * @param {GameEventCreateArgs} args - Arguments to create a GameEvent.
     * @example
     * // Create one GameEvent
     * const GameEvent = await prisma.gameEvent.create({
     *   data: {
     *     // ... data to create a GameEvent
     *   }
     * })
     * 
     */
    create<T extends GameEventCreateArgs>(args: SelectSubset<T, GameEventCreateArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GameEvents.
     * @param {GameEventCreateManyArgs} args - Arguments to create many GameEvents.
     * @example
     * // Create many GameEvents
     * const gameEvent = await prisma.gameEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameEventCreateManyArgs>(args?: SelectSubset<T, GameEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameEvents and returns the data saved in the database.
     * @param {GameEventCreateManyAndReturnArgs} args - Arguments to create many GameEvents.
     * @example
     * // Create many GameEvents
     * const gameEvent = await prisma.gameEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameEvents and only return the `id`
     * const gameEventWithIdOnly = await prisma.gameEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameEventCreateManyAndReturnArgs>(args?: SelectSubset<T, GameEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GameEvent.
     * @param {GameEventDeleteArgs} args - Arguments to delete one GameEvent.
     * @example
     * // Delete one GameEvent
     * const GameEvent = await prisma.gameEvent.delete({
     *   where: {
     *     // ... filter to delete one GameEvent
     *   }
     * })
     * 
     */
    delete<T extends GameEventDeleteArgs>(args: SelectSubset<T, GameEventDeleteArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GameEvent.
     * @param {GameEventUpdateArgs} args - Arguments to update one GameEvent.
     * @example
     * // Update one GameEvent
     * const gameEvent = await prisma.gameEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameEventUpdateArgs>(args: SelectSubset<T, GameEventUpdateArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GameEvents.
     * @param {GameEventDeleteManyArgs} args - Arguments to filter GameEvents to delete.
     * @example
     * // Delete a few GameEvents
     * const { count } = await prisma.gameEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameEventDeleteManyArgs>(args?: SelectSubset<T, GameEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameEvents
     * const gameEvent = await prisma.gameEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameEventUpdateManyArgs>(args: SelectSubset<T, GameEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GameEvent.
     * @param {GameEventUpsertArgs} args - Arguments to update or create a GameEvent.
     * @example
     * // Update or create a GameEvent
     * const gameEvent = await prisma.gameEvent.upsert({
     *   create: {
     *     // ... data to create a GameEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameEvent we want to update
     *   }
     * })
     */
    upsert<T extends GameEventUpsertArgs>(args: SelectSubset<T, GameEventUpsertArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GameEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventCountArgs} args - Arguments to filter GameEvents to count.
     * @example
     * // Count the number of GameEvents
     * const count = await prisma.gameEvent.count({
     *   where: {
     *     // ... the filter for the GameEvents we want to count
     *   }
     * })
    **/
    count<T extends GameEventCountArgs>(
      args?: Subset<T, GameEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameEventAggregateArgs>(args: Subset<T, GameEventAggregateArgs>): Prisma.PrismaPromise<GetGameEventAggregateType<T>>

    /**
     * Group by GameEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameEventGroupByArgs['orderBy'] }
        : { orderBy?: GameEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameEvent model
   */
  readonly fields: GameEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends gamesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, gamesDefaultArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameEvent model
   */ 
  interface GameEventFieldRefs {
    readonly id: FieldRef<"GameEvent", 'String'>
    readonly gameId: FieldRef<"GameEvent", 'String'>
    readonly sequence: FieldRef<"GameEvent", 'Int'>
    readonly type: FieldRef<"GameEvent", 'String'>
    readonly payload: FieldRef<"GameEvent", 'Json'>
    readonly createdAt: FieldRef<"GameEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameEvent findUnique
   */
  export type GameEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * Filter, which GameEvent to fetch.
     */
    where: GameEventWhereUniqueInput
  }

  /**
   * GameEvent findUniqueOrThrow
   */
  export type GameEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * Filter, which GameEvent to fetch.
     */
    where: GameEventWhereUniqueInput
  }

  /**
   * GameEvent findFirst
   */
  export type GameEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * Filter, which GameEvent to fetch.
     */
    where?: GameEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameEvents to fetch.
     */
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameEvents.
     */
    cursor?: GameEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameEvents.
     */
    distinct?: GameEventScalarFieldEnum | GameEventScalarFieldEnum[]
  }

  /**
   * GameEvent findFirstOrThrow
   */
  export type GameEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * Filter, which GameEvent to fetch.
     */
    where?: GameEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameEvents to fetch.
     */
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameEvents.
     */
    cursor?: GameEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameEvents.
     */
    distinct?: GameEventScalarFieldEnum | GameEventScalarFieldEnum[]
  }

  /**
   * GameEvent findMany
   */
  export type GameEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * Filter, which GameEvents to fetch.
     */
    where?: GameEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameEvents to fetch.
     */
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameEvents.
     */
    cursor?: GameEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameEvents.
     */
    skip?: number
    distinct?: GameEventScalarFieldEnum | GameEventScalarFieldEnum[]
  }

  /**
   * GameEvent create
   */
  export type GameEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * The data needed to create a GameEvent.
     */
    data: XOR<GameEventCreateInput, GameEventUncheckedCreateInput>
  }

  /**
   * GameEvent createMany
   */
  export type GameEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameEvents.
     */
    data: GameEventCreateManyInput | GameEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameEvent createManyAndReturn
   */
  export type GameEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GameEvents.
     */
    data: GameEventCreateManyInput | GameEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameEvent update
   */
  export type GameEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * The data needed to update a GameEvent.
     */
    data: XOR<GameEventUpdateInput, GameEventUncheckedUpdateInput>
    /**
     * Choose, which GameEvent to update.
     */
    where: GameEventWhereUniqueInput
  }

  /**
   * GameEvent updateMany
   */
  export type GameEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameEvents.
     */
    data: XOR<GameEventUpdateManyMutationInput, GameEventUncheckedUpdateManyInput>
    /**
     * Filter which GameEvents to update
     */
    where?: GameEventWhereInput
  }

  /**
   * GameEvent upsert
   */
  export type GameEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * The filter to search for the GameEvent to update in case it exists.
     */
    where: GameEventWhereUniqueInput
    /**
     * In case the GameEvent found by the `where` argument doesn't exist, create a new GameEvent with this data.
     */
    create: XOR<GameEventCreateInput, GameEventUncheckedCreateInput>
    /**
     * In case the GameEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameEventUpdateInput, GameEventUncheckedUpdateInput>
  }

  /**
   * GameEvent delete
   */
  export type GameEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * Filter which GameEvent to delete.
     */
    where: GameEventWhereUniqueInput
  }

  /**
   * GameEvent deleteMany
   */
  export type GameEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameEvents to delete
     */
    where?: GameEventWhereInput
  }

  /**
   * GameEvent without action
   */
  export type GameEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
  }


  /**
   * Model matches
   */

  export type AggregateMatches = {
    _count: MatchesCountAggregateOutputType | null
    _avg: MatchesAvgAggregateOutputType | null
    _sum: MatchesSumAggregateOutputType | null
    _min: MatchesMinAggregateOutputType | null
    _max: MatchesMaxAggregateOutputType | null
  }

  export type MatchesAvgAggregateOutputType = {
    length: number | null
  }

  export type MatchesSumAggregateOutputType = {
    length: number | null
  }

  export type MatchesMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    length: number | null
    state: $Enums.MatchState | null
    crawfordUsed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchesMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    length: number | null
    state: $Enums.MatchState | null
    crawfordUsed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchesCountAggregateOutputType = {
    id: number
    gameId: number
    length: number
    rules: number
    state: number
    crawfordUsed: number
    cubeHistory: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatchesAvgAggregateInputType = {
    length?: true
  }

  export type MatchesSumAggregateInputType = {
    length?: true
  }

  export type MatchesMinAggregateInputType = {
    id?: true
    gameId?: true
    length?: true
    state?: true
    crawfordUsed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchesMaxAggregateInputType = {
    id?: true
    gameId?: true
    length?: true
    state?: true
    crawfordUsed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchesCountAggregateInputType = {
    id?: true
    gameId?: true
    length?: true
    rules?: true
    state?: true
    crawfordUsed?: true
    cubeHistory?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatchesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which matches to aggregate.
     */
    where?: matchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of matches to fetch.
     */
    orderBy?: matchesOrderByWithRelationInput | matchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: matchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned matches
    **/
    _count?: true | MatchesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchesMaxAggregateInputType
  }

  export type GetMatchesAggregateType<T extends MatchesAggregateArgs> = {
        [P in keyof T & keyof AggregateMatches]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatches[P]>
      : GetScalarType<T[P], AggregateMatches[P]>
  }




  export type matchesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: matchesWhereInput
    orderBy?: matchesOrderByWithAggregationInput | matchesOrderByWithAggregationInput[]
    by: MatchesScalarFieldEnum[] | MatchesScalarFieldEnum
    having?: matchesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchesCountAggregateInputType | true
    _avg?: MatchesAvgAggregateInputType
    _sum?: MatchesSumAggregateInputType
    _min?: MatchesMinAggregateInputType
    _max?: MatchesMaxAggregateInputType
  }

  export type MatchesGroupByOutputType = {
    id: string
    gameId: string
    length: number
    rules: JsonValue
    state: $Enums.MatchState
    crawfordUsed: boolean
    cubeHistory: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: MatchesCountAggregateOutputType | null
    _avg: MatchesAvgAggregateOutputType | null
    _sum: MatchesSumAggregateOutputType | null
    _min: MatchesMinAggregateOutputType | null
    _max: MatchesMaxAggregateOutputType | null
  }

  type GetMatchesGroupByPayload<T extends matchesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchesGroupByOutputType[P]>
            : GetScalarType<T[P], MatchesGroupByOutputType[P]>
        }
      >
    >


  export type matchesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    length?: boolean
    rules?: boolean
    state?: boolean
    crawfordUsed?: boolean
    cubeHistory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    game?: boolean | gamesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matches"]>

  export type matchesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    length?: boolean
    rules?: boolean
    state?: boolean
    crawfordUsed?: boolean
    cubeHistory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    game?: boolean | gamesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matches"]>

  export type matchesSelectScalar = {
    id?: boolean
    gameId?: boolean
    length?: boolean
    rules?: boolean
    state?: boolean
    crawfordUsed?: boolean
    cubeHistory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type matchesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | gamesDefaultArgs<ExtArgs>
  }
  export type matchesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | gamesDefaultArgs<ExtArgs>
  }

  export type $matchesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "matches"
    objects: {
      game: Prisma.$gamesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      length: number
      rules: Prisma.JsonValue
      state: $Enums.MatchState
      crawfordUsed: boolean
      cubeHistory: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["matches"]>
    composites: {}
  }

  type matchesGetPayload<S extends boolean | null | undefined | matchesDefaultArgs> = $Result.GetResult<Prisma.$matchesPayload, S>

  type matchesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<matchesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MatchesCountAggregateInputType | true
    }

  export interface matchesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['matches'], meta: { name: 'matches' } }
    /**
     * Find zero or one Matches that matches the filter.
     * @param {matchesFindUniqueArgs} args - Arguments to find a Matches
     * @example
     * // Get one Matches
     * const matches = await prisma.matches.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends matchesFindUniqueArgs>(args: SelectSubset<T, matchesFindUniqueArgs<ExtArgs>>): Prisma__matchesClient<$Result.GetResult<Prisma.$matchesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Matches that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {matchesFindUniqueOrThrowArgs} args - Arguments to find a Matches
     * @example
     * // Get one Matches
     * const matches = await prisma.matches.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends matchesFindUniqueOrThrowArgs>(args: SelectSubset<T, matchesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__matchesClient<$Result.GetResult<Prisma.$matchesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matchesFindFirstArgs} args - Arguments to find a Matches
     * @example
     * // Get one Matches
     * const matches = await prisma.matches.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends matchesFindFirstArgs>(args?: SelectSubset<T, matchesFindFirstArgs<ExtArgs>>): Prisma__matchesClient<$Result.GetResult<Prisma.$matchesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Matches that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matchesFindFirstOrThrowArgs} args - Arguments to find a Matches
     * @example
     * // Get one Matches
     * const matches = await prisma.matches.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends matchesFindFirstOrThrowArgs>(args?: SelectSubset<T, matchesFindFirstOrThrowArgs<ExtArgs>>): Prisma__matchesClient<$Result.GetResult<Prisma.$matchesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matchesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matches
     * const matches = await prisma.matches.findMany()
     * 
     * // Get first 10 Matches
     * const matches = await prisma.matches.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchesWithIdOnly = await prisma.matches.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends matchesFindManyArgs>(args?: SelectSubset<T, matchesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$matchesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Matches.
     * @param {matchesCreateArgs} args - Arguments to create a Matches.
     * @example
     * // Create one Matches
     * const Matches = await prisma.matches.create({
     *   data: {
     *     // ... data to create a Matches
     *   }
     * })
     * 
     */
    create<T extends matchesCreateArgs>(args: SelectSubset<T, matchesCreateArgs<ExtArgs>>): Prisma__matchesClient<$Result.GetResult<Prisma.$matchesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Matches.
     * @param {matchesCreateManyArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const matches = await prisma.matches.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends matchesCreateManyArgs>(args?: SelectSubset<T, matchesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Matches and returns the data saved in the database.
     * @param {matchesCreateManyAndReturnArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const matches = await prisma.matches.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Matches and only return the `id`
     * const matchesWithIdOnly = await prisma.matches.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends matchesCreateManyAndReturnArgs>(args?: SelectSubset<T, matchesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$matchesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Matches.
     * @param {matchesDeleteArgs} args - Arguments to delete one Matches.
     * @example
     * // Delete one Matches
     * const Matches = await prisma.matches.delete({
     *   where: {
     *     // ... filter to delete one Matches
     *   }
     * })
     * 
     */
    delete<T extends matchesDeleteArgs>(args: SelectSubset<T, matchesDeleteArgs<ExtArgs>>): Prisma__matchesClient<$Result.GetResult<Prisma.$matchesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Matches.
     * @param {matchesUpdateArgs} args - Arguments to update one Matches.
     * @example
     * // Update one Matches
     * const matches = await prisma.matches.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends matchesUpdateArgs>(args: SelectSubset<T, matchesUpdateArgs<ExtArgs>>): Prisma__matchesClient<$Result.GetResult<Prisma.$matchesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Matches.
     * @param {matchesDeleteManyArgs} args - Arguments to filter Matches to delete.
     * @example
     * // Delete a few Matches
     * const { count } = await prisma.matches.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends matchesDeleteManyArgs>(args?: SelectSubset<T, matchesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matchesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matches
     * const matches = await prisma.matches.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends matchesUpdateManyArgs>(args: SelectSubset<T, matchesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Matches.
     * @param {matchesUpsertArgs} args - Arguments to update or create a Matches.
     * @example
     * // Update or create a Matches
     * const matches = await prisma.matches.upsert({
     *   create: {
     *     // ... data to create a Matches
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Matches we want to update
     *   }
     * })
     */
    upsert<T extends matchesUpsertArgs>(args: SelectSubset<T, matchesUpsertArgs<ExtArgs>>): Prisma__matchesClient<$Result.GetResult<Prisma.$matchesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matchesCountArgs} args - Arguments to filter Matches to count.
     * @example
     * // Count the number of Matches
     * const count = await prisma.matches.count({
     *   where: {
     *     // ... the filter for the Matches we want to count
     *   }
     * })
    **/
    count<T extends matchesCountArgs>(
      args?: Subset<T, matchesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchesAggregateArgs>(args: Subset<T, MatchesAggregateArgs>): Prisma.PrismaPromise<GetMatchesAggregateType<T>>

    /**
     * Group by Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matchesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends matchesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: matchesGroupByArgs['orderBy'] }
        : { orderBy?: matchesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, matchesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the matches model
   */
  readonly fields: matchesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for matches.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__matchesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends gamesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, gamesDefaultArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the matches model
   */ 
  interface matchesFieldRefs {
    readonly id: FieldRef<"matches", 'String'>
    readonly gameId: FieldRef<"matches", 'String'>
    readonly length: FieldRef<"matches", 'Int'>
    readonly rules: FieldRef<"matches", 'Json'>
    readonly state: FieldRef<"matches", 'MatchState'>
    readonly crawfordUsed: FieldRef<"matches", 'Boolean'>
    readonly cubeHistory: FieldRef<"matches", 'Json'>
    readonly createdAt: FieldRef<"matches", 'DateTime'>
    readonly updatedAt: FieldRef<"matches", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * matches findUnique
   */
  export type matchesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matches
     */
    select?: matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matchesInclude<ExtArgs> | null
    /**
     * Filter, which matches to fetch.
     */
    where: matchesWhereUniqueInput
  }

  /**
   * matches findUniqueOrThrow
   */
  export type matchesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matches
     */
    select?: matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matchesInclude<ExtArgs> | null
    /**
     * Filter, which matches to fetch.
     */
    where: matchesWhereUniqueInput
  }

  /**
   * matches findFirst
   */
  export type matchesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matches
     */
    select?: matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matchesInclude<ExtArgs> | null
    /**
     * Filter, which matches to fetch.
     */
    where?: matchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of matches to fetch.
     */
    orderBy?: matchesOrderByWithRelationInput | matchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for matches.
     */
    cursor?: matchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of matches.
     */
    distinct?: MatchesScalarFieldEnum | MatchesScalarFieldEnum[]
  }

  /**
   * matches findFirstOrThrow
   */
  export type matchesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matches
     */
    select?: matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matchesInclude<ExtArgs> | null
    /**
     * Filter, which matches to fetch.
     */
    where?: matchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of matches to fetch.
     */
    orderBy?: matchesOrderByWithRelationInput | matchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for matches.
     */
    cursor?: matchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of matches.
     */
    distinct?: MatchesScalarFieldEnum | MatchesScalarFieldEnum[]
  }

  /**
   * matches findMany
   */
  export type matchesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matches
     */
    select?: matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matchesInclude<ExtArgs> | null
    /**
     * Filter, which matches to fetch.
     */
    where?: matchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of matches to fetch.
     */
    orderBy?: matchesOrderByWithRelationInput | matchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing matches.
     */
    cursor?: matchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` matches.
     */
    skip?: number
    distinct?: MatchesScalarFieldEnum | MatchesScalarFieldEnum[]
  }

  /**
   * matches create
   */
  export type matchesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matches
     */
    select?: matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matchesInclude<ExtArgs> | null
    /**
     * The data needed to create a matches.
     */
    data: XOR<matchesCreateInput, matchesUncheckedCreateInput>
  }

  /**
   * matches createMany
   */
  export type matchesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many matches.
     */
    data: matchesCreateManyInput | matchesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * matches createManyAndReturn
   */
  export type matchesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matches
     */
    select?: matchesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many matches.
     */
    data: matchesCreateManyInput | matchesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matchesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * matches update
   */
  export type matchesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matches
     */
    select?: matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matchesInclude<ExtArgs> | null
    /**
     * The data needed to update a matches.
     */
    data: XOR<matchesUpdateInput, matchesUncheckedUpdateInput>
    /**
     * Choose, which matches to update.
     */
    where: matchesWhereUniqueInput
  }

  /**
   * matches updateMany
   */
  export type matchesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update matches.
     */
    data: XOR<matchesUpdateManyMutationInput, matchesUncheckedUpdateManyInput>
    /**
     * Filter which matches to update
     */
    where?: matchesWhereInput
  }

  /**
   * matches upsert
   */
  export type matchesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matches
     */
    select?: matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matchesInclude<ExtArgs> | null
    /**
     * The filter to search for the matches to update in case it exists.
     */
    where: matchesWhereUniqueInput
    /**
     * In case the matches found by the `where` argument doesn't exist, create a new matches with this data.
     */
    create: XOR<matchesCreateInput, matchesUncheckedCreateInput>
    /**
     * In case the matches was found with the provided `where` argument, update it with this data.
     */
    update: XOR<matchesUpdateInput, matchesUncheckedUpdateInput>
  }

  /**
   * matches delete
   */
  export type matchesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matches
     */
    select?: matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matchesInclude<ExtArgs> | null
    /**
     * Filter which matches to delete.
     */
    where: matchesWhereUniqueInput
  }

  /**
   * matches deleteMany
   */
  export type matchesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which matches to delete
     */
    where?: matchesWhereInput
  }

  /**
   * matches without action
   */
  export type matchesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matches
     */
    select?: matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matchesInclude<ExtArgs> | null
  }


  /**
   * Model user_learning_progress
   */

  export type AggregateUser_learning_progress = {
    _count: User_learning_progressCountAggregateOutputType | null
    _avg: User_learning_progressAvgAggregateOutputType | null
    _sum: User_learning_progressSumAggregateOutputType | null
    _min: User_learning_progressMinAggregateOutputType | null
    _max: User_learning_progressMaxAggregateOutputType | null
  }

  export type User_learning_progressAvgAggregateOutputType = {
    score: number | null
  }

  export type User_learning_progressSumAggregateOutputType = {
    score: number | null
  }

  export type User_learning_progressMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    rule_key: string | null
    viewed_at: Date | null
    completed: boolean | null
    completed_at: Date | null
    score: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type User_learning_progressMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    rule_key: string | null
    viewed_at: Date | null
    completed: boolean | null
    completed_at: Date | null
    score: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type User_learning_progressCountAggregateOutputType = {
    id: number
    user_id: number
    rule_key: number
    viewed_at: number
    completed: number
    completed_at: number
    score: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type User_learning_progressAvgAggregateInputType = {
    score?: true
  }

  export type User_learning_progressSumAggregateInputType = {
    score?: true
  }

  export type User_learning_progressMinAggregateInputType = {
    id?: true
    user_id?: true
    rule_key?: true
    viewed_at?: true
    completed?: true
    completed_at?: true
    score?: true
    created_at?: true
    updated_at?: true
  }

  export type User_learning_progressMaxAggregateInputType = {
    id?: true
    user_id?: true
    rule_key?: true
    viewed_at?: true
    completed?: true
    completed_at?: true
    score?: true
    created_at?: true
    updated_at?: true
  }

  export type User_learning_progressCountAggregateInputType = {
    id?: true
    user_id?: true
    rule_key?: true
    viewed_at?: true
    completed?: true
    completed_at?: true
    score?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type User_learning_progressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_learning_progress to aggregate.
     */
    where?: user_learning_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_learning_progresses to fetch.
     */
    orderBy?: user_learning_progressOrderByWithRelationInput | user_learning_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_learning_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_learning_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_learning_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_learning_progresses
    **/
    _count?: true | User_learning_progressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_learning_progressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_learning_progressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_learning_progressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_learning_progressMaxAggregateInputType
  }

  export type GetUser_learning_progressAggregateType<T extends User_learning_progressAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_learning_progress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_learning_progress[P]>
      : GetScalarType<T[P], AggregateUser_learning_progress[P]>
  }




  export type user_learning_progressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_learning_progressWhereInput
    orderBy?: user_learning_progressOrderByWithAggregationInput | user_learning_progressOrderByWithAggregationInput[]
    by: User_learning_progressScalarFieldEnum[] | User_learning_progressScalarFieldEnum
    having?: user_learning_progressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_learning_progressCountAggregateInputType | true
    _avg?: User_learning_progressAvgAggregateInputType
    _sum?: User_learning_progressSumAggregateInputType
    _min?: User_learning_progressMinAggregateInputType
    _max?: User_learning_progressMaxAggregateInputType
  }

  export type User_learning_progressGroupByOutputType = {
    id: string
    user_id: string
    rule_key: string
    viewed_at: Date
    completed: boolean
    completed_at: Date | null
    score: number | null
    created_at: Date
    updated_at: Date
    _count: User_learning_progressCountAggregateOutputType | null
    _avg: User_learning_progressAvgAggregateOutputType | null
    _sum: User_learning_progressSumAggregateOutputType | null
    _min: User_learning_progressMinAggregateOutputType | null
    _max: User_learning_progressMaxAggregateOutputType | null
  }

  type GetUser_learning_progressGroupByPayload<T extends user_learning_progressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_learning_progressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_learning_progressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_learning_progressGroupByOutputType[P]>
            : GetScalarType<T[P], User_learning_progressGroupByOutputType[P]>
        }
      >
    >


  export type user_learning_progressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    rule_key?: boolean
    viewed_at?: boolean
    completed?: boolean
    completed_at?: boolean
    score?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user_learning_progress"]>

  export type user_learning_progressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    rule_key?: boolean
    viewed_at?: boolean
    completed?: boolean
    completed_at?: boolean
    score?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user_learning_progress"]>

  export type user_learning_progressSelectScalar = {
    id?: boolean
    user_id?: boolean
    rule_key?: boolean
    viewed_at?: boolean
    completed?: boolean
    completed_at?: boolean
    score?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $user_learning_progressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_learning_progress"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      rule_key: string
      viewed_at: Date
      completed: boolean
      completed_at: Date | null
      score: number | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user_learning_progress"]>
    composites: {}
  }

  type user_learning_progressGetPayload<S extends boolean | null | undefined | user_learning_progressDefaultArgs> = $Result.GetResult<Prisma.$user_learning_progressPayload, S>

  type user_learning_progressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_learning_progressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_learning_progressCountAggregateInputType | true
    }

  export interface user_learning_progressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_learning_progress'], meta: { name: 'user_learning_progress' } }
    /**
     * Find zero or one User_learning_progress that matches the filter.
     * @param {user_learning_progressFindUniqueArgs} args - Arguments to find a User_learning_progress
     * @example
     * // Get one User_learning_progress
     * const user_learning_progress = await prisma.user_learning_progress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_learning_progressFindUniqueArgs>(args: SelectSubset<T, user_learning_progressFindUniqueArgs<ExtArgs>>): Prisma__user_learning_progressClient<$Result.GetResult<Prisma.$user_learning_progressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_learning_progress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_learning_progressFindUniqueOrThrowArgs} args - Arguments to find a User_learning_progress
     * @example
     * // Get one User_learning_progress
     * const user_learning_progress = await prisma.user_learning_progress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_learning_progressFindUniqueOrThrowArgs>(args: SelectSubset<T, user_learning_progressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_learning_progressClient<$Result.GetResult<Prisma.$user_learning_progressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_learning_progress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_learning_progressFindFirstArgs} args - Arguments to find a User_learning_progress
     * @example
     * // Get one User_learning_progress
     * const user_learning_progress = await prisma.user_learning_progress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_learning_progressFindFirstArgs>(args?: SelectSubset<T, user_learning_progressFindFirstArgs<ExtArgs>>): Prisma__user_learning_progressClient<$Result.GetResult<Prisma.$user_learning_progressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_learning_progress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_learning_progressFindFirstOrThrowArgs} args - Arguments to find a User_learning_progress
     * @example
     * // Get one User_learning_progress
     * const user_learning_progress = await prisma.user_learning_progress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_learning_progressFindFirstOrThrowArgs>(args?: SelectSubset<T, user_learning_progressFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_learning_progressClient<$Result.GetResult<Prisma.$user_learning_progressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_learning_progresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_learning_progressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_learning_progresses
     * const user_learning_progresses = await prisma.user_learning_progress.findMany()
     * 
     * // Get first 10 User_learning_progresses
     * const user_learning_progresses = await prisma.user_learning_progress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_learning_progressWithIdOnly = await prisma.user_learning_progress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_learning_progressFindManyArgs>(args?: SelectSubset<T, user_learning_progressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_learning_progressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_learning_progress.
     * @param {user_learning_progressCreateArgs} args - Arguments to create a User_learning_progress.
     * @example
     * // Create one User_learning_progress
     * const User_learning_progress = await prisma.user_learning_progress.create({
     *   data: {
     *     // ... data to create a User_learning_progress
     *   }
     * })
     * 
     */
    create<T extends user_learning_progressCreateArgs>(args: SelectSubset<T, user_learning_progressCreateArgs<ExtArgs>>): Prisma__user_learning_progressClient<$Result.GetResult<Prisma.$user_learning_progressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_learning_progresses.
     * @param {user_learning_progressCreateManyArgs} args - Arguments to create many User_learning_progresses.
     * @example
     * // Create many User_learning_progresses
     * const user_learning_progress = await prisma.user_learning_progress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_learning_progressCreateManyArgs>(args?: SelectSubset<T, user_learning_progressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_learning_progresses and returns the data saved in the database.
     * @param {user_learning_progressCreateManyAndReturnArgs} args - Arguments to create many User_learning_progresses.
     * @example
     * // Create many User_learning_progresses
     * const user_learning_progress = await prisma.user_learning_progress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_learning_progresses and only return the `id`
     * const user_learning_progressWithIdOnly = await prisma.user_learning_progress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_learning_progressCreateManyAndReturnArgs>(args?: SelectSubset<T, user_learning_progressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_learning_progressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User_learning_progress.
     * @param {user_learning_progressDeleteArgs} args - Arguments to delete one User_learning_progress.
     * @example
     * // Delete one User_learning_progress
     * const User_learning_progress = await prisma.user_learning_progress.delete({
     *   where: {
     *     // ... filter to delete one User_learning_progress
     *   }
     * })
     * 
     */
    delete<T extends user_learning_progressDeleteArgs>(args: SelectSubset<T, user_learning_progressDeleteArgs<ExtArgs>>): Prisma__user_learning_progressClient<$Result.GetResult<Prisma.$user_learning_progressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_learning_progress.
     * @param {user_learning_progressUpdateArgs} args - Arguments to update one User_learning_progress.
     * @example
     * // Update one User_learning_progress
     * const user_learning_progress = await prisma.user_learning_progress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_learning_progressUpdateArgs>(args: SelectSubset<T, user_learning_progressUpdateArgs<ExtArgs>>): Prisma__user_learning_progressClient<$Result.GetResult<Prisma.$user_learning_progressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_learning_progresses.
     * @param {user_learning_progressDeleteManyArgs} args - Arguments to filter User_learning_progresses to delete.
     * @example
     * // Delete a few User_learning_progresses
     * const { count } = await prisma.user_learning_progress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_learning_progressDeleteManyArgs>(args?: SelectSubset<T, user_learning_progressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_learning_progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_learning_progressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_learning_progresses
     * const user_learning_progress = await prisma.user_learning_progress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_learning_progressUpdateManyArgs>(args: SelectSubset<T, user_learning_progressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_learning_progress.
     * @param {user_learning_progressUpsertArgs} args - Arguments to update or create a User_learning_progress.
     * @example
     * // Update or create a User_learning_progress
     * const user_learning_progress = await prisma.user_learning_progress.upsert({
     *   create: {
     *     // ... data to create a User_learning_progress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_learning_progress we want to update
     *   }
     * })
     */
    upsert<T extends user_learning_progressUpsertArgs>(args: SelectSubset<T, user_learning_progressUpsertArgs<ExtArgs>>): Prisma__user_learning_progressClient<$Result.GetResult<Prisma.$user_learning_progressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_learning_progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_learning_progressCountArgs} args - Arguments to filter User_learning_progresses to count.
     * @example
     * // Count the number of User_learning_progresses
     * const count = await prisma.user_learning_progress.count({
     *   where: {
     *     // ... the filter for the User_learning_progresses we want to count
     *   }
     * })
    **/
    count<T extends user_learning_progressCountArgs>(
      args?: Subset<T, user_learning_progressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_learning_progressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_learning_progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_learning_progressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_learning_progressAggregateArgs>(args: Subset<T, User_learning_progressAggregateArgs>): Prisma.PrismaPromise<GetUser_learning_progressAggregateType<T>>

    /**
     * Group by User_learning_progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_learning_progressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_learning_progressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_learning_progressGroupByArgs['orderBy'] }
        : { orderBy?: user_learning_progressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_learning_progressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_learning_progressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_learning_progress model
   */
  readonly fields: user_learning_progressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_learning_progress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_learning_progressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_learning_progress model
   */ 
  interface user_learning_progressFieldRefs {
    readonly id: FieldRef<"user_learning_progress", 'String'>
    readonly user_id: FieldRef<"user_learning_progress", 'String'>
    readonly rule_key: FieldRef<"user_learning_progress", 'String'>
    readonly viewed_at: FieldRef<"user_learning_progress", 'DateTime'>
    readonly completed: FieldRef<"user_learning_progress", 'Boolean'>
    readonly completed_at: FieldRef<"user_learning_progress", 'DateTime'>
    readonly score: FieldRef<"user_learning_progress", 'Int'>
    readonly created_at: FieldRef<"user_learning_progress", 'DateTime'>
    readonly updated_at: FieldRef<"user_learning_progress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_learning_progress findUnique
   */
  export type user_learning_progressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_learning_progress
     */
    select?: user_learning_progressSelect<ExtArgs> | null
    /**
     * Filter, which user_learning_progress to fetch.
     */
    where: user_learning_progressWhereUniqueInput
  }

  /**
   * user_learning_progress findUniqueOrThrow
   */
  export type user_learning_progressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_learning_progress
     */
    select?: user_learning_progressSelect<ExtArgs> | null
    /**
     * Filter, which user_learning_progress to fetch.
     */
    where: user_learning_progressWhereUniqueInput
  }

  /**
   * user_learning_progress findFirst
   */
  export type user_learning_progressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_learning_progress
     */
    select?: user_learning_progressSelect<ExtArgs> | null
    /**
     * Filter, which user_learning_progress to fetch.
     */
    where?: user_learning_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_learning_progresses to fetch.
     */
    orderBy?: user_learning_progressOrderByWithRelationInput | user_learning_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_learning_progresses.
     */
    cursor?: user_learning_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_learning_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_learning_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_learning_progresses.
     */
    distinct?: User_learning_progressScalarFieldEnum | User_learning_progressScalarFieldEnum[]
  }

  /**
   * user_learning_progress findFirstOrThrow
   */
  export type user_learning_progressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_learning_progress
     */
    select?: user_learning_progressSelect<ExtArgs> | null
    /**
     * Filter, which user_learning_progress to fetch.
     */
    where?: user_learning_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_learning_progresses to fetch.
     */
    orderBy?: user_learning_progressOrderByWithRelationInput | user_learning_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_learning_progresses.
     */
    cursor?: user_learning_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_learning_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_learning_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_learning_progresses.
     */
    distinct?: User_learning_progressScalarFieldEnum | User_learning_progressScalarFieldEnum[]
  }

  /**
   * user_learning_progress findMany
   */
  export type user_learning_progressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_learning_progress
     */
    select?: user_learning_progressSelect<ExtArgs> | null
    /**
     * Filter, which user_learning_progresses to fetch.
     */
    where?: user_learning_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_learning_progresses to fetch.
     */
    orderBy?: user_learning_progressOrderByWithRelationInput | user_learning_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_learning_progresses.
     */
    cursor?: user_learning_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_learning_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_learning_progresses.
     */
    skip?: number
    distinct?: User_learning_progressScalarFieldEnum | User_learning_progressScalarFieldEnum[]
  }

  /**
   * user_learning_progress create
   */
  export type user_learning_progressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_learning_progress
     */
    select?: user_learning_progressSelect<ExtArgs> | null
    /**
     * The data needed to create a user_learning_progress.
     */
    data: XOR<user_learning_progressCreateInput, user_learning_progressUncheckedCreateInput>
  }

  /**
   * user_learning_progress createMany
   */
  export type user_learning_progressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_learning_progresses.
     */
    data: user_learning_progressCreateManyInput | user_learning_progressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_learning_progress createManyAndReturn
   */
  export type user_learning_progressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_learning_progress
     */
    select?: user_learning_progressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many user_learning_progresses.
     */
    data: user_learning_progressCreateManyInput | user_learning_progressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_learning_progress update
   */
  export type user_learning_progressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_learning_progress
     */
    select?: user_learning_progressSelect<ExtArgs> | null
    /**
     * The data needed to update a user_learning_progress.
     */
    data: XOR<user_learning_progressUpdateInput, user_learning_progressUncheckedUpdateInput>
    /**
     * Choose, which user_learning_progress to update.
     */
    where: user_learning_progressWhereUniqueInput
  }

  /**
   * user_learning_progress updateMany
   */
  export type user_learning_progressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_learning_progresses.
     */
    data: XOR<user_learning_progressUpdateManyMutationInput, user_learning_progressUncheckedUpdateManyInput>
    /**
     * Filter which user_learning_progresses to update
     */
    where?: user_learning_progressWhereInput
  }

  /**
   * user_learning_progress upsert
   */
  export type user_learning_progressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_learning_progress
     */
    select?: user_learning_progressSelect<ExtArgs> | null
    /**
     * The filter to search for the user_learning_progress to update in case it exists.
     */
    where: user_learning_progressWhereUniqueInput
    /**
     * In case the user_learning_progress found by the `where` argument doesn't exist, create a new user_learning_progress with this data.
     */
    create: XOR<user_learning_progressCreateInput, user_learning_progressUncheckedCreateInput>
    /**
     * In case the user_learning_progress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_learning_progressUpdateInput, user_learning_progressUncheckedUpdateInput>
  }

  /**
   * user_learning_progress delete
   */
  export type user_learning_progressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_learning_progress
     */
    select?: user_learning_progressSelect<ExtArgs> | null
    /**
     * Filter which user_learning_progress to delete.
     */
    where: user_learning_progressWhereUniqueInput
  }

  /**
   * user_learning_progress deleteMany
   */
  export type user_learning_progressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_learning_progresses to delete
     */
    where?: user_learning_progressWhereInput
  }

  /**
   * user_learning_progress without action
   */
  export type user_learning_progressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_learning_progress
     */
    select?: user_learning_progressSelect<ExtArgs> | null
  }


  /**
   * Model user_achievements
   */

  export type AggregateUser_achievements = {
    _count: User_achievementsCountAggregateOutputType | null
    _min: User_achievementsMinAggregateOutputType | null
    _max: User_achievementsMaxAggregateOutputType | null
  }

  export type User_achievementsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    achievement: string | null
    description: string | null
    icon: string | null
    unlocked_at: Date | null
    category: string | null
  }

  export type User_achievementsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    achievement: string | null
    description: string | null
    icon: string | null
    unlocked_at: Date | null
    category: string | null
  }

  export type User_achievementsCountAggregateOutputType = {
    id: number
    user_id: number
    achievement: number
    description: number
    icon: number
    unlocked_at: number
    category: number
    _all: number
  }


  export type User_achievementsMinAggregateInputType = {
    id?: true
    user_id?: true
    achievement?: true
    description?: true
    icon?: true
    unlocked_at?: true
    category?: true
  }

  export type User_achievementsMaxAggregateInputType = {
    id?: true
    user_id?: true
    achievement?: true
    description?: true
    icon?: true
    unlocked_at?: true
    category?: true
  }

  export type User_achievementsCountAggregateInputType = {
    id?: true
    user_id?: true
    achievement?: true
    description?: true
    icon?: true
    unlocked_at?: true
    category?: true
    _all?: true
  }

  export type User_achievementsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_achievements to aggregate.
     */
    where?: user_achievementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_achievements to fetch.
     */
    orderBy?: user_achievementsOrderByWithRelationInput | user_achievementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_achievementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_achievements
    **/
    _count?: true | User_achievementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_achievementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_achievementsMaxAggregateInputType
  }

  export type GetUser_achievementsAggregateType<T extends User_achievementsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_achievements]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_achievements[P]>
      : GetScalarType<T[P], AggregateUser_achievements[P]>
  }




  export type user_achievementsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_achievementsWhereInput
    orderBy?: user_achievementsOrderByWithAggregationInput | user_achievementsOrderByWithAggregationInput[]
    by: User_achievementsScalarFieldEnum[] | User_achievementsScalarFieldEnum
    having?: user_achievementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_achievementsCountAggregateInputType | true
    _min?: User_achievementsMinAggregateInputType
    _max?: User_achievementsMaxAggregateInputType
  }

  export type User_achievementsGroupByOutputType = {
    id: string
    user_id: string
    achievement: string
    description: string
    icon: string
    unlocked_at: Date
    category: string
    _count: User_achievementsCountAggregateOutputType | null
    _min: User_achievementsMinAggregateOutputType | null
    _max: User_achievementsMaxAggregateOutputType | null
  }

  type GetUser_achievementsGroupByPayload<T extends user_achievementsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_achievementsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_achievementsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_achievementsGroupByOutputType[P]>
            : GetScalarType<T[P], User_achievementsGroupByOutputType[P]>
        }
      >
    >


  export type user_achievementsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    achievement?: boolean
    description?: boolean
    icon?: boolean
    unlocked_at?: boolean
    category?: boolean
  }, ExtArgs["result"]["user_achievements"]>

  export type user_achievementsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    achievement?: boolean
    description?: boolean
    icon?: boolean
    unlocked_at?: boolean
    category?: boolean
  }, ExtArgs["result"]["user_achievements"]>

  export type user_achievementsSelectScalar = {
    id?: boolean
    user_id?: boolean
    achievement?: boolean
    description?: boolean
    icon?: boolean
    unlocked_at?: boolean
    category?: boolean
  }


  export type $user_achievementsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_achievements"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      achievement: string
      description: string
      icon: string
      unlocked_at: Date
      category: string
    }, ExtArgs["result"]["user_achievements"]>
    composites: {}
  }

  type user_achievementsGetPayload<S extends boolean | null | undefined | user_achievementsDefaultArgs> = $Result.GetResult<Prisma.$user_achievementsPayload, S>

  type user_achievementsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_achievementsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_achievementsCountAggregateInputType | true
    }

  export interface user_achievementsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_achievements'], meta: { name: 'user_achievements' } }
    /**
     * Find zero or one User_achievements that matches the filter.
     * @param {user_achievementsFindUniqueArgs} args - Arguments to find a User_achievements
     * @example
     * // Get one User_achievements
     * const user_achievements = await prisma.user_achievements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_achievementsFindUniqueArgs>(args: SelectSubset<T, user_achievementsFindUniqueArgs<ExtArgs>>): Prisma__user_achievementsClient<$Result.GetResult<Prisma.$user_achievementsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_achievements that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_achievementsFindUniqueOrThrowArgs} args - Arguments to find a User_achievements
     * @example
     * // Get one User_achievements
     * const user_achievements = await prisma.user_achievements.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_achievementsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_achievementsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_achievementsClient<$Result.GetResult<Prisma.$user_achievementsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_achievementsFindFirstArgs} args - Arguments to find a User_achievements
     * @example
     * // Get one User_achievements
     * const user_achievements = await prisma.user_achievements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_achievementsFindFirstArgs>(args?: SelectSubset<T, user_achievementsFindFirstArgs<ExtArgs>>): Prisma__user_achievementsClient<$Result.GetResult<Prisma.$user_achievementsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_achievements that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_achievementsFindFirstOrThrowArgs} args - Arguments to find a User_achievements
     * @example
     * // Get one User_achievements
     * const user_achievements = await prisma.user_achievements.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_achievementsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_achievementsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_achievementsClient<$Result.GetResult<Prisma.$user_achievementsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_achievementsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_achievements
     * const user_achievements = await prisma.user_achievements.findMany()
     * 
     * // Get first 10 User_achievements
     * const user_achievements = await prisma.user_achievements.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_achievementsWithIdOnly = await prisma.user_achievements.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_achievementsFindManyArgs>(args?: SelectSubset<T, user_achievementsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_achievementsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_achievements.
     * @param {user_achievementsCreateArgs} args - Arguments to create a User_achievements.
     * @example
     * // Create one User_achievements
     * const User_achievements = await prisma.user_achievements.create({
     *   data: {
     *     // ... data to create a User_achievements
     *   }
     * })
     * 
     */
    create<T extends user_achievementsCreateArgs>(args: SelectSubset<T, user_achievementsCreateArgs<ExtArgs>>): Prisma__user_achievementsClient<$Result.GetResult<Prisma.$user_achievementsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_achievements.
     * @param {user_achievementsCreateManyArgs} args - Arguments to create many User_achievements.
     * @example
     * // Create many User_achievements
     * const user_achievements = await prisma.user_achievements.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_achievementsCreateManyArgs>(args?: SelectSubset<T, user_achievementsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_achievements and returns the data saved in the database.
     * @param {user_achievementsCreateManyAndReturnArgs} args - Arguments to create many User_achievements.
     * @example
     * // Create many User_achievements
     * const user_achievements = await prisma.user_achievements.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_achievements and only return the `id`
     * const user_achievementsWithIdOnly = await prisma.user_achievements.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_achievementsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_achievementsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_achievementsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User_achievements.
     * @param {user_achievementsDeleteArgs} args - Arguments to delete one User_achievements.
     * @example
     * // Delete one User_achievements
     * const User_achievements = await prisma.user_achievements.delete({
     *   where: {
     *     // ... filter to delete one User_achievements
     *   }
     * })
     * 
     */
    delete<T extends user_achievementsDeleteArgs>(args: SelectSubset<T, user_achievementsDeleteArgs<ExtArgs>>): Prisma__user_achievementsClient<$Result.GetResult<Prisma.$user_achievementsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_achievements.
     * @param {user_achievementsUpdateArgs} args - Arguments to update one User_achievements.
     * @example
     * // Update one User_achievements
     * const user_achievements = await prisma.user_achievements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_achievementsUpdateArgs>(args: SelectSubset<T, user_achievementsUpdateArgs<ExtArgs>>): Prisma__user_achievementsClient<$Result.GetResult<Prisma.$user_achievementsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_achievements.
     * @param {user_achievementsDeleteManyArgs} args - Arguments to filter User_achievements to delete.
     * @example
     * // Delete a few User_achievements
     * const { count } = await prisma.user_achievements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_achievementsDeleteManyArgs>(args?: SelectSubset<T, user_achievementsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_achievementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_achievements
     * const user_achievements = await prisma.user_achievements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_achievementsUpdateManyArgs>(args: SelectSubset<T, user_achievementsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_achievements.
     * @param {user_achievementsUpsertArgs} args - Arguments to update or create a User_achievements.
     * @example
     * // Update or create a User_achievements
     * const user_achievements = await prisma.user_achievements.upsert({
     *   create: {
     *     // ... data to create a User_achievements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_achievements we want to update
     *   }
     * })
     */
    upsert<T extends user_achievementsUpsertArgs>(args: SelectSubset<T, user_achievementsUpsertArgs<ExtArgs>>): Prisma__user_achievementsClient<$Result.GetResult<Prisma.$user_achievementsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_achievementsCountArgs} args - Arguments to filter User_achievements to count.
     * @example
     * // Count the number of User_achievements
     * const count = await prisma.user_achievements.count({
     *   where: {
     *     // ... the filter for the User_achievements we want to count
     *   }
     * })
    **/
    count<T extends user_achievementsCountArgs>(
      args?: Subset<T, user_achievementsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_achievementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_achievementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_achievementsAggregateArgs>(args: Subset<T, User_achievementsAggregateArgs>): Prisma.PrismaPromise<GetUser_achievementsAggregateType<T>>

    /**
     * Group by User_achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_achievementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_achievementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_achievementsGroupByArgs['orderBy'] }
        : { orderBy?: user_achievementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_achievementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_achievementsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_achievements model
   */
  readonly fields: user_achievementsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_achievements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_achievementsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_achievements model
   */ 
  interface user_achievementsFieldRefs {
    readonly id: FieldRef<"user_achievements", 'String'>
    readonly user_id: FieldRef<"user_achievements", 'String'>
    readonly achievement: FieldRef<"user_achievements", 'String'>
    readonly description: FieldRef<"user_achievements", 'String'>
    readonly icon: FieldRef<"user_achievements", 'String'>
    readonly unlocked_at: FieldRef<"user_achievements", 'DateTime'>
    readonly category: FieldRef<"user_achievements", 'String'>
  }
    

  // Custom InputTypes
  /**
   * user_achievements findUnique
   */
  export type user_achievementsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_achievements
     */
    select?: user_achievementsSelect<ExtArgs> | null
    /**
     * Filter, which user_achievements to fetch.
     */
    where: user_achievementsWhereUniqueInput
  }

  /**
   * user_achievements findUniqueOrThrow
   */
  export type user_achievementsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_achievements
     */
    select?: user_achievementsSelect<ExtArgs> | null
    /**
     * Filter, which user_achievements to fetch.
     */
    where: user_achievementsWhereUniqueInput
  }

  /**
   * user_achievements findFirst
   */
  export type user_achievementsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_achievements
     */
    select?: user_achievementsSelect<ExtArgs> | null
    /**
     * Filter, which user_achievements to fetch.
     */
    where?: user_achievementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_achievements to fetch.
     */
    orderBy?: user_achievementsOrderByWithRelationInput | user_achievementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_achievements.
     */
    cursor?: user_achievementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_achievements.
     */
    distinct?: User_achievementsScalarFieldEnum | User_achievementsScalarFieldEnum[]
  }

  /**
   * user_achievements findFirstOrThrow
   */
  export type user_achievementsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_achievements
     */
    select?: user_achievementsSelect<ExtArgs> | null
    /**
     * Filter, which user_achievements to fetch.
     */
    where?: user_achievementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_achievements to fetch.
     */
    orderBy?: user_achievementsOrderByWithRelationInput | user_achievementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_achievements.
     */
    cursor?: user_achievementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_achievements.
     */
    distinct?: User_achievementsScalarFieldEnum | User_achievementsScalarFieldEnum[]
  }

  /**
   * user_achievements findMany
   */
  export type user_achievementsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_achievements
     */
    select?: user_achievementsSelect<ExtArgs> | null
    /**
     * Filter, which user_achievements to fetch.
     */
    where?: user_achievementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_achievements to fetch.
     */
    orderBy?: user_achievementsOrderByWithRelationInput | user_achievementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_achievements.
     */
    cursor?: user_achievementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_achievements.
     */
    skip?: number
    distinct?: User_achievementsScalarFieldEnum | User_achievementsScalarFieldEnum[]
  }

  /**
   * user_achievements create
   */
  export type user_achievementsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_achievements
     */
    select?: user_achievementsSelect<ExtArgs> | null
    /**
     * The data needed to create a user_achievements.
     */
    data: XOR<user_achievementsCreateInput, user_achievementsUncheckedCreateInput>
  }

  /**
   * user_achievements createMany
   */
  export type user_achievementsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_achievements.
     */
    data: user_achievementsCreateManyInput | user_achievementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_achievements createManyAndReturn
   */
  export type user_achievementsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_achievements
     */
    select?: user_achievementsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many user_achievements.
     */
    data: user_achievementsCreateManyInput | user_achievementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_achievements update
   */
  export type user_achievementsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_achievements
     */
    select?: user_achievementsSelect<ExtArgs> | null
    /**
     * The data needed to update a user_achievements.
     */
    data: XOR<user_achievementsUpdateInput, user_achievementsUncheckedUpdateInput>
    /**
     * Choose, which user_achievements to update.
     */
    where: user_achievementsWhereUniqueInput
  }

  /**
   * user_achievements updateMany
   */
  export type user_achievementsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_achievements.
     */
    data: XOR<user_achievementsUpdateManyMutationInput, user_achievementsUncheckedUpdateManyInput>
    /**
     * Filter which user_achievements to update
     */
    where?: user_achievementsWhereInput
  }

  /**
   * user_achievements upsert
   */
  export type user_achievementsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_achievements
     */
    select?: user_achievementsSelect<ExtArgs> | null
    /**
     * The filter to search for the user_achievements to update in case it exists.
     */
    where: user_achievementsWhereUniqueInput
    /**
     * In case the user_achievements found by the `where` argument doesn't exist, create a new user_achievements with this data.
     */
    create: XOR<user_achievementsCreateInput, user_achievementsUncheckedCreateInput>
    /**
     * In case the user_achievements was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_achievementsUpdateInput, user_achievementsUncheckedUpdateInput>
  }

  /**
   * user_achievements delete
   */
  export type user_achievementsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_achievements
     */
    select?: user_achievementsSelect<ExtArgs> | null
    /**
     * Filter which user_achievements to delete.
     */
    where: user_achievementsWhereUniqueInput
  }

  /**
   * user_achievements deleteMany
   */
  export type user_achievementsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_achievements to delete
     */
    where?: user_achievementsWhereInput
  }

  /**
   * user_achievements without action
   */
  export type user_achievementsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_achievements
     */
    select?: user_achievementsSelect<ExtArgs> | null
  }


  /**
   * Model user_preferences
   */

  export type AggregateUser_preferences = {
    _count: User_preferencesCountAggregateOutputType | null
    _min: User_preferencesMinAggregateOutputType | null
    _max: User_preferencesMaxAggregateOutputType | null
  }

  export type User_preferencesMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    language: string | null
    theme: string | null
    sound: boolean | null
    notifications: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type User_preferencesMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    language: string | null
    theme: string | null
    sound: boolean | null
    notifications: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type User_preferencesCountAggregateOutputType = {
    id: number
    user_id: number
    language: number
    theme: number
    sound: number
    notifications: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type User_preferencesMinAggregateInputType = {
    id?: true
    user_id?: true
    language?: true
    theme?: true
    sound?: true
    notifications?: true
    created_at?: true
    updated_at?: true
  }

  export type User_preferencesMaxAggregateInputType = {
    id?: true
    user_id?: true
    language?: true
    theme?: true
    sound?: true
    notifications?: true
    created_at?: true
    updated_at?: true
  }

  export type User_preferencesCountAggregateInputType = {
    id?: true
    user_id?: true
    language?: true
    theme?: true
    sound?: true
    notifications?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type User_preferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_preferences to aggregate.
     */
    where?: user_preferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_preferences to fetch.
     */
    orderBy?: user_preferencesOrderByWithRelationInput | user_preferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_preferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_preferences
    **/
    _count?: true | User_preferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_preferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_preferencesMaxAggregateInputType
  }

  export type GetUser_preferencesAggregateType<T extends User_preferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_preferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_preferences[P]>
      : GetScalarType<T[P], AggregateUser_preferences[P]>
  }




  export type user_preferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_preferencesWhereInput
    orderBy?: user_preferencesOrderByWithAggregationInput | user_preferencesOrderByWithAggregationInput[]
    by: User_preferencesScalarFieldEnum[] | User_preferencesScalarFieldEnum
    having?: user_preferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_preferencesCountAggregateInputType | true
    _min?: User_preferencesMinAggregateInputType
    _max?: User_preferencesMaxAggregateInputType
  }

  export type User_preferencesGroupByOutputType = {
    id: string
    user_id: string
    language: string
    theme: string
    sound: boolean
    notifications: boolean
    created_at: Date
    updated_at: Date
    _count: User_preferencesCountAggregateOutputType | null
    _min: User_preferencesMinAggregateOutputType | null
    _max: User_preferencesMaxAggregateOutputType | null
  }

  type GetUser_preferencesGroupByPayload<T extends user_preferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_preferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_preferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_preferencesGroupByOutputType[P]>
            : GetScalarType<T[P], User_preferencesGroupByOutputType[P]>
        }
      >
    >


  export type user_preferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    language?: boolean
    theme?: boolean
    sound?: boolean
    notifications?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user_preferences"]>

  export type user_preferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    language?: boolean
    theme?: boolean
    sound?: boolean
    notifications?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user_preferences"]>

  export type user_preferencesSelectScalar = {
    id?: boolean
    user_id?: boolean
    language?: boolean
    theme?: boolean
    sound?: boolean
    notifications?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $user_preferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_preferences"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      language: string
      theme: string
      sound: boolean
      notifications: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user_preferences"]>
    composites: {}
  }

  type user_preferencesGetPayload<S extends boolean | null | undefined | user_preferencesDefaultArgs> = $Result.GetResult<Prisma.$user_preferencesPayload, S>

  type user_preferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_preferencesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_preferencesCountAggregateInputType | true
    }

  export interface user_preferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_preferences'], meta: { name: 'user_preferences' } }
    /**
     * Find zero or one User_preferences that matches the filter.
     * @param {user_preferencesFindUniqueArgs} args - Arguments to find a User_preferences
     * @example
     * // Get one User_preferences
     * const user_preferences = await prisma.user_preferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_preferencesFindUniqueArgs>(args: SelectSubset<T, user_preferencesFindUniqueArgs<ExtArgs>>): Prisma__user_preferencesClient<$Result.GetResult<Prisma.$user_preferencesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_preferences that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_preferencesFindUniqueOrThrowArgs} args - Arguments to find a User_preferences
     * @example
     * // Get one User_preferences
     * const user_preferences = await prisma.user_preferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_preferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, user_preferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_preferencesClient<$Result.GetResult<Prisma.$user_preferencesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_preferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_preferencesFindFirstArgs} args - Arguments to find a User_preferences
     * @example
     * // Get one User_preferences
     * const user_preferences = await prisma.user_preferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_preferencesFindFirstArgs>(args?: SelectSubset<T, user_preferencesFindFirstArgs<ExtArgs>>): Prisma__user_preferencesClient<$Result.GetResult<Prisma.$user_preferencesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_preferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_preferencesFindFirstOrThrowArgs} args - Arguments to find a User_preferences
     * @example
     * // Get one User_preferences
     * const user_preferences = await prisma.user_preferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_preferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, user_preferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_preferencesClient<$Result.GetResult<Prisma.$user_preferencesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_preferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_preferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_preferences
     * const user_preferences = await prisma.user_preferences.findMany()
     * 
     * // Get first 10 User_preferences
     * const user_preferences = await prisma.user_preferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_preferencesWithIdOnly = await prisma.user_preferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_preferencesFindManyArgs>(args?: SelectSubset<T, user_preferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_preferencesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_preferences.
     * @param {user_preferencesCreateArgs} args - Arguments to create a User_preferences.
     * @example
     * // Create one User_preferences
     * const User_preferences = await prisma.user_preferences.create({
     *   data: {
     *     // ... data to create a User_preferences
     *   }
     * })
     * 
     */
    create<T extends user_preferencesCreateArgs>(args: SelectSubset<T, user_preferencesCreateArgs<ExtArgs>>): Prisma__user_preferencesClient<$Result.GetResult<Prisma.$user_preferencesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_preferences.
     * @param {user_preferencesCreateManyArgs} args - Arguments to create many User_preferences.
     * @example
     * // Create many User_preferences
     * const user_preferences = await prisma.user_preferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_preferencesCreateManyArgs>(args?: SelectSubset<T, user_preferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_preferences and returns the data saved in the database.
     * @param {user_preferencesCreateManyAndReturnArgs} args - Arguments to create many User_preferences.
     * @example
     * // Create many User_preferences
     * const user_preferences = await prisma.user_preferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_preferences and only return the `id`
     * const user_preferencesWithIdOnly = await prisma.user_preferences.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_preferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, user_preferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_preferencesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User_preferences.
     * @param {user_preferencesDeleteArgs} args - Arguments to delete one User_preferences.
     * @example
     * // Delete one User_preferences
     * const User_preferences = await prisma.user_preferences.delete({
     *   where: {
     *     // ... filter to delete one User_preferences
     *   }
     * })
     * 
     */
    delete<T extends user_preferencesDeleteArgs>(args: SelectSubset<T, user_preferencesDeleteArgs<ExtArgs>>): Prisma__user_preferencesClient<$Result.GetResult<Prisma.$user_preferencesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_preferences.
     * @param {user_preferencesUpdateArgs} args - Arguments to update one User_preferences.
     * @example
     * // Update one User_preferences
     * const user_preferences = await prisma.user_preferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_preferencesUpdateArgs>(args: SelectSubset<T, user_preferencesUpdateArgs<ExtArgs>>): Prisma__user_preferencesClient<$Result.GetResult<Prisma.$user_preferencesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_preferences.
     * @param {user_preferencesDeleteManyArgs} args - Arguments to filter User_preferences to delete.
     * @example
     * // Delete a few User_preferences
     * const { count } = await prisma.user_preferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_preferencesDeleteManyArgs>(args?: SelectSubset<T, user_preferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_preferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_preferences
     * const user_preferences = await prisma.user_preferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_preferencesUpdateManyArgs>(args: SelectSubset<T, user_preferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_preferences.
     * @param {user_preferencesUpsertArgs} args - Arguments to update or create a User_preferences.
     * @example
     * // Update or create a User_preferences
     * const user_preferences = await prisma.user_preferences.upsert({
     *   create: {
     *     // ... data to create a User_preferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_preferences we want to update
     *   }
     * })
     */
    upsert<T extends user_preferencesUpsertArgs>(args: SelectSubset<T, user_preferencesUpsertArgs<ExtArgs>>): Prisma__user_preferencesClient<$Result.GetResult<Prisma.$user_preferencesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_preferencesCountArgs} args - Arguments to filter User_preferences to count.
     * @example
     * // Count the number of User_preferences
     * const count = await prisma.user_preferences.count({
     *   where: {
     *     // ... the filter for the User_preferences we want to count
     *   }
     * })
    **/
    count<T extends user_preferencesCountArgs>(
      args?: Subset<T, user_preferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_preferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_preferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_preferencesAggregateArgs>(args: Subset<T, User_preferencesAggregateArgs>): Prisma.PrismaPromise<GetUser_preferencesAggregateType<T>>

    /**
     * Group by User_preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_preferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_preferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_preferencesGroupByArgs['orderBy'] }
        : { orderBy?: user_preferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_preferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_preferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_preferences model
   */
  readonly fields: user_preferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_preferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_preferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_preferences model
   */ 
  interface user_preferencesFieldRefs {
    readonly id: FieldRef<"user_preferences", 'String'>
    readonly user_id: FieldRef<"user_preferences", 'String'>
    readonly language: FieldRef<"user_preferences", 'String'>
    readonly theme: FieldRef<"user_preferences", 'String'>
    readonly sound: FieldRef<"user_preferences", 'Boolean'>
    readonly notifications: FieldRef<"user_preferences", 'Boolean'>
    readonly created_at: FieldRef<"user_preferences", 'DateTime'>
    readonly updated_at: FieldRef<"user_preferences", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_preferences findUnique
   */
  export type user_preferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_preferences
     */
    select?: user_preferencesSelect<ExtArgs> | null
    /**
     * Filter, which user_preferences to fetch.
     */
    where: user_preferencesWhereUniqueInput
  }

  /**
   * user_preferences findUniqueOrThrow
   */
  export type user_preferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_preferences
     */
    select?: user_preferencesSelect<ExtArgs> | null
    /**
     * Filter, which user_preferences to fetch.
     */
    where: user_preferencesWhereUniqueInput
  }

  /**
   * user_preferences findFirst
   */
  export type user_preferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_preferences
     */
    select?: user_preferencesSelect<ExtArgs> | null
    /**
     * Filter, which user_preferences to fetch.
     */
    where?: user_preferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_preferences to fetch.
     */
    orderBy?: user_preferencesOrderByWithRelationInput | user_preferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_preferences.
     */
    cursor?: user_preferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_preferences.
     */
    distinct?: User_preferencesScalarFieldEnum | User_preferencesScalarFieldEnum[]
  }

  /**
   * user_preferences findFirstOrThrow
   */
  export type user_preferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_preferences
     */
    select?: user_preferencesSelect<ExtArgs> | null
    /**
     * Filter, which user_preferences to fetch.
     */
    where?: user_preferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_preferences to fetch.
     */
    orderBy?: user_preferencesOrderByWithRelationInput | user_preferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_preferences.
     */
    cursor?: user_preferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_preferences.
     */
    distinct?: User_preferencesScalarFieldEnum | User_preferencesScalarFieldEnum[]
  }

  /**
   * user_preferences findMany
   */
  export type user_preferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_preferences
     */
    select?: user_preferencesSelect<ExtArgs> | null
    /**
     * Filter, which user_preferences to fetch.
     */
    where?: user_preferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_preferences to fetch.
     */
    orderBy?: user_preferencesOrderByWithRelationInput | user_preferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_preferences.
     */
    cursor?: user_preferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_preferences.
     */
    skip?: number
    distinct?: User_preferencesScalarFieldEnum | User_preferencesScalarFieldEnum[]
  }

  /**
   * user_preferences create
   */
  export type user_preferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_preferences
     */
    select?: user_preferencesSelect<ExtArgs> | null
    /**
     * The data needed to create a user_preferences.
     */
    data: XOR<user_preferencesCreateInput, user_preferencesUncheckedCreateInput>
  }

  /**
   * user_preferences createMany
   */
  export type user_preferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_preferences.
     */
    data: user_preferencesCreateManyInput | user_preferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_preferences createManyAndReturn
   */
  export type user_preferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_preferences
     */
    select?: user_preferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many user_preferences.
     */
    data: user_preferencesCreateManyInput | user_preferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_preferences update
   */
  export type user_preferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_preferences
     */
    select?: user_preferencesSelect<ExtArgs> | null
    /**
     * The data needed to update a user_preferences.
     */
    data: XOR<user_preferencesUpdateInput, user_preferencesUncheckedUpdateInput>
    /**
     * Choose, which user_preferences to update.
     */
    where: user_preferencesWhereUniqueInput
  }

  /**
   * user_preferences updateMany
   */
  export type user_preferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_preferences.
     */
    data: XOR<user_preferencesUpdateManyMutationInput, user_preferencesUncheckedUpdateManyInput>
    /**
     * Filter which user_preferences to update
     */
    where?: user_preferencesWhereInput
  }

  /**
   * user_preferences upsert
   */
  export type user_preferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_preferences
     */
    select?: user_preferencesSelect<ExtArgs> | null
    /**
     * The filter to search for the user_preferences to update in case it exists.
     */
    where: user_preferencesWhereUniqueInput
    /**
     * In case the user_preferences found by the `where` argument doesn't exist, create a new user_preferences with this data.
     */
    create: XOR<user_preferencesCreateInput, user_preferencesUncheckedCreateInput>
    /**
     * In case the user_preferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_preferencesUpdateInput, user_preferencesUncheckedUpdateInput>
  }

  /**
   * user_preferences delete
   */
  export type user_preferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_preferences
     */
    select?: user_preferencesSelect<ExtArgs> | null
    /**
     * Filter which user_preferences to delete.
     */
    where: user_preferencesWhereUniqueInput
  }

  /**
   * user_preferences deleteMany
   */
  export type user_preferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_preferences to delete
     */
    where?: user_preferencesWhereInput
  }

  /**
   * user_preferences without action
   */
  export type user_preferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_preferences
     */
    select?: user_preferencesSelect<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    eloRating: number | null
    gamesPlayed: number | null
    gamesWon: number | null
    winRate: number | null
    currentStreak: number | null
    bestStreak: number | null
  }

  export type UsersSumAggregateOutputType = {
    eloRating: number | null
    gamesPlayed: number | null
    gamesWon: number | null
    winRate: number | null
    currentStreak: number | null
    bestStreak: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    avatarUrl: string | null
    country: string | null
    eloRating: number | null
    gamesPlayed: number | null
    gamesWon: number | null
    winRate: number | null
    currentStreak: number | null
    bestStreak: number | null
    subscriptionType: $Enums.SubscriptionType | null
    subscriptionExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    avatarUrl: string | null
    country: string | null
    eloRating: number | null
    gamesPlayed: number | null
    gamesWon: number | null
    winRate: number | null
    currentStreak: number | null
    bestStreak: number | null
    subscriptionType: $Enums.SubscriptionType | null
    subscriptionExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    password: number
    username: number
    firstName: number
    lastName: number
    avatarUrl: number
    country: number
    eloRating: number
    gamesPlayed: number
    gamesWon: number
    winRate: number
    currentStreak: number
    bestStreak: number
    subscriptionType: number
    subscriptionExpiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    eloRating?: true
    gamesPlayed?: true
    gamesWon?: true
    winRate?: true
    currentStreak?: true
    bestStreak?: true
  }

  export type UsersSumAggregateInputType = {
    eloRating?: true
    gamesPlayed?: true
    gamesWon?: true
    winRate?: true
    currentStreak?: true
    bestStreak?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    country?: true
    eloRating?: true
    gamesPlayed?: true
    gamesWon?: true
    winRate?: true
    currentStreak?: true
    bestStreak?: true
    subscriptionType?: true
    subscriptionExpiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    country?: true
    eloRating?: true
    gamesPlayed?: true
    gamesWon?: true
    winRate?: true
    currentStreak?: true
    bestStreak?: true
    subscriptionType?: true
    subscriptionExpiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    country?: true
    eloRating?: true
    gamesPlayed?: true
    gamesWon?: true
    winRate?: true
    currentStreak?: true
    bestStreak?: true
    subscriptionType?: true
    subscriptionExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    email: string
    password: string
    username: string | null
    firstName: string | null
    lastName: string | null
    avatarUrl: string | null
    country: string | null
    eloRating: number
    gamesPlayed: number
    gamesWon: number
    winRate: number
    currentStreak: number
    bestStreak: number
    subscriptionType: $Enums.SubscriptionType
    subscriptionExpiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    country?: boolean
    eloRating?: boolean
    gamesPlayed?: boolean
    gamesWon?: boolean
    winRate?: boolean
    currentStreak?: boolean
    bestStreak?: boolean
    subscriptionType?: boolean
    subscriptionExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    analyses?: boolean | users$analysesArgs<ExtArgs>
    analysisQuotas?: boolean | users$analysisQuotasArgs<ExtArgs>
    iaQuota?: boolean | users$iaQuotaArgs<ExtArgs>
    sessions?: boolean | users$sessionsArgs<ExtArgs>
    chatMessages?: boolean | users$chatMessagesArgs<ExtArgs>
    gameMoves?: boolean | users$gameMovesArgs<ExtArgs>
    userAnalytics?: boolean | users$userAnalyticsArgs<ExtArgs>
    gameAnalyses?: boolean | users$gameAnalysesArgs<ExtArgs>
    subscription?: boolean | users$subscriptionArgs<ExtArgs>
    tournamentParticipants?: boolean | users$tournamentParticipantsArgs<ExtArgs>
    tournaments?: boolean | users$tournamentsArgs<ExtArgs>
    websocketConnections?: boolean | users$websocketConnectionsArgs<ExtArgs>
    whiteGames?: boolean | users$whiteGamesArgs<ExtArgs>
    blackGames?: boolean | users$blackGamesArgs<ExtArgs>
    gameSessions?: boolean | users$gameSessionsArgs<ExtArgs>
    seasonStats?: boolean | users$seasonStatsArgs<ExtArgs>
    seasonLeaderboards?: boolean | users$seasonLeaderboardsArgs<ExtArgs>
    quotaHistory?: boolean | users$quotaHistoryArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    country?: boolean
    eloRating?: boolean
    gamesPlayed?: boolean
    gamesWon?: boolean
    winRate?: boolean
    currentStreak?: boolean
    bestStreak?: boolean
    subscriptionType?: boolean
    subscriptionExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    country?: boolean
    eloRating?: boolean
    gamesPlayed?: boolean
    gamesWon?: boolean
    winRate?: boolean
    currentStreak?: boolean
    bestStreak?: boolean
    subscriptionType?: boolean
    subscriptionExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analyses?: boolean | users$analysesArgs<ExtArgs>
    analysisQuotas?: boolean | users$analysisQuotasArgs<ExtArgs>
    iaQuota?: boolean | users$iaQuotaArgs<ExtArgs>
    sessions?: boolean | users$sessionsArgs<ExtArgs>
    chatMessages?: boolean | users$chatMessagesArgs<ExtArgs>
    gameMoves?: boolean | users$gameMovesArgs<ExtArgs>
    userAnalytics?: boolean | users$userAnalyticsArgs<ExtArgs>
    gameAnalyses?: boolean | users$gameAnalysesArgs<ExtArgs>
    subscription?: boolean | users$subscriptionArgs<ExtArgs>
    tournamentParticipants?: boolean | users$tournamentParticipantsArgs<ExtArgs>
    tournaments?: boolean | users$tournamentsArgs<ExtArgs>
    websocketConnections?: boolean | users$websocketConnectionsArgs<ExtArgs>
    whiteGames?: boolean | users$whiteGamesArgs<ExtArgs>
    blackGames?: boolean | users$blackGamesArgs<ExtArgs>
    gameSessions?: boolean | users$gameSessionsArgs<ExtArgs>
    seasonStats?: boolean | users$seasonStatsArgs<ExtArgs>
    seasonLeaderboards?: boolean | users$seasonLeaderboardsArgs<ExtArgs>
    quotaHistory?: boolean | users$quotaHistoryArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      analyses: Prisma.$analysesPayload<ExtArgs>[]
      analysisQuotas: Prisma.$AnalysisQuotaPayload<ExtArgs>[]
      iaQuota: Prisma.$IAQuotaPayload<ExtArgs> | null
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
      chatMessages: Prisma.$chat_messagesPayload<ExtArgs>[]
      gameMoves: Prisma.$game_movesPayload<ExtArgs>[]
      userAnalytics: Prisma.$user_analyticsPayload<ExtArgs>[]
      gameAnalyses: Prisma.$game_analysesPayload<ExtArgs>[]
      subscription: Prisma.$subscriptionsPayload<ExtArgs> | null
      tournamentParticipants: Prisma.$tournament_participantsPayload<ExtArgs>[]
      tournaments: Prisma.$tournamentsPayload<ExtArgs>[]
      websocketConnections: Prisma.$websocket_connectionsPayload<ExtArgs>[]
      whiteGames: Prisma.$gamesPayload<ExtArgs>[]
      blackGames: Prisma.$gamesPayload<ExtArgs>[]
      gameSessions: Prisma.$GameSessionPayload<ExtArgs>[]
      seasonStats: Prisma.$user_season_statsPayload<ExtArgs>[]
      seasonLeaderboards: Prisma.$season_leaderboardPayload<ExtArgs>[]
      quotaHistory: Prisma.$user_quota_historyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      username: string | null
      firstName: string | null
      lastName: string | null
      avatarUrl: string | null
      country: string | null
      eloRating: number
      gamesPlayed: number
      gamesWon: number
      winRate: number
      currentStreak: number
      bestStreak: number
      subscriptionType: $Enums.SubscriptionType
      subscriptionExpiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    analyses<T extends users$analysesArgs<ExtArgs> = {}>(args?: Subset<T, users$analysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "findMany"> | Null>
    analysisQuotas<T extends users$analysisQuotasArgs<ExtArgs> = {}>(args?: Subset<T, users$analysisQuotasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisQuotaPayload<ExtArgs>, T, "findMany"> | Null>
    iaQuota<T extends users$iaQuotaArgs<ExtArgs> = {}>(args?: Subset<T, users$iaQuotaArgs<ExtArgs>>): Prisma__IAQuotaClient<$Result.GetResult<Prisma.$IAQuotaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sessions<T extends users$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, users$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany"> | Null>
    chatMessages<T extends users$chatMessagesArgs<ExtArgs> = {}>(args?: Subset<T, users$chatMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findMany"> | Null>
    gameMoves<T extends users$gameMovesArgs<ExtArgs> = {}>(args?: Subset<T, users$gameMovesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "findMany"> | Null>
    userAnalytics<T extends users$userAnalyticsArgs<ExtArgs> = {}>(args?: Subset<T, users$userAnalyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "findMany"> | Null>
    gameAnalyses<T extends users$gameAnalysesArgs<ExtArgs> = {}>(args?: Subset<T, users$gameAnalysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_analysesPayload<ExtArgs>, T, "findMany"> | Null>
    subscription<T extends users$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, users$subscriptionArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tournamentParticipants<T extends users$tournamentParticipantsArgs<ExtArgs> = {}>(args?: Subset<T, users$tournamentParticipantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "findMany"> | Null>
    tournaments<T extends users$tournamentsArgs<ExtArgs> = {}>(args?: Subset<T, users$tournamentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findMany"> | Null>
    websocketConnections<T extends users$websocketConnectionsArgs<ExtArgs> = {}>(args?: Subset<T, users$websocketConnectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "findMany"> | Null>
    whiteGames<T extends users$whiteGamesArgs<ExtArgs> = {}>(args?: Subset<T, users$whiteGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findMany"> | Null>
    blackGames<T extends users$blackGamesArgs<ExtArgs> = {}>(args?: Subset<T, users$blackGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findMany"> | Null>
    gameSessions<T extends users$gameSessionsArgs<ExtArgs> = {}>(args?: Subset<T, users$gameSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findMany"> | Null>
    seasonStats<T extends users$seasonStatsArgs<ExtArgs> = {}>(args?: Subset<T, users$seasonStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_season_statsPayload<ExtArgs>, T, "findMany"> | Null>
    seasonLeaderboards<T extends users$seasonLeaderboardsArgs<ExtArgs> = {}>(args?: Subset<T, users$seasonLeaderboardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$season_leaderboardPayload<ExtArgs>, T, "findMany"> | Null>
    quotaHistory<T extends users$quotaHistoryArgs<ExtArgs> = {}>(args?: Subset<T, users$quotaHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_quota_historyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly username: FieldRef<"users", 'String'>
    readonly firstName: FieldRef<"users", 'String'>
    readonly lastName: FieldRef<"users", 'String'>
    readonly avatarUrl: FieldRef<"users", 'String'>
    readonly country: FieldRef<"users", 'String'>
    readonly eloRating: FieldRef<"users", 'Int'>
    readonly gamesPlayed: FieldRef<"users", 'Int'>
    readonly gamesWon: FieldRef<"users", 'Int'>
    readonly winRate: FieldRef<"users", 'Float'>
    readonly currentStreak: FieldRef<"users", 'Int'>
    readonly bestStreak: FieldRef<"users", 'Int'>
    readonly subscriptionType: FieldRef<"users", 'SubscriptionType'>
    readonly subscriptionExpiresAt: FieldRef<"users", 'DateTime'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly updatedAt: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users.analyses
   */
  export type users$analysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    where?: analysesWhereInput
    orderBy?: analysesOrderByWithRelationInput | analysesOrderByWithRelationInput[]
    cursor?: analysesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalysesScalarFieldEnum | AnalysesScalarFieldEnum[]
  }

  /**
   * users.analysisQuotas
   */
  export type users$analysisQuotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuota
     */
    select?: AnalysisQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuotaInclude<ExtArgs> | null
    where?: AnalysisQuotaWhereInput
    orderBy?: AnalysisQuotaOrderByWithRelationInput | AnalysisQuotaOrderByWithRelationInput[]
    cursor?: AnalysisQuotaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalysisQuotaScalarFieldEnum | AnalysisQuotaScalarFieldEnum[]
  }

  /**
   * users.iaQuota
   */
  export type users$iaQuotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IAQuota
     */
    select?: IAQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IAQuotaInclude<ExtArgs> | null
    where?: IAQuotaWhereInput
  }

  /**
   * users.sessions
   */
  export type users$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * users.chatMessages
   */
  export type users$chatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    where?: chat_messagesWhereInput
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    cursor?: chat_messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * users.gameMoves
   */
  export type users$gameMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    where?: game_movesWhereInput
    orderBy?: game_movesOrderByWithRelationInput | game_movesOrderByWithRelationInput[]
    cursor?: game_movesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Game_movesScalarFieldEnum | Game_movesScalarFieldEnum[]
  }

  /**
   * users.userAnalytics
   */
  export type users$userAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    where?: user_analyticsWhereInput
    orderBy?: user_analyticsOrderByWithRelationInput | user_analyticsOrderByWithRelationInput[]
    cursor?: user_analyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_analyticsScalarFieldEnum | User_analyticsScalarFieldEnum[]
  }

  /**
   * users.gameAnalyses
   */
  export type users$gameAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_analyses
     */
    select?: game_analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_analysesInclude<ExtArgs> | null
    where?: game_analysesWhereInput
    orderBy?: game_analysesOrderByWithRelationInput | game_analysesOrderByWithRelationInput[]
    cursor?: game_analysesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Game_analysesScalarFieldEnum | Game_analysesScalarFieldEnum[]
  }

  /**
   * users.subscription
   */
  export type users$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    where?: subscriptionsWhereInput
  }

  /**
   * users.tournamentParticipants
   */
  export type users$tournamentParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    where?: tournament_participantsWhereInput
    orderBy?: tournament_participantsOrderByWithRelationInput | tournament_participantsOrderByWithRelationInput[]
    cursor?: tournament_participantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tournament_participantsScalarFieldEnum | Tournament_participantsScalarFieldEnum[]
  }

  /**
   * users.tournaments
   */
  export type users$tournamentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    where?: tournamentsWhereInput
    orderBy?: tournamentsOrderByWithRelationInput | tournamentsOrderByWithRelationInput[]
    cursor?: tournamentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentsScalarFieldEnum | TournamentsScalarFieldEnum[]
  }

  /**
   * users.websocketConnections
   */
  export type users$websocketConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    where?: websocket_connectionsWhereInput
    orderBy?: websocket_connectionsOrderByWithRelationInput | websocket_connectionsOrderByWithRelationInput[]
    cursor?: websocket_connectionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Websocket_connectionsScalarFieldEnum | Websocket_connectionsScalarFieldEnum[]
  }

  /**
   * users.whiteGames
   */
  export type users$whiteGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    where?: gamesWhereInput
    orderBy?: gamesOrderByWithRelationInput | gamesOrderByWithRelationInput[]
    cursor?: gamesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamesScalarFieldEnum | GamesScalarFieldEnum[]
  }

  /**
   * users.blackGames
   */
  export type users$blackGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    where?: gamesWhereInput
    orderBy?: gamesOrderByWithRelationInput | gamesOrderByWithRelationInput[]
    cursor?: gamesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamesScalarFieldEnum | GamesScalarFieldEnum[]
  }

  /**
   * users.gameSessions
   */
  export type users$gameSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    where?: GameSessionWhereInput
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    cursor?: GameSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * users.seasonStats
   */
  export type users$seasonStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_season_stats
     */
    select?: user_season_statsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_season_statsInclude<ExtArgs> | null
    where?: user_season_statsWhereInput
    orderBy?: user_season_statsOrderByWithRelationInput | user_season_statsOrderByWithRelationInput[]
    cursor?: user_season_statsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_season_statsScalarFieldEnum | User_season_statsScalarFieldEnum[]
  }

  /**
   * users.seasonLeaderboards
   */
  export type users$seasonLeaderboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the season_leaderboard
     */
    select?: season_leaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: season_leaderboardInclude<ExtArgs> | null
    where?: season_leaderboardWhereInput
    orderBy?: season_leaderboardOrderByWithRelationInput | season_leaderboardOrderByWithRelationInput[]
    cursor?: season_leaderboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Season_leaderboardScalarFieldEnum | Season_leaderboardScalarFieldEnum[]
  }

  /**
   * users.quotaHistory
   */
  export type users$quotaHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quota_history
     */
    select?: user_quota_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_quota_historyInclude<ExtArgs> | null
    where?: user_quota_historyWhereInput
    orderBy?: user_quota_historyOrderByWithRelationInput | user_quota_historyOrderByWithRelationInput[]
    cursor?: user_quota_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_quota_historyScalarFieldEnum | User_quota_historyScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model seasons
   */

  export type AggregateSeasons = {
    _count: SeasonsCountAggregateOutputType | null
    _min: SeasonsMinAggregateOutputType | null
    _max: SeasonsMaxAggregateOutputType | null
  }

  export type SeasonsMinAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeasonsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeasonsCountAggregateOutputType = {
    id: number
    name: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SeasonsMinAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeasonsMaxAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeasonsCountAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SeasonsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which seasons to aggregate.
     */
    where?: seasonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasons to fetch.
     */
    orderBy?: seasonsOrderByWithRelationInput | seasonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: seasonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned seasons
    **/
    _count?: true | SeasonsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeasonsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeasonsMaxAggregateInputType
  }

  export type GetSeasonsAggregateType<T extends SeasonsAggregateArgs> = {
        [P in keyof T & keyof AggregateSeasons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeasons[P]>
      : GetScalarType<T[P], AggregateSeasons[P]>
  }




  export type seasonsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: seasonsWhereInput
    orderBy?: seasonsOrderByWithAggregationInput | seasonsOrderByWithAggregationInput[]
    by: SeasonsScalarFieldEnum[] | SeasonsScalarFieldEnum
    having?: seasonsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeasonsCountAggregateInputType | true
    _min?: SeasonsMinAggregateInputType
    _max?: SeasonsMaxAggregateInputType
  }

  export type SeasonsGroupByOutputType = {
    id: string
    name: string
    startDate: Date
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SeasonsCountAggregateOutputType | null
    _min: SeasonsMinAggregateOutputType | null
    _max: SeasonsMaxAggregateOutputType | null
  }

  type GetSeasonsGroupByPayload<T extends seasonsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeasonsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeasonsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeasonsGroupByOutputType[P]>
            : GetScalarType<T[P], SeasonsGroupByOutputType[P]>
        }
      >
    >


  export type seasonsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seasonStats?: boolean | seasons$seasonStatsArgs<ExtArgs>
    leaderboards?: boolean | seasons$leaderboardsArgs<ExtArgs>
    quotaHistory?: boolean | seasons$quotaHistoryArgs<ExtArgs>
    _count?: boolean | SeasonsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seasons"]>

  export type seasonsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["seasons"]>

  export type seasonsSelectScalar = {
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type seasonsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seasonStats?: boolean | seasons$seasonStatsArgs<ExtArgs>
    leaderboards?: boolean | seasons$leaderboardsArgs<ExtArgs>
    quotaHistory?: boolean | seasons$quotaHistoryArgs<ExtArgs>
    _count?: boolean | SeasonsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type seasonsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $seasonsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "seasons"
    objects: {
      seasonStats: Prisma.$user_season_statsPayload<ExtArgs>[]
      leaderboards: Prisma.$season_leaderboardPayload<ExtArgs>[]
      quotaHistory: Prisma.$user_quota_historyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      startDate: Date
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["seasons"]>
    composites: {}
  }

  type seasonsGetPayload<S extends boolean | null | undefined | seasonsDefaultArgs> = $Result.GetResult<Prisma.$seasonsPayload, S>

  type seasonsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<seasonsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SeasonsCountAggregateInputType | true
    }

  export interface seasonsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['seasons'], meta: { name: 'seasons' } }
    /**
     * Find zero or one Seasons that matches the filter.
     * @param {seasonsFindUniqueArgs} args - Arguments to find a Seasons
     * @example
     * // Get one Seasons
     * const seasons = await prisma.seasons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends seasonsFindUniqueArgs>(args: SelectSubset<T, seasonsFindUniqueArgs<ExtArgs>>): Prisma__seasonsClient<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Seasons that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {seasonsFindUniqueOrThrowArgs} args - Arguments to find a Seasons
     * @example
     * // Get one Seasons
     * const seasons = await prisma.seasons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends seasonsFindUniqueOrThrowArgs>(args: SelectSubset<T, seasonsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__seasonsClient<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Seasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonsFindFirstArgs} args - Arguments to find a Seasons
     * @example
     * // Get one Seasons
     * const seasons = await prisma.seasons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends seasonsFindFirstArgs>(args?: SelectSubset<T, seasonsFindFirstArgs<ExtArgs>>): Prisma__seasonsClient<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Seasons that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonsFindFirstOrThrowArgs} args - Arguments to find a Seasons
     * @example
     * // Get one Seasons
     * const seasons = await prisma.seasons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends seasonsFindFirstOrThrowArgs>(args?: SelectSubset<T, seasonsFindFirstOrThrowArgs<ExtArgs>>): Prisma__seasonsClient<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Seasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seasons
     * const seasons = await prisma.seasons.findMany()
     * 
     * // Get first 10 Seasons
     * const seasons = await prisma.seasons.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seasonsWithIdOnly = await prisma.seasons.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends seasonsFindManyArgs>(args?: SelectSubset<T, seasonsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Seasons.
     * @param {seasonsCreateArgs} args - Arguments to create a Seasons.
     * @example
     * // Create one Seasons
     * const Seasons = await prisma.seasons.create({
     *   data: {
     *     // ... data to create a Seasons
     *   }
     * })
     * 
     */
    create<T extends seasonsCreateArgs>(args: SelectSubset<T, seasonsCreateArgs<ExtArgs>>): Prisma__seasonsClient<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Seasons.
     * @param {seasonsCreateManyArgs} args - Arguments to create many Seasons.
     * @example
     * // Create many Seasons
     * const seasons = await prisma.seasons.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends seasonsCreateManyArgs>(args?: SelectSubset<T, seasonsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Seasons and returns the data saved in the database.
     * @param {seasonsCreateManyAndReturnArgs} args - Arguments to create many Seasons.
     * @example
     * // Create many Seasons
     * const seasons = await prisma.seasons.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Seasons and only return the `id`
     * const seasonsWithIdOnly = await prisma.seasons.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends seasonsCreateManyAndReturnArgs>(args?: SelectSubset<T, seasonsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Seasons.
     * @param {seasonsDeleteArgs} args - Arguments to delete one Seasons.
     * @example
     * // Delete one Seasons
     * const Seasons = await prisma.seasons.delete({
     *   where: {
     *     // ... filter to delete one Seasons
     *   }
     * })
     * 
     */
    delete<T extends seasonsDeleteArgs>(args: SelectSubset<T, seasonsDeleteArgs<ExtArgs>>): Prisma__seasonsClient<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Seasons.
     * @param {seasonsUpdateArgs} args - Arguments to update one Seasons.
     * @example
     * // Update one Seasons
     * const seasons = await prisma.seasons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends seasonsUpdateArgs>(args: SelectSubset<T, seasonsUpdateArgs<ExtArgs>>): Prisma__seasonsClient<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Seasons.
     * @param {seasonsDeleteManyArgs} args - Arguments to filter Seasons to delete.
     * @example
     * // Delete a few Seasons
     * const { count } = await prisma.seasons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends seasonsDeleteManyArgs>(args?: SelectSubset<T, seasonsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seasons
     * const seasons = await prisma.seasons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends seasonsUpdateManyArgs>(args: SelectSubset<T, seasonsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Seasons.
     * @param {seasonsUpsertArgs} args - Arguments to update or create a Seasons.
     * @example
     * // Update or create a Seasons
     * const seasons = await prisma.seasons.upsert({
     *   create: {
     *     // ... data to create a Seasons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seasons we want to update
     *   }
     * })
     */
    upsert<T extends seasonsUpsertArgs>(args: SelectSubset<T, seasonsUpsertArgs<ExtArgs>>): Prisma__seasonsClient<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonsCountArgs} args - Arguments to filter Seasons to count.
     * @example
     * // Count the number of Seasons
     * const count = await prisma.seasons.count({
     *   where: {
     *     // ... the filter for the Seasons we want to count
     *   }
     * })
    **/
    count<T extends seasonsCountArgs>(
      args?: Subset<T, seasonsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeasonsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeasonsAggregateArgs>(args: Subset<T, SeasonsAggregateArgs>): Prisma.PrismaPromise<GetSeasonsAggregateType<T>>

    /**
     * Group by Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends seasonsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: seasonsGroupByArgs['orderBy'] }
        : { orderBy?: seasonsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, seasonsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeasonsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the seasons model
   */
  readonly fields: seasonsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for seasons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__seasonsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seasonStats<T extends seasons$seasonStatsArgs<ExtArgs> = {}>(args?: Subset<T, seasons$seasonStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_season_statsPayload<ExtArgs>, T, "findMany"> | Null>
    leaderboards<T extends seasons$leaderboardsArgs<ExtArgs> = {}>(args?: Subset<T, seasons$leaderboardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$season_leaderboardPayload<ExtArgs>, T, "findMany"> | Null>
    quotaHistory<T extends seasons$quotaHistoryArgs<ExtArgs> = {}>(args?: Subset<T, seasons$quotaHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_quota_historyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the seasons model
   */ 
  interface seasonsFieldRefs {
    readonly id: FieldRef<"seasons", 'String'>
    readonly name: FieldRef<"seasons", 'String'>
    readonly startDate: FieldRef<"seasons", 'DateTime'>
    readonly endDate: FieldRef<"seasons", 'DateTime'>
    readonly createdAt: FieldRef<"seasons", 'DateTime'>
    readonly updatedAt: FieldRef<"seasons", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * seasons findUnique
   */
  export type seasonsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
    /**
     * Filter, which seasons to fetch.
     */
    where: seasonsWhereUniqueInput
  }

  /**
   * seasons findUniqueOrThrow
   */
  export type seasonsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
    /**
     * Filter, which seasons to fetch.
     */
    where: seasonsWhereUniqueInput
  }

  /**
   * seasons findFirst
   */
  export type seasonsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
    /**
     * Filter, which seasons to fetch.
     */
    where?: seasonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasons to fetch.
     */
    orderBy?: seasonsOrderByWithRelationInput | seasonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seasons.
     */
    cursor?: seasonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seasons.
     */
    distinct?: SeasonsScalarFieldEnum | SeasonsScalarFieldEnum[]
  }

  /**
   * seasons findFirstOrThrow
   */
  export type seasonsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
    /**
     * Filter, which seasons to fetch.
     */
    where?: seasonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasons to fetch.
     */
    orderBy?: seasonsOrderByWithRelationInput | seasonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seasons.
     */
    cursor?: seasonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seasons.
     */
    distinct?: SeasonsScalarFieldEnum | SeasonsScalarFieldEnum[]
  }

  /**
   * seasons findMany
   */
  export type seasonsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
    /**
     * Filter, which seasons to fetch.
     */
    where?: seasonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasons to fetch.
     */
    orderBy?: seasonsOrderByWithRelationInput | seasonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing seasons.
     */
    cursor?: seasonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasons.
     */
    skip?: number
    distinct?: SeasonsScalarFieldEnum | SeasonsScalarFieldEnum[]
  }

  /**
   * seasons create
   */
  export type seasonsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
    /**
     * The data needed to create a seasons.
     */
    data: XOR<seasonsCreateInput, seasonsUncheckedCreateInput>
  }

  /**
   * seasons createMany
   */
  export type seasonsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many seasons.
     */
    data: seasonsCreateManyInput | seasonsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * seasons createManyAndReturn
   */
  export type seasonsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many seasons.
     */
    data: seasonsCreateManyInput | seasonsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * seasons update
   */
  export type seasonsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
    /**
     * The data needed to update a seasons.
     */
    data: XOR<seasonsUpdateInput, seasonsUncheckedUpdateInput>
    /**
     * Choose, which seasons to update.
     */
    where: seasonsWhereUniqueInput
  }

  /**
   * seasons updateMany
   */
  export type seasonsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update seasons.
     */
    data: XOR<seasonsUpdateManyMutationInput, seasonsUncheckedUpdateManyInput>
    /**
     * Filter which seasons to update
     */
    where?: seasonsWhereInput
  }

  /**
   * seasons upsert
   */
  export type seasonsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
    /**
     * The filter to search for the seasons to update in case it exists.
     */
    where: seasonsWhereUniqueInput
    /**
     * In case the seasons found by the `where` argument doesn't exist, create a new seasons with this data.
     */
    create: XOR<seasonsCreateInput, seasonsUncheckedCreateInput>
    /**
     * In case the seasons was found with the provided `where` argument, update it with this data.
     */
    update: XOR<seasonsUpdateInput, seasonsUncheckedUpdateInput>
  }

  /**
   * seasons delete
   */
  export type seasonsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
    /**
     * Filter which seasons to delete.
     */
    where: seasonsWhereUniqueInput
  }

  /**
   * seasons deleteMany
   */
  export type seasonsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which seasons to delete
     */
    where?: seasonsWhereInput
  }

  /**
   * seasons.seasonStats
   */
  export type seasons$seasonStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_season_stats
     */
    select?: user_season_statsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_season_statsInclude<ExtArgs> | null
    where?: user_season_statsWhereInput
    orderBy?: user_season_statsOrderByWithRelationInput | user_season_statsOrderByWithRelationInput[]
    cursor?: user_season_statsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_season_statsScalarFieldEnum | User_season_statsScalarFieldEnum[]
  }

  /**
   * seasons.leaderboards
   */
  export type seasons$leaderboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the season_leaderboard
     */
    select?: season_leaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: season_leaderboardInclude<ExtArgs> | null
    where?: season_leaderboardWhereInput
    orderBy?: season_leaderboardOrderByWithRelationInput | season_leaderboardOrderByWithRelationInput[]
    cursor?: season_leaderboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Season_leaderboardScalarFieldEnum | Season_leaderboardScalarFieldEnum[]
  }

  /**
   * seasons.quotaHistory
   */
  export type seasons$quotaHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quota_history
     */
    select?: user_quota_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_quota_historyInclude<ExtArgs> | null
    where?: user_quota_historyWhereInput
    orderBy?: user_quota_historyOrderByWithRelationInput | user_quota_historyOrderByWithRelationInput[]
    cursor?: user_quota_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_quota_historyScalarFieldEnum | User_quota_historyScalarFieldEnum[]
  }

  /**
   * seasons without action
   */
  export type seasonsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
  }


  /**
   * Model user_season_stats
   */

  export type AggregateUser_season_stats = {
    _count: User_season_statsCountAggregateOutputType | null
    _avg: User_season_statsAvgAggregateOutputType | null
    _sum: User_season_statsSumAggregateOutputType | null
    _min: User_season_statsMinAggregateOutputType | null
    _max: User_season_statsMaxAggregateOutputType | null
  }

  export type User_season_statsAvgAggregateOutputType = {
    elo: number | null
    winrate: number | null
    gamesPlayed: number | null
  }

  export type User_season_statsSumAggregateOutputType = {
    elo: number | null
    winrate: number | null
    gamesPlayed: number | null
  }

  export type User_season_statsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    seasonId: string | null
    elo: number | null
    winrate: number | null
    gamesPlayed: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type User_season_statsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    seasonId: string | null
    elo: number | null
    winrate: number | null
    gamesPlayed: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type User_season_statsCountAggregateOutputType = {
    id: number
    userId: number
    seasonId: number
    elo: number
    winrate: number
    gamesPlayed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type User_season_statsAvgAggregateInputType = {
    elo?: true
    winrate?: true
    gamesPlayed?: true
  }

  export type User_season_statsSumAggregateInputType = {
    elo?: true
    winrate?: true
    gamesPlayed?: true
  }

  export type User_season_statsMinAggregateInputType = {
    id?: true
    userId?: true
    seasonId?: true
    elo?: true
    winrate?: true
    gamesPlayed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type User_season_statsMaxAggregateInputType = {
    id?: true
    userId?: true
    seasonId?: true
    elo?: true
    winrate?: true
    gamesPlayed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type User_season_statsCountAggregateInputType = {
    id?: true
    userId?: true
    seasonId?: true
    elo?: true
    winrate?: true
    gamesPlayed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type User_season_statsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_season_stats to aggregate.
     */
    where?: user_season_statsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_season_stats to fetch.
     */
    orderBy?: user_season_statsOrderByWithRelationInput | user_season_statsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_season_statsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_season_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_season_stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_season_stats
    **/
    _count?: true | User_season_statsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_season_statsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_season_statsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_season_statsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_season_statsMaxAggregateInputType
  }

  export type GetUser_season_statsAggregateType<T extends User_season_statsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_season_stats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_season_stats[P]>
      : GetScalarType<T[P], AggregateUser_season_stats[P]>
  }




  export type user_season_statsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_season_statsWhereInput
    orderBy?: user_season_statsOrderByWithAggregationInput | user_season_statsOrderByWithAggregationInput[]
    by: User_season_statsScalarFieldEnum[] | User_season_statsScalarFieldEnum
    having?: user_season_statsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_season_statsCountAggregateInputType | true
    _avg?: User_season_statsAvgAggregateInputType
    _sum?: User_season_statsSumAggregateInputType
    _min?: User_season_statsMinAggregateInputType
    _max?: User_season_statsMaxAggregateInputType
  }

  export type User_season_statsGroupByOutputType = {
    id: string
    userId: string
    seasonId: string
    elo: number
    winrate: number
    gamesPlayed: number
    createdAt: Date
    updatedAt: Date
    _count: User_season_statsCountAggregateOutputType | null
    _avg: User_season_statsAvgAggregateOutputType | null
    _sum: User_season_statsSumAggregateOutputType | null
    _min: User_season_statsMinAggregateOutputType | null
    _max: User_season_statsMaxAggregateOutputType | null
  }

  type GetUser_season_statsGroupByPayload<T extends user_season_statsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_season_statsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_season_statsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_season_statsGroupByOutputType[P]>
            : GetScalarType<T[P], User_season_statsGroupByOutputType[P]>
        }
      >
    >


  export type user_season_statsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    seasonId?: boolean
    elo?: boolean
    winrate?: boolean
    gamesPlayed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    season?: boolean | seasonsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_season_stats"]>

  export type user_season_statsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    seasonId?: boolean
    elo?: boolean
    winrate?: boolean
    gamesPlayed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    season?: boolean | seasonsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_season_stats"]>

  export type user_season_statsSelectScalar = {
    id?: boolean
    userId?: boolean
    seasonId?: boolean
    elo?: boolean
    winrate?: boolean
    gamesPlayed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type user_season_statsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    season?: boolean | seasonsDefaultArgs<ExtArgs>
  }
  export type user_season_statsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    season?: boolean | seasonsDefaultArgs<ExtArgs>
  }

  export type $user_season_statsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_season_stats"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      season: Prisma.$seasonsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      seasonId: string
      elo: number
      winrate: number
      gamesPlayed: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user_season_stats"]>
    composites: {}
  }

  type user_season_statsGetPayload<S extends boolean | null | undefined | user_season_statsDefaultArgs> = $Result.GetResult<Prisma.$user_season_statsPayload, S>

  type user_season_statsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_season_statsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_season_statsCountAggregateInputType | true
    }

  export interface user_season_statsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_season_stats'], meta: { name: 'user_season_stats' } }
    /**
     * Find zero or one User_season_stats that matches the filter.
     * @param {user_season_statsFindUniqueArgs} args - Arguments to find a User_season_stats
     * @example
     * // Get one User_season_stats
     * const user_season_stats = await prisma.user_season_stats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_season_statsFindUniqueArgs>(args: SelectSubset<T, user_season_statsFindUniqueArgs<ExtArgs>>): Prisma__user_season_statsClient<$Result.GetResult<Prisma.$user_season_statsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_season_stats that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_season_statsFindUniqueOrThrowArgs} args - Arguments to find a User_season_stats
     * @example
     * // Get one User_season_stats
     * const user_season_stats = await prisma.user_season_stats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_season_statsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_season_statsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_season_statsClient<$Result.GetResult<Prisma.$user_season_statsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_season_stats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_season_statsFindFirstArgs} args - Arguments to find a User_season_stats
     * @example
     * // Get one User_season_stats
     * const user_season_stats = await prisma.user_season_stats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_season_statsFindFirstArgs>(args?: SelectSubset<T, user_season_statsFindFirstArgs<ExtArgs>>): Prisma__user_season_statsClient<$Result.GetResult<Prisma.$user_season_statsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_season_stats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_season_statsFindFirstOrThrowArgs} args - Arguments to find a User_season_stats
     * @example
     * // Get one User_season_stats
     * const user_season_stats = await prisma.user_season_stats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_season_statsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_season_statsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_season_statsClient<$Result.GetResult<Prisma.$user_season_statsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_season_stats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_season_statsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_season_stats
     * const user_season_stats = await prisma.user_season_stats.findMany()
     * 
     * // Get first 10 User_season_stats
     * const user_season_stats = await prisma.user_season_stats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_season_statsWithIdOnly = await prisma.user_season_stats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_season_statsFindManyArgs>(args?: SelectSubset<T, user_season_statsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_season_statsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_season_stats.
     * @param {user_season_statsCreateArgs} args - Arguments to create a User_season_stats.
     * @example
     * // Create one User_season_stats
     * const User_season_stats = await prisma.user_season_stats.create({
     *   data: {
     *     // ... data to create a User_season_stats
     *   }
     * })
     * 
     */
    create<T extends user_season_statsCreateArgs>(args: SelectSubset<T, user_season_statsCreateArgs<ExtArgs>>): Prisma__user_season_statsClient<$Result.GetResult<Prisma.$user_season_statsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_season_stats.
     * @param {user_season_statsCreateManyArgs} args - Arguments to create many User_season_stats.
     * @example
     * // Create many User_season_stats
     * const user_season_stats = await prisma.user_season_stats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_season_statsCreateManyArgs>(args?: SelectSubset<T, user_season_statsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_season_stats and returns the data saved in the database.
     * @param {user_season_statsCreateManyAndReturnArgs} args - Arguments to create many User_season_stats.
     * @example
     * // Create many User_season_stats
     * const user_season_stats = await prisma.user_season_stats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_season_stats and only return the `id`
     * const user_season_statsWithIdOnly = await prisma.user_season_stats.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_season_statsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_season_statsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_season_statsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User_season_stats.
     * @param {user_season_statsDeleteArgs} args - Arguments to delete one User_season_stats.
     * @example
     * // Delete one User_season_stats
     * const User_season_stats = await prisma.user_season_stats.delete({
     *   where: {
     *     // ... filter to delete one User_season_stats
     *   }
     * })
     * 
     */
    delete<T extends user_season_statsDeleteArgs>(args: SelectSubset<T, user_season_statsDeleteArgs<ExtArgs>>): Prisma__user_season_statsClient<$Result.GetResult<Prisma.$user_season_statsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_season_stats.
     * @param {user_season_statsUpdateArgs} args - Arguments to update one User_season_stats.
     * @example
     * // Update one User_season_stats
     * const user_season_stats = await prisma.user_season_stats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_season_statsUpdateArgs>(args: SelectSubset<T, user_season_statsUpdateArgs<ExtArgs>>): Prisma__user_season_statsClient<$Result.GetResult<Prisma.$user_season_statsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_season_stats.
     * @param {user_season_statsDeleteManyArgs} args - Arguments to filter User_season_stats to delete.
     * @example
     * // Delete a few User_season_stats
     * const { count } = await prisma.user_season_stats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_season_statsDeleteManyArgs>(args?: SelectSubset<T, user_season_statsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_season_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_season_statsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_season_stats
     * const user_season_stats = await prisma.user_season_stats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_season_statsUpdateManyArgs>(args: SelectSubset<T, user_season_statsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_season_stats.
     * @param {user_season_statsUpsertArgs} args - Arguments to update or create a User_season_stats.
     * @example
     * // Update or create a User_season_stats
     * const user_season_stats = await prisma.user_season_stats.upsert({
     *   create: {
     *     // ... data to create a User_season_stats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_season_stats we want to update
     *   }
     * })
     */
    upsert<T extends user_season_statsUpsertArgs>(args: SelectSubset<T, user_season_statsUpsertArgs<ExtArgs>>): Prisma__user_season_statsClient<$Result.GetResult<Prisma.$user_season_statsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_season_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_season_statsCountArgs} args - Arguments to filter User_season_stats to count.
     * @example
     * // Count the number of User_season_stats
     * const count = await prisma.user_season_stats.count({
     *   where: {
     *     // ... the filter for the User_season_stats we want to count
     *   }
     * })
    **/
    count<T extends user_season_statsCountArgs>(
      args?: Subset<T, user_season_statsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_season_statsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_season_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_season_statsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_season_statsAggregateArgs>(args: Subset<T, User_season_statsAggregateArgs>): Prisma.PrismaPromise<GetUser_season_statsAggregateType<T>>

    /**
     * Group by User_season_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_season_statsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_season_statsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_season_statsGroupByArgs['orderBy'] }
        : { orderBy?: user_season_statsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_season_statsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_season_statsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_season_stats model
   */
  readonly fields: user_season_statsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_season_stats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_season_statsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    season<T extends seasonsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, seasonsDefaultArgs<ExtArgs>>): Prisma__seasonsClient<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_season_stats model
   */ 
  interface user_season_statsFieldRefs {
    readonly id: FieldRef<"user_season_stats", 'String'>
    readonly userId: FieldRef<"user_season_stats", 'String'>
    readonly seasonId: FieldRef<"user_season_stats", 'String'>
    readonly elo: FieldRef<"user_season_stats", 'Int'>
    readonly winrate: FieldRef<"user_season_stats", 'Float'>
    readonly gamesPlayed: FieldRef<"user_season_stats", 'Int'>
    readonly createdAt: FieldRef<"user_season_stats", 'DateTime'>
    readonly updatedAt: FieldRef<"user_season_stats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_season_stats findUnique
   */
  export type user_season_statsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_season_stats
     */
    select?: user_season_statsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_season_statsInclude<ExtArgs> | null
    /**
     * Filter, which user_season_stats to fetch.
     */
    where: user_season_statsWhereUniqueInput
  }

  /**
   * user_season_stats findUniqueOrThrow
   */
  export type user_season_statsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_season_stats
     */
    select?: user_season_statsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_season_statsInclude<ExtArgs> | null
    /**
     * Filter, which user_season_stats to fetch.
     */
    where: user_season_statsWhereUniqueInput
  }

  /**
   * user_season_stats findFirst
   */
  export type user_season_statsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_season_stats
     */
    select?: user_season_statsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_season_statsInclude<ExtArgs> | null
    /**
     * Filter, which user_season_stats to fetch.
     */
    where?: user_season_statsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_season_stats to fetch.
     */
    orderBy?: user_season_statsOrderByWithRelationInput | user_season_statsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_season_stats.
     */
    cursor?: user_season_statsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_season_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_season_stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_season_stats.
     */
    distinct?: User_season_statsScalarFieldEnum | User_season_statsScalarFieldEnum[]
  }

  /**
   * user_season_stats findFirstOrThrow
   */
  export type user_season_statsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_season_stats
     */
    select?: user_season_statsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_season_statsInclude<ExtArgs> | null
    /**
     * Filter, which user_season_stats to fetch.
     */
    where?: user_season_statsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_season_stats to fetch.
     */
    orderBy?: user_season_statsOrderByWithRelationInput | user_season_statsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_season_stats.
     */
    cursor?: user_season_statsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_season_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_season_stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_season_stats.
     */
    distinct?: User_season_statsScalarFieldEnum | User_season_statsScalarFieldEnum[]
  }

  /**
   * user_season_stats findMany
   */
  export type user_season_statsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_season_stats
     */
    select?: user_season_statsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_season_statsInclude<ExtArgs> | null
    /**
     * Filter, which user_season_stats to fetch.
     */
    where?: user_season_statsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_season_stats to fetch.
     */
    orderBy?: user_season_statsOrderByWithRelationInput | user_season_statsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_season_stats.
     */
    cursor?: user_season_statsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_season_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_season_stats.
     */
    skip?: number
    distinct?: User_season_statsScalarFieldEnum | User_season_statsScalarFieldEnum[]
  }

  /**
   * user_season_stats create
   */
  export type user_season_statsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_season_stats
     */
    select?: user_season_statsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_season_statsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_season_stats.
     */
    data: XOR<user_season_statsCreateInput, user_season_statsUncheckedCreateInput>
  }

  /**
   * user_season_stats createMany
   */
  export type user_season_statsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_season_stats.
     */
    data: user_season_statsCreateManyInput | user_season_statsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_season_stats createManyAndReturn
   */
  export type user_season_statsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_season_stats
     */
    select?: user_season_statsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many user_season_stats.
     */
    data: user_season_statsCreateManyInput | user_season_statsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_season_statsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_season_stats update
   */
  export type user_season_statsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_season_stats
     */
    select?: user_season_statsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_season_statsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_season_stats.
     */
    data: XOR<user_season_statsUpdateInput, user_season_statsUncheckedUpdateInput>
    /**
     * Choose, which user_season_stats to update.
     */
    where: user_season_statsWhereUniqueInput
  }

  /**
   * user_season_stats updateMany
   */
  export type user_season_statsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_season_stats.
     */
    data: XOR<user_season_statsUpdateManyMutationInput, user_season_statsUncheckedUpdateManyInput>
    /**
     * Filter which user_season_stats to update
     */
    where?: user_season_statsWhereInput
  }

  /**
   * user_season_stats upsert
   */
  export type user_season_statsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_season_stats
     */
    select?: user_season_statsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_season_statsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_season_stats to update in case it exists.
     */
    where: user_season_statsWhereUniqueInput
    /**
     * In case the user_season_stats found by the `where` argument doesn't exist, create a new user_season_stats with this data.
     */
    create: XOR<user_season_statsCreateInput, user_season_statsUncheckedCreateInput>
    /**
     * In case the user_season_stats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_season_statsUpdateInput, user_season_statsUncheckedUpdateInput>
  }

  /**
   * user_season_stats delete
   */
  export type user_season_statsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_season_stats
     */
    select?: user_season_statsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_season_statsInclude<ExtArgs> | null
    /**
     * Filter which user_season_stats to delete.
     */
    where: user_season_statsWhereUniqueInput
  }

  /**
   * user_season_stats deleteMany
   */
  export type user_season_statsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_season_stats to delete
     */
    where?: user_season_statsWhereInput
  }

  /**
   * user_season_stats without action
   */
  export type user_season_statsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_season_stats
     */
    select?: user_season_statsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_season_statsInclude<ExtArgs> | null
  }


  /**
   * Model season_leaderboard
   */

  export type AggregateSeason_leaderboard = {
    _count: Season_leaderboardCountAggregateOutputType | null
    _avg: Season_leaderboardAvgAggregateOutputType | null
    _sum: Season_leaderboardSumAggregateOutputType | null
    _min: Season_leaderboardMinAggregateOutputType | null
    _max: Season_leaderboardMaxAggregateOutputType | null
  }

  export type Season_leaderboardAvgAggregateOutputType = {
    rankGlobal: number | null
    rankCountry: number | null
  }

  export type Season_leaderboardSumAggregateOutputType = {
    rankGlobal: number | null
    rankCountry: number | null
  }

  export type Season_leaderboardMinAggregateOutputType = {
    id: string | null
    seasonId: string | null
    userId: string | null
    rankGlobal: number | null
    rankCountry: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Season_leaderboardMaxAggregateOutputType = {
    id: string | null
    seasonId: string | null
    userId: string | null
    rankGlobal: number | null
    rankCountry: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Season_leaderboardCountAggregateOutputType = {
    id: number
    seasonId: number
    userId: number
    rankGlobal: number
    rankCountry: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Season_leaderboardAvgAggregateInputType = {
    rankGlobal?: true
    rankCountry?: true
  }

  export type Season_leaderboardSumAggregateInputType = {
    rankGlobal?: true
    rankCountry?: true
  }

  export type Season_leaderboardMinAggregateInputType = {
    id?: true
    seasonId?: true
    userId?: true
    rankGlobal?: true
    rankCountry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Season_leaderboardMaxAggregateInputType = {
    id?: true
    seasonId?: true
    userId?: true
    rankGlobal?: true
    rankCountry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Season_leaderboardCountAggregateInputType = {
    id?: true
    seasonId?: true
    userId?: true
    rankGlobal?: true
    rankCountry?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Season_leaderboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which season_leaderboard to aggregate.
     */
    where?: season_leaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of season_leaderboards to fetch.
     */
    orderBy?: season_leaderboardOrderByWithRelationInput | season_leaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: season_leaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` season_leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` season_leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned season_leaderboards
    **/
    _count?: true | Season_leaderboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Season_leaderboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Season_leaderboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Season_leaderboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Season_leaderboardMaxAggregateInputType
  }

  export type GetSeason_leaderboardAggregateType<T extends Season_leaderboardAggregateArgs> = {
        [P in keyof T & keyof AggregateSeason_leaderboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeason_leaderboard[P]>
      : GetScalarType<T[P], AggregateSeason_leaderboard[P]>
  }




  export type season_leaderboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: season_leaderboardWhereInput
    orderBy?: season_leaderboardOrderByWithAggregationInput | season_leaderboardOrderByWithAggregationInput[]
    by: Season_leaderboardScalarFieldEnum[] | Season_leaderboardScalarFieldEnum
    having?: season_leaderboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Season_leaderboardCountAggregateInputType | true
    _avg?: Season_leaderboardAvgAggregateInputType
    _sum?: Season_leaderboardSumAggregateInputType
    _min?: Season_leaderboardMinAggregateInputType
    _max?: Season_leaderboardMaxAggregateInputType
  }

  export type Season_leaderboardGroupByOutputType = {
    id: string
    seasonId: string
    userId: string
    rankGlobal: number
    rankCountry: number
    createdAt: Date
    updatedAt: Date
    _count: Season_leaderboardCountAggregateOutputType | null
    _avg: Season_leaderboardAvgAggregateOutputType | null
    _sum: Season_leaderboardSumAggregateOutputType | null
    _min: Season_leaderboardMinAggregateOutputType | null
    _max: Season_leaderboardMaxAggregateOutputType | null
  }

  type GetSeason_leaderboardGroupByPayload<T extends season_leaderboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Season_leaderboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Season_leaderboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Season_leaderboardGroupByOutputType[P]>
            : GetScalarType<T[P], Season_leaderboardGroupByOutputType[P]>
        }
      >
    >


  export type season_leaderboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seasonId?: boolean
    userId?: boolean
    rankGlobal?: boolean
    rankCountry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    season?: boolean | seasonsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["season_leaderboard"]>

  export type season_leaderboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seasonId?: boolean
    userId?: boolean
    rankGlobal?: boolean
    rankCountry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    season?: boolean | seasonsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["season_leaderboard"]>

  export type season_leaderboardSelectScalar = {
    id?: boolean
    seasonId?: boolean
    userId?: boolean
    rankGlobal?: boolean
    rankCountry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type season_leaderboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    season?: boolean | seasonsDefaultArgs<ExtArgs>
  }
  export type season_leaderboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    season?: boolean | seasonsDefaultArgs<ExtArgs>
  }

  export type $season_leaderboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "season_leaderboard"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      season: Prisma.$seasonsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seasonId: string
      userId: string
      rankGlobal: number
      rankCountry: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["season_leaderboard"]>
    composites: {}
  }

  type season_leaderboardGetPayload<S extends boolean | null | undefined | season_leaderboardDefaultArgs> = $Result.GetResult<Prisma.$season_leaderboardPayload, S>

  type season_leaderboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<season_leaderboardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Season_leaderboardCountAggregateInputType | true
    }

  export interface season_leaderboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['season_leaderboard'], meta: { name: 'season_leaderboard' } }
    /**
     * Find zero or one Season_leaderboard that matches the filter.
     * @param {season_leaderboardFindUniqueArgs} args - Arguments to find a Season_leaderboard
     * @example
     * // Get one Season_leaderboard
     * const season_leaderboard = await prisma.season_leaderboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends season_leaderboardFindUniqueArgs>(args: SelectSubset<T, season_leaderboardFindUniqueArgs<ExtArgs>>): Prisma__season_leaderboardClient<$Result.GetResult<Prisma.$season_leaderboardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Season_leaderboard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {season_leaderboardFindUniqueOrThrowArgs} args - Arguments to find a Season_leaderboard
     * @example
     * // Get one Season_leaderboard
     * const season_leaderboard = await prisma.season_leaderboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends season_leaderboardFindUniqueOrThrowArgs>(args: SelectSubset<T, season_leaderboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__season_leaderboardClient<$Result.GetResult<Prisma.$season_leaderboardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Season_leaderboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {season_leaderboardFindFirstArgs} args - Arguments to find a Season_leaderboard
     * @example
     * // Get one Season_leaderboard
     * const season_leaderboard = await prisma.season_leaderboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends season_leaderboardFindFirstArgs>(args?: SelectSubset<T, season_leaderboardFindFirstArgs<ExtArgs>>): Prisma__season_leaderboardClient<$Result.GetResult<Prisma.$season_leaderboardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Season_leaderboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {season_leaderboardFindFirstOrThrowArgs} args - Arguments to find a Season_leaderboard
     * @example
     * // Get one Season_leaderboard
     * const season_leaderboard = await prisma.season_leaderboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends season_leaderboardFindFirstOrThrowArgs>(args?: SelectSubset<T, season_leaderboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__season_leaderboardClient<$Result.GetResult<Prisma.$season_leaderboardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Season_leaderboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {season_leaderboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Season_leaderboards
     * const season_leaderboards = await prisma.season_leaderboard.findMany()
     * 
     * // Get first 10 Season_leaderboards
     * const season_leaderboards = await prisma.season_leaderboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const season_leaderboardWithIdOnly = await prisma.season_leaderboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends season_leaderboardFindManyArgs>(args?: SelectSubset<T, season_leaderboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$season_leaderboardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Season_leaderboard.
     * @param {season_leaderboardCreateArgs} args - Arguments to create a Season_leaderboard.
     * @example
     * // Create one Season_leaderboard
     * const Season_leaderboard = await prisma.season_leaderboard.create({
     *   data: {
     *     // ... data to create a Season_leaderboard
     *   }
     * })
     * 
     */
    create<T extends season_leaderboardCreateArgs>(args: SelectSubset<T, season_leaderboardCreateArgs<ExtArgs>>): Prisma__season_leaderboardClient<$Result.GetResult<Prisma.$season_leaderboardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Season_leaderboards.
     * @param {season_leaderboardCreateManyArgs} args - Arguments to create many Season_leaderboards.
     * @example
     * // Create many Season_leaderboards
     * const season_leaderboard = await prisma.season_leaderboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends season_leaderboardCreateManyArgs>(args?: SelectSubset<T, season_leaderboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Season_leaderboards and returns the data saved in the database.
     * @param {season_leaderboardCreateManyAndReturnArgs} args - Arguments to create many Season_leaderboards.
     * @example
     * // Create many Season_leaderboards
     * const season_leaderboard = await prisma.season_leaderboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Season_leaderboards and only return the `id`
     * const season_leaderboardWithIdOnly = await prisma.season_leaderboard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends season_leaderboardCreateManyAndReturnArgs>(args?: SelectSubset<T, season_leaderboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$season_leaderboardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Season_leaderboard.
     * @param {season_leaderboardDeleteArgs} args - Arguments to delete one Season_leaderboard.
     * @example
     * // Delete one Season_leaderboard
     * const Season_leaderboard = await prisma.season_leaderboard.delete({
     *   where: {
     *     // ... filter to delete one Season_leaderboard
     *   }
     * })
     * 
     */
    delete<T extends season_leaderboardDeleteArgs>(args: SelectSubset<T, season_leaderboardDeleteArgs<ExtArgs>>): Prisma__season_leaderboardClient<$Result.GetResult<Prisma.$season_leaderboardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Season_leaderboard.
     * @param {season_leaderboardUpdateArgs} args - Arguments to update one Season_leaderboard.
     * @example
     * // Update one Season_leaderboard
     * const season_leaderboard = await prisma.season_leaderboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends season_leaderboardUpdateArgs>(args: SelectSubset<T, season_leaderboardUpdateArgs<ExtArgs>>): Prisma__season_leaderboardClient<$Result.GetResult<Prisma.$season_leaderboardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Season_leaderboards.
     * @param {season_leaderboardDeleteManyArgs} args - Arguments to filter Season_leaderboards to delete.
     * @example
     * // Delete a few Season_leaderboards
     * const { count } = await prisma.season_leaderboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends season_leaderboardDeleteManyArgs>(args?: SelectSubset<T, season_leaderboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Season_leaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {season_leaderboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Season_leaderboards
     * const season_leaderboard = await prisma.season_leaderboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends season_leaderboardUpdateManyArgs>(args: SelectSubset<T, season_leaderboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Season_leaderboard.
     * @param {season_leaderboardUpsertArgs} args - Arguments to update or create a Season_leaderboard.
     * @example
     * // Update or create a Season_leaderboard
     * const season_leaderboard = await prisma.season_leaderboard.upsert({
     *   create: {
     *     // ... data to create a Season_leaderboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Season_leaderboard we want to update
     *   }
     * })
     */
    upsert<T extends season_leaderboardUpsertArgs>(args: SelectSubset<T, season_leaderboardUpsertArgs<ExtArgs>>): Prisma__season_leaderboardClient<$Result.GetResult<Prisma.$season_leaderboardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Season_leaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {season_leaderboardCountArgs} args - Arguments to filter Season_leaderboards to count.
     * @example
     * // Count the number of Season_leaderboards
     * const count = await prisma.season_leaderboard.count({
     *   where: {
     *     // ... the filter for the Season_leaderboards we want to count
     *   }
     * })
    **/
    count<T extends season_leaderboardCountArgs>(
      args?: Subset<T, season_leaderboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Season_leaderboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Season_leaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Season_leaderboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Season_leaderboardAggregateArgs>(args: Subset<T, Season_leaderboardAggregateArgs>): Prisma.PrismaPromise<GetSeason_leaderboardAggregateType<T>>

    /**
     * Group by Season_leaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {season_leaderboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends season_leaderboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: season_leaderboardGroupByArgs['orderBy'] }
        : { orderBy?: season_leaderboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, season_leaderboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeason_leaderboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the season_leaderboard model
   */
  readonly fields: season_leaderboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for season_leaderboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__season_leaderboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    season<T extends seasonsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, seasonsDefaultArgs<ExtArgs>>): Prisma__seasonsClient<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the season_leaderboard model
   */ 
  interface season_leaderboardFieldRefs {
    readonly id: FieldRef<"season_leaderboard", 'String'>
    readonly seasonId: FieldRef<"season_leaderboard", 'String'>
    readonly userId: FieldRef<"season_leaderboard", 'String'>
    readonly rankGlobal: FieldRef<"season_leaderboard", 'Int'>
    readonly rankCountry: FieldRef<"season_leaderboard", 'Int'>
    readonly createdAt: FieldRef<"season_leaderboard", 'DateTime'>
    readonly updatedAt: FieldRef<"season_leaderboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * season_leaderboard findUnique
   */
  export type season_leaderboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the season_leaderboard
     */
    select?: season_leaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: season_leaderboardInclude<ExtArgs> | null
    /**
     * Filter, which season_leaderboard to fetch.
     */
    where: season_leaderboardWhereUniqueInput
  }

  /**
   * season_leaderboard findUniqueOrThrow
   */
  export type season_leaderboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the season_leaderboard
     */
    select?: season_leaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: season_leaderboardInclude<ExtArgs> | null
    /**
     * Filter, which season_leaderboard to fetch.
     */
    where: season_leaderboardWhereUniqueInput
  }

  /**
   * season_leaderboard findFirst
   */
  export type season_leaderboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the season_leaderboard
     */
    select?: season_leaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: season_leaderboardInclude<ExtArgs> | null
    /**
     * Filter, which season_leaderboard to fetch.
     */
    where?: season_leaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of season_leaderboards to fetch.
     */
    orderBy?: season_leaderboardOrderByWithRelationInput | season_leaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for season_leaderboards.
     */
    cursor?: season_leaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` season_leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` season_leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of season_leaderboards.
     */
    distinct?: Season_leaderboardScalarFieldEnum | Season_leaderboardScalarFieldEnum[]
  }

  /**
   * season_leaderboard findFirstOrThrow
   */
  export type season_leaderboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the season_leaderboard
     */
    select?: season_leaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: season_leaderboardInclude<ExtArgs> | null
    /**
     * Filter, which season_leaderboard to fetch.
     */
    where?: season_leaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of season_leaderboards to fetch.
     */
    orderBy?: season_leaderboardOrderByWithRelationInput | season_leaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for season_leaderboards.
     */
    cursor?: season_leaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` season_leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` season_leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of season_leaderboards.
     */
    distinct?: Season_leaderboardScalarFieldEnum | Season_leaderboardScalarFieldEnum[]
  }

  /**
   * season_leaderboard findMany
   */
  export type season_leaderboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the season_leaderboard
     */
    select?: season_leaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: season_leaderboardInclude<ExtArgs> | null
    /**
     * Filter, which season_leaderboards to fetch.
     */
    where?: season_leaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of season_leaderboards to fetch.
     */
    orderBy?: season_leaderboardOrderByWithRelationInput | season_leaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing season_leaderboards.
     */
    cursor?: season_leaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` season_leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` season_leaderboards.
     */
    skip?: number
    distinct?: Season_leaderboardScalarFieldEnum | Season_leaderboardScalarFieldEnum[]
  }

  /**
   * season_leaderboard create
   */
  export type season_leaderboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the season_leaderboard
     */
    select?: season_leaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: season_leaderboardInclude<ExtArgs> | null
    /**
     * The data needed to create a season_leaderboard.
     */
    data: XOR<season_leaderboardCreateInput, season_leaderboardUncheckedCreateInput>
  }

  /**
   * season_leaderboard createMany
   */
  export type season_leaderboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many season_leaderboards.
     */
    data: season_leaderboardCreateManyInput | season_leaderboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * season_leaderboard createManyAndReturn
   */
  export type season_leaderboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the season_leaderboard
     */
    select?: season_leaderboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many season_leaderboards.
     */
    data: season_leaderboardCreateManyInput | season_leaderboardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: season_leaderboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * season_leaderboard update
   */
  export type season_leaderboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the season_leaderboard
     */
    select?: season_leaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: season_leaderboardInclude<ExtArgs> | null
    /**
     * The data needed to update a season_leaderboard.
     */
    data: XOR<season_leaderboardUpdateInput, season_leaderboardUncheckedUpdateInput>
    /**
     * Choose, which season_leaderboard to update.
     */
    where: season_leaderboardWhereUniqueInput
  }

  /**
   * season_leaderboard updateMany
   */
  export type season_leaderboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update season_leaderboards.
     */
    data: XOR<season_leaderboardUpdateManyMutationInput, season_leaderboardUncheckedUpdateManyInput>
    /**
     * Filter which season_leaderboards to update
     */
    where?: season_leaderboardWhereInput
  }

  /**
   * season_leaderboard upsert
   */
  export type season_leaderboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the season_leaderboard
     */
    select?: season_leaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: season_leaderboardInclude<ExtArgs> | null
    /**
     * The filter to search for the season_leaderboard to update in case it exists.
     */
    where: season_leaderboardWhereUniqueInput
    /**
     * In case the season_leaderboard found by the `where` argument doesn't exist, create a new season_leaderboard with this data.
     */
    create: XOR<season_leaderboardCreateInput, season_leaderboardUncheckedCreateInput>
    /**
     * In case the season_leaderboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<season_leaderboardUpdateInput, season_leaderboardUncheckedUpdateInput>
  }

  /**
   * season_leaderboard delete
   */
  export type season_leaderboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the season_leaderboard
     */
    select?: season_leaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: season_leaderboardInclude<ExtArgs> | null
    /**
     * Filter which season_leaderboard to delete.
     */
    where: season_leaderboardWhereUniqueInput
  }

  /**
   * season_leaderboard deleteMany
   */
  export type season_leaderboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which season_leaderboards to delete
     */
    where?: season_leaderboardWhereInput
  }

  /**
   * season_leaderboard without action
   */
  export type season_leaderboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the season_leaderboard
     */
    select?: season_leaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: season_leaderboardInclude<ExtArgs> | null
  }


  /**
   * Model user_quota_history
   */

  export type AggregateUser_quota_history = {
    _count: User_quota_historyCountAggregateOutputType | null
    _avg: User_quota_historyAvgAggregateOutputType | null
    _sum: User_quota_historySumAggregateOutputType | null
    _min: User_quota_historyMinAggregateOutputType | null
    _max: User_quota_historyMaxAggregateOutputType | null
  }

  export type User_quota_historyAvgAggregateOutputType = {
    quotaUsed: number | null
  }

  export type User_quota_historySumAggregateOutputType = {
    quotaUsed: number | null
  }

  export type User_quota_historyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    seasonId: string | null
    quotaUsed: number | null
    timestamp: Date | null
  }

  export type User_quota_historyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    seasonId: string | null
    quotaUsed: number | null
    timestamp: Date | null
  }

  export type User_quota_historyCountAggregateOutputType = {
    id: number
    userId: number
    seasonId: number
    quotaUsed: number
    timestamp: number
    _all: number
  }


  export type User_quota_historyAvgAggregateInputType = {
    quotaUsed?: true
  }

  export type User_quota_historySumAggregateInputType = {
    quotaUsed?: true
  }

  export type User_quota_historyMinAggregateInputType = {
    id?: true
    userId?: true
    seasonId?: true
    quotaUsed?: true
    timestamp?: true
  }

  export type User_quota_historyMaxAggregateInputType = {
    id?: true
    userId?: true
    seasonId?: true
    quotaUsed?: true
    timestamp?: true
  }

  export type User_quota_historyCountAggregateInputType = {
    id?: true
    userId?: true
    seasonId?: true
    quotaUsed?: true
    timestamp?: true
    _all?: true
  }

  export type User_quota_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_quota_history to aggregate.
     */
    where?: user_quota_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_quota_histories to fetch.
     */
    orderBy?: user_quota_historyOrderByWithRelationInput | user_quota_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_quota_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_quota_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_quota_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_quota_histories
    **/
    _count?: true | User_quota_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_quota_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_quota_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_quota_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_quota_historyMaxAggregateInputType
  }

  export type GetUser_quota_historyAggregateType<T extends User_quota_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_quota_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_quota_history[P]>
      : GetScalarType<T[P], AggregateUser_quota_history[P]>
  }




  export type user_quota_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_quota_historyWhereInput
    orderBy?: user_quota_historyOrderByWithAggregationInput | user_quota_historyOrderByWithAggregationInput[]
    by: User_quota_historyScalarFieldEnum[] | User_quota_historyScalarFieldEnum
    having?: user_quota_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_quota_historyCountAggregateInputType | true
    _avg?: User_quota_historyAvgAggregateInputType
    _sum?: User_quota_historySumAggregateInputType
    _min?: User_quota_historyMinAggregateInputType
    _max?: User_quota_historyMaxAggregateInputType
  }

  export type User_quota_historyGroupByOutputType = {
    id: string
    userId: string
    seasonId: string
    quotaUsed: number
    timestamp: Date
    _count: User_quota_historyCountAggregateOutputType | null
    _avg: User_quota_historyAvgAggregateOutputType | null
    _sum: User_quota_historySumAggregateOutputType | null
    _min: User_quota_historyMinAggregateOutputType | null
    _max: User_quota_historyMaxAggregateOutputType | null
  }

  type GetUser_quota_historyGroupByPayload<T extends user_quota_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_quota_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_quota_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_quota_historyGroupByOutputType[P]>
            : GetScalarType<T[P], User_quota_historyGroupByOutputType[P]>
        }
      >
    >


  export type user_quota_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    seasonId?: boolean
    quotaUsed?: boolean
    timestamp?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    season?: boolean | seasonsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_quota_history"]>

  export type user_quota_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    seasonId?: boolean
    quotaUsed?: boolean
    timestamp?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    season?: boolean | seasonsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_quota_history"]>

  export type user_quota_historySelectScalar = {
    id?: boolean
    userId?: boolean
    seasonId?: boolean
    quotaUsed?: boolean
    timestamp?: boolean
  }

  export type user_quota_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    season?: boolean | seasonsDefaultArgs<ExtArgs>
  }
  export type user_quota_historyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    season?: boolean | seasonsDefaultArgs<ExtArgs>
  }

  export type $user_quota_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_quota_history"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      season: Prisma.$seasonsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      seasonId: string
      quotaUsed: number
      timestamp: Date
    }, ExtArgs["result"]["user_quota_history"]>
    composites: {}
  }

  type user_quota_historyGetPayload<S extends boolean | null | undefined | user_quota_historyDefaultArgs> = $Result.GetResult<Prisma.$user_quota_historyPayload, S>

  type user_quota_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_quota_historyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_quota_historyCountAggregateInputType | true
    }

  export interface user_quota_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_quota_history'], meta: { name: 'user_quota_history' } }
    /**
     * Find zero or one User_quota_history that matches the filter.
     * @param {user_quota_historyFindUniqueArgs} args - Arguments to find a User_quota_history
     * @example
     * // Get one User_quota_history
     * const user_quota_history = await prisma.user_quota_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_quota_historyFindUniqueArgs>(args: SelectSubset<T, user_quota_historyFindUniqueArgs<ExtArgs>>): Prisma__user_quota_historyClient<$Result.GetResult<Prisma.$user_quota_historyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_quota_history that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_quota_historyFindUniqueOrThrowArgs} args - Arguments to find a User_quota_history
     * @example
     * // Get one User_quota_history
     * const user_quota_history = await prisma.user_quota_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_quota_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, user_quota_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_quota_historyClient<$Result.GetResult<Prisma.$user_quota_historyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_quota_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_quota_historyFindFirstArgs} args - Arguments to find a User_quota_history
     * @example
     * // Get one User_quota_history
     * const user_quota_history = await prisma.user_quota_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_quota_historyFindFirstArgs>(args?: SelectSubset<T, user_quota_historyFindFirstArgs<ExtArgs>>): Prisma__user_quota_historyClient<$Result.GetResult<Prisma.$user_quota_historyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_quota_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_quota_historyFindFirstOrThrowArgs} args - Arguments to find a User_quota_history
     * @example
     * // Get one User_quota_history
     * const user_quota_history = await prisma.user_quota_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_quota_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, user_quota_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_quota_historyClient<$Result.GetResult<Prisma.$user_quota_historyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_quota_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_quota_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_quota_histories
     * const user_quota_histories = await prisma.user_quota_history.findMany()
     * 
     * // Get first 10 User_quota_histories
     * const user_quota_histories = await prisma.user_quota_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_quota_historyWithIdOnly = await prisma.user_quota_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_quota_historyFindManyArgs>(args?: SelectSubset<T, user_quota_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_quota_historyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_quota_history.
     * @param {user_quota_historyCreateArgs} args - Arguments to create a User_quota_history.
     * @example
     * // Create one User_quota_history
     * const User_quota_history = await prisma.user_quota_history.create({
     *   data: {
     *     // ... data to create a User_quota_history
     *   }
     * })
     * 
     */
    create<T extends user_quota_historyCreateArgs>(args: SelectSubset<T, user_quota_historyCreateArgs<ExtArgs>>): Prisma__user_quota_historyClient<$Result.GetResult<Prisma.$user_quota_historyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_quota_histories.
     * @param {user_quota_historyCreateManyArgs} args - Arguments to create many User_quota_histories.
     * @example
     * // Create many User_quota_histories
     * const user_quota_history = await prisma.user_quota_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_quota_historyCreateManyArgs>(args?: SelectSubset<T, user_quota_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_quota_histories and returns the data saved in the database.
     * @param {user_quota_historyCreateManyAndReturnArgs} args - Arguments to create many User_quota_histories.
     * @example
     * // Create many User_quota_histories
     * const user_quota_history = await prisma.user_quota_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_quota_histories and only return the `id`
     * const user_quota_historyWithIdOnly = await prisma.user_quota_history.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_quota_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, user_quota_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_quota_historyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User_quota_history.
     * @param {user_quota_historyDeleteArgs} args - Arguments to delete one User_quota_history.
     * @example
     * // Delete one User_quota_history
     * const User_quota_history = await prisma.user_quota_history.delete({
     *   where: {
     *     // ... filter to delete one User_quota_history
     *   }
     * })
     * 
     */
    delete<T extends user_quota_historyDeleteArgs>(args: SelectSubset<T, user_quota_historyDeleteArgs<ExtArgs>>): Prisma__user_quota_historyClient<$Result.GetResult<Prisma.$user_quota_historyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_quota_history.
     * @param {user_quota_historyUpdateArgs} args - Arguments to update one User_quota_history.
     * @example
     * // Update one User_quota_history
     * const user_quota_history = await prisma.user_quota_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_quota_historyUpdateArgs>(args: SelectSubset<T, user_quota_historyUpdateArgs<ExtArgs>>): Prisma__user_quota_historyClient<$Result.GetResult<Prisma.$user_quota_historyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_quota_histories.
     * @param {user_quota_historyDeleteManyArgs} args - Arguments to filter User_quota_histories to delete.
     * @example
     * // Delete a few User_quota_histories
     * const { count } = await prisma.user_quota_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_quota_historyDeleteManyArgs>(args?: SelectSubset<T, user_quota_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_quota_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_quota_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_quota_histories
     * const user_quota_history = await prisma.user_quota_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_quota_historyUpdateManyArgs>(args: SelectSubset<T, user_quota_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_quota_history.
     * @param {user_quota_historyUpsertArgs} args - Arguments to update or create a User_quota_history.
     * @example
     * // Update or create a User_quota_history
     * const user_quota_history = await prisma.user_quota_history.upsert({
     *   create: {
     *     // ... data to create a User_quota_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_quota_history we want to update
     *   }
     * })
     */
    upsert<T extends user_quota_historyUpsertArgs>(args: SelectSubset<T, user_quota_historyUpsertArgs<ExtArgs>>): Prisma__user_quota_historyClient<$Result.GetResult<Prisma.$user_quota_historyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_quota_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_quota_historyCountArgs} args - Arguments to filter User_quota_histories to count.
     * @example
     * // Count the number of User_quota_histories
     * const count = await prisma.user_quota_history.count({
     *   where: {
     *     // ... the filter for the User_quota_histories we want to count
     *   }
     * })
    **/
    count<T extends user_quota_historyCountArgs>(
      args?: Subset<T, user_quota_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_quota_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_quota_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_quota_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_quota_historyAggregateArgs>(args: Subset<T, User_quota_historyAggregateArgs>): Prisma.PrismaPromise<GetUser_quota_historyAggregateType<T>>

    /**
     * Group by User_quota_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_quota_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_quota_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_quota_historyGroupByArgs['orderBy'] }
        : { orderBy?: user_quota_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_quota_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_quota_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_quota_history model
   */
  readonly fields: user_quota_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_quota_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_quota_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    season<T extends seasonsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, seasonsDefaultArgs<ExtArgs>>): Prisma__seasonsClient<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_quota_history model
   */ 
  interface user_quota_historyFieldRefs {
    readonly id: FieldRef<"user_quota_history", 'String'>
    readonly userId: FieldRef<"user_quota_history", 'String'>
    readonly seasonId: FieldRef<"user_quota_history", 'String'>
    readonly quotaUsed: FieldRef<"user_quota_history", 'Int'>
    readonly timestamp: FieldRef<"user_quota_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_quota_history findUnique
   */
  export type user_quota_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quota_history
     */
    select?: user_quota_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_quota_historyInclude<ExtArgs> | null
    /**
     * Filter, which user_quota_history to fetch.
     */
    where: user_quota_historyWhereUniqueInput
  }

  /**
   * user_quota_history findUniqueOrThrow
   */
  export type user_quota_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quota_history
     */
    select?: user_quota_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_quota_historyInclude<ExtArgs> | null
    /**
     * Filter, which user_quota_history to fetch.
     */
    where: user_quota_historyWhereUniqueInput
  }

  /**
   * user_quota_history findFirst
   */
  export type user_quota_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quota_history
     */
    select?: user_quota_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_quota_historyInclude<ExtArgs> | null
    /**
     * Filter, which user_quota_history to fetch.
     */
    where?: user_quota_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_quota_histories to fetch.
     */
    orderBy?: user_quota_historyOrderByWithRelationInput | user_quota_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_quota_histories.
     */
    cursor?: user_quota_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_quota_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_quota_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_quota_histories.
     */
    distinct?: User_quota_historyScalarFieldEnum | User_quota_historyScalarFieldEnum[]
  }

  /**
   * user_quota_history findFirstOrThrow
   */
  export type user_quota_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quota_history
     */
    select?: user_quota_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_quota_historyInclude<ExtArgs> | null
    /**
     * Filter, which user_quota_history to fetch.
     */
    where?: user_quota_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_quota_histories to fetch.
     */
    orderBy?: user_quota_historyOrderByWithRelationInput | user_quota_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_quota_histories.
     */
    cursor?: user_quota_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_quota_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_quota_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_quota_histories.
     */
    distinct?: User_quota_historyScalarFieldEnum | User_quota_historyScalarFieldEnum[]
  }

  /**
   * user_quota_history findMany
   */
  export type user_quota_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quota_history
     */
    select?: user_quota_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_quota_historyInclude<ExtArgs> | null
    /**
     * Filter, which user_quota_histories to fetch.
     */
    where?: user_quota_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_quota_histories to fetch.
     */
    orderBy?: user_quota_historyOrderByWithRelationInput | user_quota_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_quota_histories.
     */
    cursor?: user_quota_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_quota_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_quota_histories.
     */
    skip?: number
    distinct?: User_quota_historyScalarFieldEnum | User_quota_historyScalarFieldEnum[]
  }

  /**
   * user_quota_history create
   */
  export type user_quota_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quota_history
     */
    select?: user_quota_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_quota_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a user_quota_history.
     */
    data: XOR<user_quota_historyCreateInput, user_quota_historyUncheckedCreateInput>
  }

  /**
   * user_quota_history createMany
   */
  export type user_quota_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_quota_histories.
     */
    data: user_quota_historyCreateManyInput | user_quota_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_quota_history createManyAndReturn
   */
  export type user_quota_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quota_history
     */
    select?: user_quota_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many user_quota_histories.
     */
    data: user_quota_historyCreateManyInput | user_quota_historyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_quota_historyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_quota_history update
   */
  export type user_quota_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quota_history
     */
    select?: user_quota_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_quota_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a user_quota_history.
     */
    data: XOR<user_quota_historyUpdateInput, user_quota_historyUncheckedUpdateInput>
    /**
     * Choose, which user_quota_history to update.
     */
    where: user_quota_historyWhereUniqueInput
  }

  /**
   * user_quota_history updateMany
   */
  export type user_quota_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_quota_histories.
     */
    data: XOR<user_quota_historyUpdateManyMutationInput, user_quota_historyUncheckedUpdateManyInput>
    /**
     * Filter which user_quota_histories to update
     */
    where?: user_quota_historyWhereInput
  }

  /**
   * user_quota_history upsert
   */
  export type user_quota_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quota_history
     */
    select?: user_quota_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_quota_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the user_quota_history to update in case it exists.
     */
    where: user_quota_historyWhereUniqueInput
    /**
     * In case the user_quota_history found by the `where` argument doesn't exist, create a new user_quota_history with this data.
     */
    create: XOR<user_quota_historyCreateInput, user_quota_historyUncheckedCreateInput>
    /**
     * In case the user_quota_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_quota_historyUpdateInput, user_quota_historyUncheckedUpdateInput>
  }

  /**
   * user_quota_history delete
   */
  export type user_quota_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quota_history
     */
    select?: user_quota_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_quota_historyInclude<ExtArgs> | null
    /**
     * Filter which user_quota_history to delete.
     */
    where: user_quota_historyWhereUniqueInput
  }

  /**
   * user_quota_history deleteMany
   */
  export type user_quota_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_quota_histories to delete
     */
    where?: user_quota_historyWhereInput
  }

  /**
   * user_quota_history without action
   */
  export type user_quota_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quota_history
     */
    select?: user_quota_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_quota_historyInclude<ExtArgs> | null
  }


  /**
   * Model websocket_connections
   */

  export type AggregateWebsocket_connections = {
    _count: Websocket_connectionsCountAggregateOutputType | null
    _min: Websocket_connectionsMinAggregateOutputType | null
    _max: Websocket_connectionsMaxAggregateOutputType | null
  }

  export type Websocket_connectionsMinAggregateOutputType = {
    id: string | null
    connectionId: string | null
    userId: string | null
    gameId: string | null
    connectedAt: Date | null
    lastPing: Date | null
    isActive: boolean | null
  }

  export type Websocket_connectionsMaxAggregateOutputType = {
    id: string | null
    connectionId: string | null
    userId: string | null
    gameId: string | null
    connectedAt: Date | null
    lastPing: Date | null
    isActive: boolean | null
  }

  export type Websocket_connectionsCountAggregateOutputType = {
    id: number
    connectionId: number
    userId: number
    gameId: number
    connectedAt: number
    lastPing: number
    isActive: number
    _all: number
  }


  export type Websocket_connectionsMinAggregateInputType = {
    id?: true
    connectionId?: true
    userId?: true
    gameId?: true
    connectedAt?: true
    lastPing?: true
    isActive?: true
  }

  export type Websocket_connectionsMaxAggregateInputType = {
    id?: true
    connectionId?: true
    userId?: true
    gameId?: true
    connectedAt?: true
    lastPing?: true
    isActive?: true
  }

  export type Websocket_connectionsCountAggregateInputType = {
    id?: true
    connectionId?: true
    userId?: true
    gameId?: true
    connectedAt?: true
    lastPing?: true
    isActive?: true
    _all?: true
  }

  export type Websocket_connectionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which websocket_connections to aggregate.
     */
    where?: websocket_connectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of websocket_connections to fetch.
     */
    orderBy?: websocket_connectionsOrderByWithRelationInput | websocket_connectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: websocket_connectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` websocket_connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` websocket_connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned websocket_connections
    **/
    _count?: true | Websocket_connectionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Websocket_connectionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Websocket_connectionsMaxAggregateInputType
  }

  export type GetWebsocket_connectionsAggregateType<T extends Websocket_connectionsAggregateArgs> = {
        [P in keyof T & keyof AggregateWebsocket_connections]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebsocket_connections[P]>
      : GetScalarType<T[P], AggregateWebsocket_connections[P]>
  }




  export type websocket_connectionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: websocket_connectionsWhereInput
    orderBy?: websocket_connectionsOrderByWithAggregationInput | websocket_connectionsOrderByWithAggregationInput[]
    by: Websocket_connectionsScalarFieldEnum[] | Websocket_connectionsScalarFieldEnum
    having?: websocket_connectionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Websocket_connectionsCountAggregateInputType | true
    _min?: Websocket_connectionsMinAggregateInputType
    _max?: Websocket_connectionsMaxAggregateInputType
  }

  export type Websocket_connectionsGroupByOutputType = {
    id: string
    connectionId: string
    userId: string
    gameId: string | null
    connectedAt: Date
    lastPing: Date
    isActive: boolean
    _count: Websocket_connectionsCountAggregateOutputType | null
    _min: Websocket_connectionsMinAggregateOutputType | null
    _max: Websocket_connectionsMaxAggregateOutputType | null
  }

  type GetWebsocket_connectionsGroupByPayload<T extends websocket_connectionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Websocket_connectionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Websocket_connectionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Websocket_connectionsGroupByOutputType[P]>
            : GetScalarType<T[P], Websocket_connectionsGroupByOutputType[P]>
        }
      >
    >


  export type websocket_connectionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    connectionId?: boolean
    userId?: boolean
    gameId?: boolean
    connectedAt?: boolean
    lastPing?: boolean
    isActive?: boolean
    game?: boolean | websocket_connections$gameArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["websocket_connections"]>

  export type websocket_connectionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    connectionId?: boolean
    userId?: boolean
    gameId?: boolean
    connectedAt?: boolean
    lastPing?: boolean
    isActive?: boolean
    game?: boolean | websocket_connections$gameArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["websocket_connections"]>

  export type websocket_connectionsSelectScalar = {
    id?: boolean
    connectionId?: boolean
    userId?: boolean
    gameId?: boolean
    connectedAt?: boolean
    lastPing?: boolean
    isActive?: boolean
  }

  export type websocket_connectionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | websocket_connections$gameArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type websocket_connectionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | websocket_connections$gameArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $websocket_connectionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "websocket_connections"
    objects: {
      game: Prisma.$gamesPayload<ExtArgs> | null
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      connectionId: string
      userId: string
      gameId: string | null
      connectedAt: Date
      lastPing: Date
      isActive: boolean
    }, ExtArgs["result"]["websocket_connections"]>
    composites: {}
  }

  type websocket_connectionsGetPayload<S extends boolean | null | undefined | websocket_connectionsDefaultArgs> = $Result.GetResult<Prisma.$websocket_connectionsPayload, S>

  type websocket_connectionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<websocket_connectionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Websocket_connectionsCountAggregateInputType | true
    }

  export interface websocket_connectionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['websocket_connections'], meta: { name: 'websocket_connections' } }
    /**
     * Find zero or one Websocket_connections that matches the filter.
     * @param {websocket_connectionsFindUniqueArgs} args - Arguments to find a Websocket_connections
     * @example
     * // Get one Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends websocket_connectionsFindUniqueArgs>(args: SelectSubset<T, websocket_connectionsFindUniqueArgs<ExtArgs>>): Prisma__websocket_connectionsClient<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Websocket_connections that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {websocket_connectionsFindUniqueOrThrowArgs} args - Arguments to find a Websocket_connections
     * @example
     * // Get one Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends websocket_connectionsFindUniqueOrThrowArgs>(args: SelectSubset<T, websocket_connectionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__websocket_connectionsClient<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Websocket_connections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {websocket_connectionsFindFirstArgs} args - Arguments to find a Websocket_connections
     * @example
     * // Get one Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends websocket_connectionsFindFirstArgs>(args?: SelectSubset<T, websocket_connectionsFindFirstArgs<ExtArgs>>): Prisma__websocket_connectionsClient<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Websocket_connections that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {websocket_connectionsFindFirstOrThrowArgs} args - Arguments to find a Websocket_connections
     * @example
     * // Get one Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends websocket_connectionsFindFirstOrThrowArgs>(args?: SelectSubset<T, websocket_connectionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__websocket_connectionsClient<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Websocket_connections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {websocket_connectionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.findMany()
     * 
     * // Get first 10 Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const websocket_connectionsWithIdOnly = await prisma.websocket_connections.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends websocket_connectionsFindManyArgs>(args?: SelectSubset<T, websocket_connectionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Websocket_connections.
     * @param {websocket_connectionsCreateArgs} args - Arguments to create a Websocket_connections.
     * @example
     * // Create one Websocket_connections
     * const Websocket_connections = await prisma.websocket_connections.create({
     *   data: {
     *     // ... data to create a Websocket_connections
     *   }
     * })
     * 
     */
    create<T extends websocket_connectionsCreateArgs>(args: SelectSubset<T, websocket_connectionsCreateArgs<ExtArgs>>): Prisma__websocket_connectionsClient<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Websocket_connections.
     * @param {websocket_connectionsCreateManyArgs} args - Arguments to create many Websocket_connections.
     * @example
     * // Create many Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends websocket_connectionsCreateManyArgs>(args?: SelectSubset<T, websocket_connectionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Websocket_connections and returns the data saved in the database.
     * @param {websocket_connectionsCreateManyAndReturnArgs} args - Arguments to create many Websocket_connections.
     * @example
     * // Create many Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Websocket_connections and only return the `id`
     * const websocket_connectionsWithIdOnly = await prisma.websocket_connections.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends websocket_connectionsCreateManyAndReturnArgs>(args?: SelectSubset<T, websocket_connectionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Websocket_connections.
     * @param {websocket_connectionsDeleteArgs} args - Arguments to delete one Websocket_connections.
     * @example
     * // Delete one Websocket_connections
     * const Websocket_connections = await prisma.websocket_connections.delete({
     *   where: {
     *     // ... filter to delete one Websocket_connections
     *   }
     * })
     * 
     */
    delete<T extends websocket_connectionsDeleteArgs>(args: SelectSubset<T, websocket_connectionsDeleteArgs<ExtArgs>>): Prisma__websocket_connectionsClient<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Websocket_connections.
     * @param {websocket_connectionsUpdateArgs} args - Arguments to update one Websocket_connections.
     * @example
     * // Update one Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends websocket_connectionsUpdateArgs>(args: SelectSubset<T, websocket_connectionsUpdateArgs<ExtArgs>>): Prisma__websocket_connectionsClient<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Websocket_connections.
     * @param {websocket_connectionsDeleteManyArgs} args - Arguments to filter Websocket_connections to delete.
     * @example
     * // Delete a few Websocket_connections
     * const { count } = await prisma.websocket_connections.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends websocket_connectionsDeleteManyArgs>(args?: SelectSubset<T, websocket_connectionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Websocket_connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {websocket_connectionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends websocket_connectionsUpdateManyArgs>(args: SelectSubset<T, websocket_connectionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Websocket_connections.
     * @param {websocket_connectionsUpsertArgs} args - Arguments to update or create a Websocket_connections.
     * @example
     * // Update or create a Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.upsert({
     *   create: {
     *     // ... data to create a Websocket_connections
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Websocket_connections we want to update
     *   }
     * })
     */
    upsert<T extends websocket_connectionsUpsertArgs>(args: SelectSubset<T, websocket_connectionsUpsertArgs<ExtArgs>>): Prisma__websocket_connectionsClient<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Websocket_connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {websocket_connectionsCountArgs} args - Arguments to filter Websocket_connections to count.
     * @example
     * // Count the number of Websocket_connections
     * const count = await prisma.websocket_connections.count({
     *   where: {
     *     // ... the filter for the Websocket_connections we want to count
     *   }
     * })
    **/
    count<T extends websocket_connectionsCountArgs>(
      args?: Subset<T, websocket_connectionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Websocket_connectionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Websocket_connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Websocket_connectionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Websocket_connectionsAggregateArgs>(args: Subset<T, Websocket_connectionsAggregateArgs>): Prisma.PrismaPromise<GetWebsocket_connectionsAggregateType<T>>

    /**
     * Group by Websocket_connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {websocket_connectionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends websocket_connectionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: websocket_connectionsGroupByArgs['orderBy'] }
        : { orderBy?: websocket_connectionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, websocket_connectionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebsocket_connectionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the websocket_connections model
   */
  readonly fields: websocket_connectionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for websocket_connections.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__websocket_connectionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends websocket_connections$gameArgs<ExtArgs> = {}>(args?: Subset<T, websocket_connections$gameArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the websocket_connections model
   */ 
  interface websocket_connectionsFieldRefs {
    readonly id: FieldRef<"websocket_connections", 'String'>
    readonly connectionId: FieldRef<"websocket_connections", 'String'>
    readonly userId: FieldRef<"websocket_connections", 'String'>
    readonly gameId: FieldRef<"websocket_connections", 'String'>
    readonly connectedAt: FieldRef<"websocket_connections", 'DateTime'>
    readonly lastPing: FieldRef<"websocket_connections", 'DateTime'>
    readonly isActive: FieldRef<"websocket_connections", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * websocket_connections findUnique
   */
  export type websocket_connectionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which websocket_connections to fetch.
     */
    where: websocket_connectionsWhereUniqueInput
  }

  /**
   * websocket_connections findUniqueOrThrow
   */
  export type websocket_connectionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which websocket_connections to fetch.
     */
    where: websocket_connectionsWhereUniqueInput
  }

  /**
   * websocket_connections findFirst
   */
  export type websocket_connectionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which websocket_connections to fetch.
     */
    where?: websocket_connectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of websocket_connections to fetch.
     */
    orderBy?: websocket_connectionsOrderByWithRelationInput | websocket_connectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for websocket_connections.
     */
    cursor?: websocket_connectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` websocket_connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` websocket_connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of websocket_connections.
     */
    distinct?: Websocket_connectionsScalarFieldEnum | Websocket_connectionsScalarFieldEnum[]
  }

  /**
   * websocket_connections findFirstOrThrow
   */
  export type websocket_connectionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which websocket_connections to fetch.
     */
    where?: websocket_connectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of websocket_connections to fetch.
     */
    orderBy?: websocket_connectionsOrderByWithRelationInput | websocket_connectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for websocket_connections.
     */
    cursor?: websocket_connectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` websocket_connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` websocket_connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of websocket_connections.
     */
    distinct?: Websocket_connectionsScalarFieldEnum | Websocket_connectionsScalarFieldEnum[]
  }

  /**
   * websocket_connections findMany
   */
  export type websocket_connectionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which websocket_connections to fetch.
     */
    where?: websocket_connectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of websocket_connections to fetch.
     */
    orderBy?: websocket_connectionsOrderByWithRelationInput | websocket_connectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing websocket_connections.
     */
    cursor?: websocket_connectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` websocket_connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` websocket_connections.
     */
    skip?: number
    distinct?: Websocket_connectionsScalarFieldEnum | Websocket_connectionsScalarFieldEnum[]
  }

  /**
   * websocket_connections create
   */
  export type websocket_connectionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    /**
     * The data needed to create a websocket_connections.
     */
    data: XOR<websocket_connectionsCreateInput, websocket_connectionsUncheckedCreateInput>
  }

  /**
   * websocket_connections createMany
   */
  export type websocket_connectionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many websocket_connections.
     */
    data: websocket_connectionsCreateManyInput | websocket_connectionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * websocket_connections createManyAndReturn
   */
  export type websocket_connectionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many websocket_connections.
     */
    data: websocket_connectionsCreateManyInput | websocket_connectionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * websocket_connections update
   */
  export type websocket_connectionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    /**
     * The data needed to update a websocket_connections.
     */
    data: XOR<websocket_connectionsUpdateInput, websocket_connectionsUncheckedUpdateInput>
    /**
     * Choose, which websocket_connections to update.
     */
    where: websocket_connectionsWhereUniqueInput
  }

  /**
   * websocket_connections updateMany
   */
  export type websocket_connectionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update websocket_connections.
     */
    data: XOR<websocket_connectionsUpdateManyMutationInput, websocket_connectionsUncheckedUpdateManyInput>
    /**
     * Filter which websocket_connections to update
     */
    where?: websocket_connectionsWhereInput
  }

  /**
   * websocket_connections upsert
   */
  export type websocket_connectionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    /**
     * The filter to search for the websocket_connections to update in case it exists.
     */
    where: websocket_connectionsWhereUniqueInput
    /**
     * In case the websocket_connections found by the `where` argument doesn't exist, create a new websocket_connections with this data.
     */
    create: XOR<websocket_connectionsCreateInput, websocket_connectionsUncheckedCreateInput>
    /**
     * In case the websocket_connections was found with the provided `where` argument, update it with this data.
     */
    update: XOR<websocket_connectionsUpdateInput, websocket_connectionsUncheckedUpdateInput>
  }

  /**
   * websocket_connections delete
   */
  export type websocket_connectionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    /**
     * Filter which websocket_connections to delete.
     */
    where: websocket_connectionsWhereUniqueInput
  }

  /**
   * websocket_connections deleteMany
   */
  export type websocket_connectionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which websocket_connections to delete
     */
    where?: websocket_connectionsWhereInput
  }

  /**
   * websocket_connections.game
   */
  export type websocket_connections$gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    where?: gamesWhereInput
  }

  /**
   * websocket_connections without action
   */
  export type websocket_connectionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AnalysesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    boardState: 'boardState',
    dice: 'dice',
    move: 'move',
    bestMove: 'bestMove',
    equity: 'equity',
    pr: 'pr',
    explanation: 'explanation',
    alternatives: 'alternatives',
    analysisType: 'analysisType',
    createdAt: 'createdAt'
  };

  export type AnalysesScalarFieldEnum = (typeof AnalysesScalarFieldEnum)[keyof typeof AnalysesScalarFieldEnum]


  export const AnalysisQuotaScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    count: 'count',
    extraQuota: 'extraQuota',
    initialFree: 'initialFree'
  };

  export type AnalysisQuotaScalarFieldEnum = (typeof AnalysisQuotaScalarFieldEnum)[keyof typeof AnalysisQuotaScalarFieldEnum]


  export const IAQuotaScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    dailyQuota: 'dailyQuota',
    premiumQuota: 'premiumQuota',
    extrasUsed: 'extrasUsed',
    resetAt: 'resetAt'
  };

  export type IAQuotaScalarFieldEnum = (typeof IAQuotaScalarFieldEnum)[keyof typeof IAQuotaScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenHash: 'tokenHash',
    jti: 'jti',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const Chat_messagesScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    userId: 'userId',
    message: 'message',
    messageType: 'messageType',
    createdAt: 'createdAt'
  };

  export type Chat_messagesScalarFieldEnum = (typeof Chat_messagesScalarFieldEnum)[keyof typeof Chat_messagesScalarFieldEnum]


  export const Game_movesScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    userId: 'userId',
    player: 'player',
    dice: 'dice',
    move: 'move',
    fromPoint: 'fromPoint',
    toPoint: 'toPoint',
    equity: 'equity',
    pr: 'pr',
    thinkingTime: 'thinkingTime',
    createdAt: 'createdAt'
  };

  export type Game_movesScalarFieldEnum = (typeof Game_movesScalarFieldEnum)[keyof typeof Game_movesScalarFieldEnum]


  export const SubscriptionsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    stripe_subscription_id: 'stripe_subscription_id',
    stripe_customer_id: 'stripe_customer_id',
    plan: 'plan',
    status: 'status',
    current_period_start: 'current_period_start',
    current_period_end: 'current_period_end',
    cancel_at_period_end: 'cancel_at_period_end',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionsScalarFieldEnum = (typeof SubscriptionsScalarFieldEnum)[keyof typeof SubscriptionsScalarFieldEnum]


  export const Tournament_participantsScalarFieldEnum: {
    id: 'id',
    tournament_id: 'tournament_id',
    user_id: 'user_id',
    registered_at: 'registered_at',
    current_position: 'current_position',
    eliminated_at: 'eliminated_at'
  };

  export type Tournament_participantsScalarFieldEnum = (typeof Tournament_participantsScalarFieldEnum)[keyof typeof Tournament_participantsScalarFieldEnum]


  export const Tournament_matchesScalarFieldEnum: {
    id: 'id',
    tournamentId: 'tournamentId',
    round: 'round',
    matchNumber: 'matchNumber',
    whiteParticipantId: 'whiteParticipantId',
    blackParticipantId: 'blackParticipantId',
    winnerParticipantId: 'winnerParticipantId',
    status: 'status',
    scheduledAt: 'scheduledAt',
    startedAt: 'startedAt',
    finishedAt: 'finishedAt',
    gameId: 'gameId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Tournament_matchesScalarFieldEnum = (typeof Tournament_matchesScalarFieldEnum)[keyof typeof Tournament_matchesScalarFieldEnum]


  export const TournamentsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    entryFee: 'entryFee',
    prizePool: 'prizePool',
    maxPlayers: 'maxPlayers',
    status: 'status',
    startTime: 'startTime',
    endTime: 'endTime',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type TournamentsScalarFieldEnum = (typeof TournamentsScalarFieldEnum)[keyof typeof TournamentsScalarFieldEnum]


  export const User_analyticsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    date: 'date',
    games_played: 'games_played',
    games_won: 'games_won',
    analyses_completed: 'analyses_completed',
    time_played: 'time_played',
    avg_equity: 'avg_equity',
    elo_change: 'elo_change',
    claude_requests_today: 'claude_requests_today',
    claude_requests_this_month: 'claude_requests_this_month',
    claude_quota_remaining: 'claude_quota_remaining',
    chatgpt_requests_today: 'chatgpt_requests_today',
    chatgpt_requests_this_month: 'chatgpt_requests_this_month',
    gurubot_requests_today: 'gurubot_requests_today',
    gurubot_requests_this_month: 'gurubot_requests_this_month',
    gurubot_quota_remaining: 'gurubot_quota_remaining',
    easybot_requests_today: 'easybot_requests_today',
    createdAt: 'createdAt'
  };

  export type User_analyticsScalarFieldEnum = (typeof User_analyticsScalarFieldEnum)[keyof typeof User_analyticsScalarFieldEnum]


  export const Game_analysesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    game_id: 'game_id',
    analysis_report: 'analysis_report',
    ai_services_used: 'ai_services_used',
    created_at: 'created_at'
  };

  export type Game_analysesScalarFieldEnum = (typeof Game_analysesScalarFieldEnum)[keyof typeof Game_analysesScalarFieldEnum]


  export const GamesScalarFieldEnum: {
    id: 'id',
    whitePlayerId: 'whitePlayerId',
    blackPlayerId: 'blackPlayerId',
    tournamentId: 'tournamentId',
    gameMode: 'gameMode',
    status: 'status',
    stake: 'stake',
    winner: 'winner',
    drawOfferedBy: 'drawOfferedBy',
    whiteScore: 'whiteScore',
    blackScore: 'blackScore',
    boardState: 'boardState',
    currentPlayer: 'currentPlayer',
    dice: 'dice',
    cubeLevel: 'cubeLevel',
    cubeOwner: 'cubeOwner',
    matchLength: 'matchLength',
    doubleOfferedBy: 'doubleOfferedBy',
    doublePending: 'doublePending',
    cubeHistory: 'cubeHistory',
    timeControlPreset: 'timeControlPreset',
    timeControlTotalMs: 'timeControlTotalMs',
    timeControlIncrementMs: 'timeControlIncrementMs',
    timeControlDelayMs: 'timeControlDelayMs',
    whiteTimeRemainingMs: 'whiteTimeRemainingMs',
    blackTimeRemainingMs: 'blackTimeRemainingMs',
    activeTimer: 'activeTimer',
    timerUpdatedAt: 'timerUpdatedAt',
    createdAt: 'createdAt',
    finishedAt: 'finishedAt',
    updatedAt: 'updatedAt',
    resignationType: 'resignationType'
  };

  export type GamesScalarFieldEnum = (typeof GamesScalarFieldEnum)[keyof typeof GamesScalarFieldEnum]


  export const GameSessionScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    userId: 'userId',
    resumeTokenHash: 'resumeTokenHash',
    lastAckSequence: 'lastAckSequence',
    lastHeartbeatAt: 'lastHeartbeatAt',
    issuedAt: 'issuedAt',
    expiresAt: 'expiresAt',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type GameSessionScalarFieldEnum = (typeof GameSessionScalarFieldEnum)[keyof typeof GameSessionScalarFieldEnum]


  export const GameEventScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    sequence: 'sequence',
    type: 'type',
    payload: 'payload',
    createdAt: 'createdAt'
  };

  export type GameEventScalarFieldEnum = (typeof GameEventScalarFieldEnum)[keyof typeof GameEventScalarFieldEnum]


  export const MatchesScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    length: 'length',
    rules: 'rules',
    state: 'state',
    crawfordUsed: 'crawfordUsed',
    cubeHistory: 'cubeHistory',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatchesScalarFieldEnum = (typeof MatchesScalarFieldEnum)[keyof typeof MatchesScalarFieldEnum]


  export const User_learning_progressScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    rule_key: 'rule_key',
    viewed_at: 'viewed_at',
    completed: 'completed',
    completed_at: 'completed_at',
    score: 'score',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type User_learning_progressScalarFieldEnum = (typeof User_learning_progressScalarFieldEnum)[keyof typeof User_learning_progressScalarFieldEnum]


  export const User_achievementsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    achievement: 'achievement',
    description: 'description',
    icon: 'icon',
    unlocked_at: 'unlocked_at',
    category: 'category'
  };

  export type User_achievementsScalarFieldEnum = (typeof User_achievementsScalarFieldEnum)[keyof typeof User_achievementsScalarFieldEnum]


  export const User_preferencesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    language: 'language',
    theme: 'theme',
    sound: 'sound',
    notifications: 'notifications',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type User_preferencesScalarFieldEnum = (typeof User_preferencesScalarFieldEnum)[keyof typeof User_preferencesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    username: 'username',
    firstName: 'firstName',
    lastName: 'lastName',
    avatarUrl: 'avatarUrl',
    country: 'country',
    eloRating: 'eloRating',
    gamesPlayed: 'gamesPlayed',
    gamesWon: 'gamesWon',
    winRate: 'winRate',
    currentStreak: 'currentStreak',
    bestStreak: 'bestStreak',
    subscriptionType: 'subscriptionType',
    subscriptionExpiresAt: 'subscriptionExpiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SeasonsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SeasonsScalarFieldEnum = (typeof SeasonsScalarFieldEnum)[keyof typeof SeasonsScalarFieldEnum]


  export const User_season_statsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    seasonId: 'seasonId',
    elo: 'elo',
    winrate: 'winrate',
    gamesPlayed: 'gamesPlayed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type User_season_statsScalarFieldEnum = (typeof User_season_statsScalarFieldEnum)[keyof typeof User_season_statsScalarFieldEnum]


  export const Season_leaderboardScalarFieldEnum: {
    id: 'id',
    seasonId: 'seasonId',
    userId: 'userId',
    rankGlobal: 'rankGlobal',
    rankCountry: 'rankCountry',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Season_leaderboardScalarFieldEnum = (typeof Season_leaderboardScalarFieldEnum)[keyof typeof Season_leaderboardScalarFieldEnum]


  export const User_quota_historyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    seasonId: 'seasonId',
    quotaUsed: 'quotaUsed',
    timestamp: 'timestamp'
  };

  export type User_quota_historyScalarFieldEnum = (typeof User_quota_historyScalarFieldEnum)[keyof typeof User_quota_historyScalarFieldEnum]


  export const Websocket_connectionsScalarFieldEnum: {
    id: 'id',
    connectionId: 'connectionId',
    userId: 'userId',
    gameId: 'gameId',
    connectedAt: 'connectedAt',
    lastPing: 'lastPing',
    isActive: 'isActive'
  };

  export type Websocket_connectionsScalarFieldEnum = (typeof Websocket_connectionsScalarFieldEnum)[keyof typeof Websocket_connectionsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'AnalysisType'
   */
  export type EnumAnalysisTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnalysisType'>
    


  /**
   * Reference to a field of type 'AnalysisType[]'
   */
  export type ListEnumAnalysisTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnalysisType[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType[]'>
    


  /**
   * Reference to a field of type 'Player'
   */
  export type EnumPlayerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Player'>
    


  /**
   * Reference to a field of type 'Player[]'
   */
  export type ListEnumPlayerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Player[]'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan'
   */
  export type EnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan[]'
   */
  export type ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'TournamentMatchStatus'
   */
  export type EnumTournamentMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TournamentMatchStatus'>
    


  /**
   * Reference to a field of type 'TournamentMatchStatus[]'
   */
  export type ListEnumTournamentMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TournamentMatchStatus[]'>
    


  /**
   * Reference to a field of type 'TournamentStatus'
   */
  export type EnumTournamentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TournamentStatus'>
    


  /**
   * Reference to a field of type 'TournamentStatus[]'
   */
  export type ListEnumTournamentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TournamentStatus[]'>
    


  /**
   * Reference to a field of type 'GameMode'
   */
  export type EnumGameModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameMode'>
    


  /**
   * Reference to a field of type 'GameMode[]'
   */
  export type ListEnumGameModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameMode[]'>
    


  /**
   * Reference to a field of type 'GameStatus'
   */
  export type EnumGameStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameStatus'>
    


  /**
   * Reference to a field of type 'GameStatus[]'
   */
  export type ListEnumGameStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameStatus[]'>
    


  /**
   * Reference to a field of type 'TimeControlPreset'
   */
  export type EnumTimeControlPresetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TimeControlPreset'>
    


  /**
   * Reference to a field of type 'TimeControlPreset[]'
   */
  export type ListEnumTimeControlPresetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TimeControlPreset[]'>
    


  /**
   * Reference to a field of type 'ResignationType'
   */
  export type EnumResignationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResignationType'>
    


  /**
   * Reference to a field of type 'ResignationType[]'
   */
  export type ListEnumResignationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResignationType[]'>
    


  /**
   * Reference to a field of type 'MatchState'
   */
  export type EnumMatchStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchState'>
    


  /**
   * Reference to a field of type 'MatchState[]'
   */
  export type ListEnumMatchStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchState[]'>
    


  /**
   * Reference to a field of type 'SubscriptionType'
   */
  export type EnumSubscriptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionType'>
    


  /**
   * Reference to a field of type 'SubscriptionType[]'
   */
  export type ListEnumSubscriptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionType[]'>
    
  /**
   * Deep Input Types
   */


  export type analysesWhereInput = {
    AND?: analysesWhereInput | analysesWhereInput[]
    OR?: analysesWhereInput[]
    NOT?: analysesWhereInput | analysesWhereInput[]
    id?: StringFilter<"analyses"> | string
    userId?: StringFilter<"analyses"> | string
    boardState?: StringFilter<"analyses"> | string
    dice?: IntNullableListFilter<"analyses">
    move?: StringFilter<"analyses"> | string
    bestMove?: StringFilter<"analyses"> | string
    equity?: FloatFilter<"analyses"> | number
    pr?: FloatFilter<"analyses"> | number
    explanation?: StringFilter<"analyses"> | string
    alternatives?: JsonFilter<"analyses">
    analysisType?: EnumAnalysisTypeFilter<"analyses"> | $Enums.AnalysisType
    createdAt?: DateTimeFilter<"analyses"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type analysesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    boardState?: SortOrder
    dice?: SortOrder
    move?: SortOrder
    bestMove?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    explanation?: SortOrder
    alternatives?: SortOrder
    analysisType?: SortOrder
    createdAt?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type analysesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: analysesWhereInput | analysesWhereInput[]
    OR?: analysesWhereInput[]
    NOT?: analysesWhereInput | analysesWhereInput[]
    userId?: StringFilter<"analyses"> | string
    boardState?: StringFilter<"analyses"> | string
    dice?: IntNullableListFilter<"analyses">
    move?: StringFilter<"analyses"> | string
    bestMove?: StringFilter<"analyses"> | string
    equity?: FloatFilter<"analyses"> | number
    pr?: FloatFilter<"analyses"> | number
    explanation?: StringFilter<"analyses"> | string
    alternatives?: JsonFilter<"analyses">
    analysisType?: EnumAnalysisTypeFilter<"analyses"> | $Enums.AnalysisType
    createdAt?: DateTimeFilter<"analyses"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type analysesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    boardState?: SortOrder
    dice?: SortOrder
    move?: SortOrder
    bestMove?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    explanation?: SortOrder
    alternatives?: SortOrder
    analysisType?: SortOrder
    createdAt?: SortOrder
    _count?: analysesCountOrderByAggregateInput
    _avg?: analysesAvgOrderByAggregateInput
    _max?: analysesMaxOrderByAggregateInput
    _min?: analysesMinOrderByAggregateInput
    _sum?: analysesSumOrderByAggregateInput
  }

  export type analysesScalarWhereWithAggregatesInput = {
    AND?: analysesScalarWhereWithAggregatesInput | analysesScalarWhereWithAggregatesInput[]
    OR?: analysesScalarWhereWithAggregatesInput[]
    NOT?: analysesScalarWhereWithAggregatesInput | analysesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"analyses"> | string
    userId?: StringWithAggregatesFilter<"analyses"> | string
    boardState?: StringWithAggregatesFilter<"analyses"> | string
    dice?: IntNullableListFilter<"analyses">
    move?: StringWithAggregatesFilter<"analyses"> | string
    bestMove?: StringWithAggregatesFilter<"analyses"> | string
    equity?: FloatWithAggregatesFilter<"analyses"> | number
    pr?: FloatWithAggregatesFilter<"analyses"> | number
    explanation?: StringWithAggregatesFilter<"analyses"> | string
    alternatives?: JsonWithAggregatesFilter<"analyses">
    analysisType?: EnumAnalysisTypeWithAggregatesFilter<"analyses"> | $Enums.AnalysisType
    createdAt?: DateTimeWithAggregatesFilter<"analyses"> | Date | string
  }

  export type AnalysisQuotaWhereInput = {
    AND?: AnalysisQuotaWhereInput | AnalysisQuotaWhereInput[]
    OR?: AnalysisQuotaWhereInput[]
    NOT?: AnalysisQuotaWhereInput | AnalysisQuotaWhereInput[]
    id?: StringFilter<"AnalysisQuota"> | string
    userId?: StringFilter<"AnalysisQuota"> | string
    date?: DateTimeFilter<"AnalysisQuota"> | Date | string
    count?: IntFilter<"AnalysisQuota"> | number
    extraQuota?: IntFilter<"AnalysisQuota"> | number
    initialFree?: BoolFilter<"AnalysisQuota"> | boolean
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type AnalysisQuotaOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    count?: SortOrder
    extraQuota?: SortOrder
    initialFree?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type AnalysisQuotaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: AnalysisQuotaUserId_dateCompoundUniqueInput
    AND?: AnalysisQuotaWhereInput | AnalysisQuotaWhereInput[]
    OR?: AnalysisQuotaWhereInput[]
    NOT?: AnalysisQuotaWhereInput | AnalysisQuotaWhereInput[]
    userId?: StringFilter<"AnalysisQuota"> | string
    date?: DateTimeFilter<"AnalysisQuota"> | Date | string
    count?: IntFilter<"AnalysisQuota"> | number
    extraQuota?: IntFilter<"AnalysisQuota"> | number
    initialFree?: BoolFilter<"AnalysisQuota"> | boolean
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "userId_date">

  export type AnalysisQuotaOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    count?: SortOrder
    extraQuota?: SortOrder
    initialFree?: SortOrder
    _count?: AnalysisQuotaCountOrderByAggregateInput
    _avg?: AnalysisQuotaAvgOrderByAggregateInput
    _max?: AnalysisQuotaMaxOrderByAggregateInput
    _min?: AnalysisQuotaMinOrderByAggregateInput
    _sum?: AnalysisQuotaSumOrderByAggregateInput
  }

  export type AnalysisQuotaScalarWhereWithAggregatesInput = {
    AND?: AnalysisQuotaScalarWhereWithAggregatesInput | AnalysisQuotaScalarWhereWithAggregatesInput[]
    OR?: AnalysisQuotaScalarWhereWithAggregatesInput[]
    NOT?: AnalysisQuotaScalarWhereWithAggregatesInput | AnalysisQuotaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalysisQuota"> | string
    userId?: StringWithAggregatesFilter<"AnalysisQuota"> | string
    date?: DateTimeWithAggregatesFilter<"AnalysisQuota"> | Date | string
    count?: IntWithAggregatesFilter<"AnalysisQuota"> | number
    extraQuota?: IntWithAggregatesFilter<"AnalysisQuota"> | number
    initialFree?: BoolWithAggregatesFilter<"AnalysisQuota"> | boolean
  }

  export type IAQuotaWhereInput = {
    AND?: IAQuotaWhereInput | IAQuotaWhereInput[]
    OR?: IAQuotaWhereInput[]
    NOT?: IAQuotaWhereInput | IAQuotaWhereInput[]
    id?: StringFilter<"IAQuota"> | string
    userId?: StringFilter<"IAQuota"> | string
    dailyQuota?: IntFilter<"IAQuota"> | number
    premiumQuota?: IntFilter<"IAQuota"> | number
    extrasUsed?: IntFilter<"IAQuota"> | number
    resetAt?: DateTimeFilter<"IAQuota"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type IAQuotaOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    dailyQuota?: SortOrder
    premiumQuota?: SortOrder
    extrasUsed?: SortOrder
    resetAt?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type IAQuotaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: IAQuotaWhereInput | IAQuotaWhereInput[]
    OR?: IAQuotaWhereInput[]
    NOT?: IAQuotaWhereInput | IAQuotaWhereInput[]
    dailyQuota?: IntFilter<"IAQuota"> | number
    premiumQuota?: IntFilter<"IAQuota"> | number
    extrasUsed?: IntFilter<"IAQuota"> | number
    resetAt?: DateTimeFilter<"IAQuota"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "userId">

  export type IAQuotaOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    dailyQuota?: SortOrder
    premiumQuota?: SortOrder
    extrasUsed?: SortOrder
    resetAt?: SortOrder
    _count?: IAQuotaCountOrderByAggregateInput
    _avg?: IAQuotaAvgOrderByAggregateInput
    _max?: IAQuotaMaxOrderByAggregateInput
    _min?: IAQuotaMinOrderByAggregateInput
    _sum?: IAQuotaSumOrderByAggregateInput
  }

  export type IAQuotaScalarWhereWithAggregatesInput = {
    AND?: IAQuotaScalarWhereWithAggregatesInput | IAQuotaScalarWhereWithAggregatesInput[]
    OR?: IAQuotaScalarWhereWithAggregatesInput[]
    NOT?: IAQuotaScalarWhereWithAggregatesInput | IAQuotaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IAQuota"> | string
    userId?: StringWithAggregatesFilter<"IAQuota"> | string
    dailyQuota?: IntWithAggregatesFilter<"IAQuota"> | number
    premiumQuota?: IntWithAggregatesFilter<"IAQuota"> | number
    extrasUsed?: IntWithAggregatesFilter<"IAQuota"> | number
    resetAt?: DateTimeWithAggregatesFilter<"IAQuota"> | Date | string
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    tokenHash?: StringFilter<"UserSession"> | string
    jti?: StringFilter<"UserSession"> | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    jti?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jti?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: StringFilter<"UserSession"> | string
    tokenHash?: StringFilter<"UserSession"> | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "jti">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    jti?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSession"> | string
    userId?: StringWithAggregatesFilter<"UserSession"> | string
    tokenHash?: StringWithAggregatesFilter<"UserSession"> | string
    jti?: StringWithAggregatesFilter<"UserSession"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
  }

  export type chat_messagesWhereInput = {
    AND?: chat_messagesWhereInput | chat_messagesWhereInput[]
    OR?: chat_messagesWhereInput[]
    NOT?: chat_messagesWhereInput | chat_messagesWhereInput[]
    id?: StringFilter<"chat_messages"> | string
    gameId?: StringFilter<"chat_messages"> | string
    userId?: StringNullableFilter<"chat_messages"> | string | null
    message?: StringFilter<"chat_messages"> | string
    messageType?: EnumMessageTypeFilter<"chat_messages"> | $Enums.MessageType
    createdAt?: DateTimeFilter<"chat_messages"> | Date | string
    game?: XOR<GamesRelationFilter, gamesWhereInput>
    user?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type chat_messagesOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    userId?: SortOrderInput | SortOrder
    message?: SortOrder
    messageType?: SortOrder
    createdAt?: SortOrder
    game?: gamesOrderByWithRelationInput
    user?: usersOrderByWithRelationInput
  }

  export type chat_messagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: chat_messagesWhereInput | chat_messagesWhereInput[]
    OR?: chat_messagesWhereInput[]
    NOT?: chat_messagesWhereInput | chat_messagesWhereInput[]
    gameId?: StringFilter<"chat_messages"> | string
    userId?: StringNullableFilter<"chat_messages"> | string | null
    message?: StringFilter<"chat_messages"> | string
    messageType?: EnumMessageTypeFilter<"chat_messages"> | $Enums.MessageType
    createdAt?: DateTimeFilter<"chat_messages"> | Date | string
    game?: XOR<GamesRelationFilter, gamesWhereInput>
    user?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "id">

  export type chat_messagesOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    userId?: SortOrderInput | SortOrder
    message?: SortOrder
    messageType?: SortOrder
    createdAt?: SortOrder
    _count?: chat_messagesCountOrderByAggregateInput
    _max?: chat_messagesMaxOrderByAggregateInput
    _min?: chat_messagesMinOrderByAggregateInput
  }

  export type chat_messagesScalarWhereWithAggregatesInput = {
    AND?: chat_messagesScalarWhereWithAggregatesInput | chat_messagesScalarWhereWithAggregatesInput[]
    OR?: chat_messagesScalarWhereWithAggregatesInput[]
    NOT?: chat_messagesScalarWhereWithAggregatesInput | chat_messagesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"chat_messages"> | string
    gameId?: StringWithAggregatesFilter<"chat_messages"> | string
    userId?: StringNullableWithAggregatesFilter<"chat_messages"> | string | null
    message?: StringWithAggregatesFilter<"chat_messages"> | string
    messageType?: EnumMessageTypeWithAggregatesFilter<"chat_messages"> | $Enums.MessageType
    createdAt?: DateTimeWithAggregatesFilter<"chat_messages"> | Date | string
  }

  export type game_movesWhereInput = {
    AND?: game_movesWhereInput | game_movesWhereInput[]
    OR?: game_movesWhereInput[]
    NOT?: game_movesWhereInput | game_movesWhereInput[]
    id?: StringFilter<"game_moves"> | string
    gameId?: StringFilter<"game_moves"> | string
    userId?: StringNullableFilter<"game_moves"> | string | null
    player?: EnumPlayerFilter<"game_moves"> | $Enums.Player
    dice?: IntNullableListFilter<"game_moves">
    move?: StringFilter<"game_moves"> | string
    fromPoint?: IntNullableFilter<"game_moves"> | number | null
    toPoint?: IntNullableFilter<"game_moves"> | number | null
    equity?: FloatNullableFilter<"game_moves"> | number | null
    pr?: FloatNullableFilter<"game_moves"> | number | null
    thinkingTime?: IntNullableFilter<"game_moves"> | number | null
    createdAt?: DateTimeFilter<"game_moves"> | Date | string
    game?: XOR<GamesRelationFilter, gamesWhereInput>
    user?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type game_movesOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    userId?: SortOrderInput | SortOrder
    player?: SortOrder
    dice?: SortOrder
    move?: SortOrder
    fromPoint?: SortOrderInput | SortOrder
    toPoint?: SortOrderInput | SortOrder
    equity?: SortOrderInput | SortOrder
    pr?: SortOrderInput | SortOrder
    thinkingTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    game?: gamesOrderByWithRelationInput
    user?: usersOrderByWithRelationInput
  }

  export type game_movesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: game_movesWhereInput | game_movesWhereInput[]
    OR?: game_movesWhereInput[]
    NOT?: game_movesWhereInput | game_movesWhereInput[]
    gameId?: StringFilter<"game_moves"> | string
    userId?: StringNullableFilter<"game_moves"> | string | null
    player?: EnumPlayerFilter<"game_moves"> | $Enums.Player
    dice?: IntNullableListFilter<"game_moves">
    move?: StringFilter<"game_moves"> | string
    fromPoint?: IntNullableFilter<"game_moves"> | number | null
    toPoint?: IntNullableFilter<"game_moves"> | number | null
    equity?: FloatNullableFilter<"game_moves"> | number | null
    pr?: FloatNullableFilter<"game_moves"> | number | null
    thinkingTime?: IntNullableFilter<"game_moves"> | number | null
    createdAt?: DateTimeFilter<"game_moves"> | Date | string
    game?: XOR<GamesRelationFilter, gamesWhereInput>
    user?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "id">

  export type game_movesOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    userId?: SortOrderInput | SortOrder
    player?: SortOrder
    dice?: SortOrder
    move?: SortOrder
    fromPoint?: SortOrderInput | SortOrder
    toPoint?: SortOrderInput | SortOrder
    equity?: SortOrderInput | SortOrder
    pr?: SortOrderInput | SortOrder
    thinkingTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: game_movesCountOrderByAggregateInput
    _avg?: game_movesAvgOrderByAggregateInput
    _max?: game_movesMaxOrderByAggregateInput
    _min?: game_movesMinOrderByAggregateInput
    _sum?: game_movesSumOrderByAggregateInput
  }

  export type game_movesScalarWhereWithAggregatesInput = {
    AND?: game_movesScalarWhereWithAggregatesInput | game_movesScalarWhereWithAggregatesInput[]
    OR?: game_movesScalarWhereWithAggregatesInput[]
    NOT?: game_movesScalarWhereWithAggregatesInput | game_movesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"game_moves"> | string
    gameId?: StringWithAggregatesFilter<"game_moves"> | string
    userId?: StringNullableWithAggregatesFilter<"game_moves"> | string | null
    player?: EnumPlayerWithAggregatesFilter<"game_moves"> | $Enums.Player
    dice?: IntNullableListFilter<"game_moves">
    move?: StringWithAggregatesFilter<"game_moves"> | string
    fromPoint?: IntNullableWithAggregatesFilter<"game_moves"> | number | null
    toPoint?: IntNullableWithAggregatesFilter<"game_moves"> | number | null
    equity?: FloatNullableWithAggregatesFilter<"game_moves"> | number | null
    pr?: FloatNullableWithAggregatesFilter<"game_moves"> | number | null
    thinkingTime?: IntNullableWithAggregatesFilter<"game_moves"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"game_moves"> | Date | string
  }

  export type subscriptionsWhereInput = {
    AND?: subscriptionsWhereInput | subscriptionsWhereInput[]
    OR?: subscriptionsWhereInput[]
    NOT?: subscriptionsWhereInput | subscriptionsWhereInput[]
    id?: StringFilter<"subscriptions"> | string
    user_id?: StringFilter<"subscriptions"> | string
    stripe_subscription_id?: StringNullableFilter<"subscriptions"> | string | null
    stripe_customer_id?: StringNullableFilter<"subscriptions"> | string | null
    plan?: EnumSubscriptionPlanFilter<"subscriptions"> | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFilter<"subscriptions"> | $Enums.SubscriptionStatus
    current_period_start?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    current_period_end?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    cancel_at_period_end?: BoolFilter<"subscriptions"> | boolean
    createdAt?: DateTimeFilter<"subscriptions"> | Date | string
    updatedAt?: DateTimeFilter<"subscriptions"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type subscriptionsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    stripe_subscription_id?: SortOrderInput | SortOrder
    stripe_customer_id?: SortOrderInput | SortOrder
    plan?: SortOrder
    status?: SortOrder
    current_period_start?: SortOrderInput | SortOrder
    current_period_end?: SortOrderInput | SortOrder
    cancel_at_period_end?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type subscriptionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id?: string
    stripe_subscription_id?: string
    AND?: subscriptionsWhereInput | subscriptionsWhereInput[]
    OR?: subscriptionsWhereInput[]
    NOT?: subscriptionsWhereInput | subscriptionsWhereInput[]
    stripe_customer_id?: StringNullableFilter<"subscriptions"> | string | null
    plan?: EnumSubscriptionPlanFilter<"subscriptions"> | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFilter<"subscriptions"> | $Enums.SubscriptionStatus
    current_period_start?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    current_period_end?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    cancel_at_period_end?: BoolFilter<"subscriptions"> | boolean
    createdAt?: DateTimeFilter<"subscriptions"> | Date | string
    updatedAt?: DateTimeFilter<"subscriptions"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "user_id" | "stripe_subscription_id">

  export type subscriptionsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    stripe_subscription_id?: SortOrderInput | SortOrder
    stripe_customer_id?: SortOrderInput | SortOrder
    plan?: SortOrder
    status?: SortOrder
    current_period_start?: SortOrderInput | SortOrder
    current_period_end?: SortOrderInput | SortOrder
    cancel_at_period_end?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: subscriptionsCountOrderByAggregateInput
    _max?: subscriptionsMaxOrderByAggregateInput
    _min?: subscriptionsMinOrderByAggregateInput
  }

  export type subscriptionsScalarWhereWithAggregatesInput = {
    AND?: subscriptionsScalarWhereWithAggregatesInput | subscriptionsScalarWhereWithAggregatesInput[]
    OR?: subscriptionsScalarWhereWithAggregatesInput[]
    NOT?: subscriptionsScalarWhereWithAggregatesInput | subscriptionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"subscriptions"> | string
    user_id?: StringWithAggregatesFilter<"subscriptions"> | string
    stripe_subscription_id?: StringNullableWithAggregatesFilter<"subscriptions"> | string | null
    stripe_customer_id?: StringNullableWithAggregatesFilter<"subscriptions"> | string | null
    plan?: EnumSubscriptionPlanWithAggregatesFilter<"subscriptions"> | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusWithAggregatesFilter<"subscriptions"> | $Enums.SubscriptionStatus
    current_period_start?: DateTimeNullableWithAggregatesFilter<"subscriptions"> | Date | string | null
    current_period_end?: DateTimeNullableWithAggregatesFilter<"subscriptions"> | Date | string | null
    cancel_at_period_end?: BoolWithAggregatesFilter<"subscriptions"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"subscriptions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"subscriptions"> | Date | string
  }

  export type tournament_participantsWhereInput = {
    AND?: tournament_participantsWhereInput | tournament_participantsWhereInput[]
    OR?: tournament_participantsWhereInput[]
    NOT?: tournament_participantsWhereInput | tournament_participantsWhereInput[]
    id?: StringFilter<"tournament_participants"> | string
    tournament_id?: StringFilter<"tournament_participants"> | string
    user_id?: StringFilter<"tournament_participants"> | string
    registered_at?: DateTimeFilter<"tournament_participants"> | Date | string
    current_position?: IntNullableFilter<"tournament_participants"> | number | null
    eliminated_at?: DateTimeNullableFilter<"tournament_participants"> | Date | string | null
    tournaments?: XOR<TournamentsRelationFilter, tournamentsWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
    whiteMatches?: Tournament_matchesListRelationFilter
    blackMatches?: Tournament_matchesListRelationFilter
    wonMatches?: Tournament_matchesListRelationFilter
  }

  export type tournament_participantsOrderByWithRelationInput = {
    id?: SortOrder
    tournament_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrder
    current_position?: SortOrderInput | SortOrder
    eliminated_at?: SortOrderInput | SortOrder
    tournaments?: tournamentsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    whiteMatches?: tournament_matchesOrderByRelationAggregateInput
    blackMatches?: tournament_matchesOrderByRelationAggregateInput
    wonMatches?: tournament_matchesOrderByRelationAggregateInput
  }

  export type tournament_participantsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tournament_id_user_id?: tournament_participantsTournament_idUser_idCompoundUniqueInput
    AND?: tournament_participantsWhereInput | tournament_participantsWhereInput[]
    OR?: tournament_participantsWhereInput[]
    NOT?: tournament_participantsWhereInput | tournament_participantsWhereInput[]
    tournament_id?: StringFilter<"tournament_participants"> | string
    user_id?: StringFilter<"tournament_participants"> | string
    registered_at?: DateTimeFilter<"tournament_participants"> | Date | string
    current_position?: IntNullableFilter<"tournament_participants"> | number | null
    eliminated_at?: DateTimeNullableFilter<"tournament_participants"> | Date | string | null
    tournaments?: XOR<TournamentsRelationFilter, tournamentsWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
    whiteMatches?: Tournament_matchesListRelationFilter
    blackMatches?: Tournament_matchesListRelationFilter
    wonMatches?: Tournament_matchesListRelationFilter
  }, "id" | "tournament_id_user_id">

  export type tournament_participantsOrderByWithAggregationInput = {
    id?: SortOrder
    tournament_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrder
    current_position?: SortOrderInput | SortOrder
    eliminated_at?: SortOrderInput | SortOrder
    _count?: tournament_participantsCountOrderByAggregateInput
    _avg?: tournament_participantsAvgOrderByAggregateInput
    _max?: tournament_participantsMaxOrderByAggregateInput
    _min?: tournament_participantsMinOrderByAggregateInput
    _sum?: tournament_participantsSumOrderByAggregateInput
  }

  export type tournament_participantsScalarWhereWithAggregatesInput = {
    AND?: tournament_participantsScalarWhereWithAggregatesInput | tournament_participantsScalarWhereWithAggregatesInput[]
    OR?: tournament_participantsScalarWhereWithAggregatesInput[]
    NOT?: tournament_participantsScalarWhereWithAggregatesInput | tournament_participantsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tournament_participants"> | string
    tournament_id?: StringWithAggregatesFilter<"tournament_participants"> | string
    user_id?: StringWithAggregatesFilter<"tournament_participants"> | string
    registered_at?: DateTimeWithAggregatesFilter<"tournament_participants"> | Date | string
    current_position?: IntNullableWithAggregatesFilter<"tournament_participants"> | number | null
    eliminated_at?: DateTimeNullableWithAggregatesFilter<"tournament_participants"> | Date | string | null
  }

  export type tournament_matchesWhereInput = {
    AND?: tournament_matchesWhereInput | tournament_matchesWhereInput[]
    OR?: tournament_matchesWhereInput[]
    NOT?: tournament_matchesWhereInput | tournament_matchesWhereInput[]
    id?: StringFilter<"tournament_matches"> | string
    tournamentId?: StringFilter<"tournament_matches"> | string
    round?: IntFilter<"tournament_matches"> | number
    matchNumber?: IntFilter<"tournament_matches"> | number
    whiteParticipantId?: StringNullableFilter<"tournament_matches"> | string | null
    blackParticipantId?: StringNullableFilter<"tournament_matches"> | string | null
    winnerParticipantId?: StringNullableFilter<"tournament_matches"> | string | null
    status?: EnumTournamentMatchStatusFilter<"tournament_matches"> | $Enums.TournamentMatchStatus
    scheduledAt?: DateTimeNullableFilter<"tournament_matches"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"tournament_matches"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"tournament_matches"> | Date | string | null
    gameId?: StringNullableFilter<"tournament_matches"> | string | null
    createdAt?: DateTimeFilter<"tournament_matches"> | Date | string
    updatedAt?: DateTimeFilter<"tournament_matches"> | Date | string
    tournament?: XOR<TournamentsRelationFilter, tournamentsWhereInput>
    white?: XOR<Tournament_participantsNullableRelationFilter, tournament_participantsWhereInput> | null
    black?: XOR<Tournament_participantsNullableRelationFilter, tournament_participantsWhereInput> | null
    winner?: XOR<Tournament_participantsNullableRelationFilter, tournament_participantsWhereInput> | null
    game?: XOR<GamesNullableRelationFilter, gamesWhereInput> | null
  }

  export type tournament_matchesOrderByWithRelationInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    round?: SortOrder
    matchNumber?: SortOrder
    whiteParticipantId?: SortOrderInput | SortOrder
    blackParticipantId?: SortOrderInput | SortOrder
    winnerParticipantId?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    gameId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tournament?: tournamentsOrderByWithRelationInput
    white?: tournament_participantsOrderByWithRelationInput
    black?: tournament_participantsOrderByWithRelationInput
    winner?: tournament_participantsOrderByWithRelationInput
    game?: gamesOrderByWithRelationInput
  }

  export type tournament_matchesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gameId?: string
    AND?: tournament_matchesWhereInput | tournament_matchesWhereInput[]
    OR?: tournament_matchesWhereInput[]
    NOT?: tournament_matchesWhereInput | tournament_matchesWhereInput[]
    tournamentId?: StringFilter<"tournament_matches"> | string
    round?: IntFilter<"tournament_matches"> | number
    matchNumber?: IntFilter<"tournament_matches"> | number
    whiteParticipantId?: StringNullableFilter<"tournament_matches"> | string | null
    blackParticipantId?: StringNullableFilter<"tournament_matches"> | string | null
    winnerParticipantId?: StringNullableFilter<"tournament_matches"> | string | null
    status?: EnumTournamentMatchStatusFilter<"tournament_matches"> | $Enums.TournamentMatchStatus
    scheduledAt?: DateTimeNullableFilter<"tournament_matches"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"tournament_matches"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"tournament_matches"> | Date | string | null
    createdAt?: DateTimeFilter<"tournament_matches"> | Date | string
    updatedAt?: DateTimeFilter<"tournament_matches"> | Date | string
    tournament?: XOR<TournamentsRelationFilter, tournamentsWhereInput>
    white?: XOR<Tournament_participantsNullableRelationFilter, tournament_participantsWhereInput> | null
    black?: XOR<Tournament_participantsNullableRelationFilter, tournament_participantsWhereInput> | null
    winner?: XOR<Tournament_participantsNullableRelationFilter, tournament_participantsWhereInput> | null
    game?: XOR<GamesNullableRelationFilter, gamesWhereInput> | null
  }, "id" | "gameId">

  export type tournament_matchesOrderByWithAggregationInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    round?: SortOrder
    matchNumber?: SortOrder
    whiteParticipantId?: SortOrderInput | SortOrder
    blackParticipantId?: SortOrderInput | SortOrder
    winnerParticipantId?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    gameId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: tournament_matchesCountOrderByAggregateInput
    _avg?: tournament_matchesAvgOrderByAggregateInput
    _max?: tournament_matchesMaxOrderByAggregateInput
    _min?: tournament_matchesMinOrderByAggregateInput
    _sum?: tournament_matchesSumOrderByAggregateInput
  }

  export type tournament_matchesScalarWhereWithAggregatesInput = {
    AND?: tournament_matchesScalarWhereWithAggregatesInput | tournament_matchesScalarWhereWithAggregatesInput[]
    OR?: tournament_matchesScalarWhereWithAggregatesInput[]
    NOT?: tournament_matchesScalarWhereWithAggregatesInput | tournament_matchesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tournament_matches"> | string
    tournamentId?: StringWithAggregatesFilter<"tournament_matches"> | string
    round?: IntWithAggregatesFilter<"tournament_matches"> | number
    matchNumber?: IntWithAggregatesFilter<"tournament_matches"> | number
    whiteParticipantId?: StringNullableWithAggregatesFilter<"tournament_matches"> | string | null
    blackParticipantId?: StringNullableWithAggregatesFilter<"tournament_matches"> | string | null
    winnerParticipantId?: StringNullableWithAggregatesFilter<"tournament_matches"> | string | null
    status?: EnumTournamentMatchStatusWithAggregatesFilter<"tournament_matches"> | $Enums.TournamentMatchStatus
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"tournament_matches"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"tournament_matches"> | Date | string | null
    finishedAt?: DateTimeNullableWithAggregatesFilter<"tournament_matches"> | Date | string | null
    gameId?: StringNullableWithAggregatesFilter<"tournament_matches"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"tournament_matches"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tournament_matches"> | Date | string
  }

  export type tournamentsWhereInput = {
    AND?: tournamentsWhereInput | tournamentsWhereInput[]
    OR?: tournamentsWhereInput[]
    NOT?: tournamentsWhereInput | tournamentsWhereInput[]
    id?: StringFilter<"tournaments"> | string
    name?: StringFilter<"tournaments"> | string
    description?: StringNullableFilter<"tournaments"> | string | null
    entryFee?: IntFilter<"tournaments"> | number
    prizePool?: IntFilter<"tournaments"> | number
    maxPlayers?: IntNullableFilter<"tournaments"> | number | null
    status?: EnumTournamentStatusFilter<"tournaments"> | $Enums.TournamentStatus
    startTime?: DateTimeNullableFilter<"tournaments"> | Date | string | null
    endTime?: DateTimeNullableFilter<"tournaments"> | Date | string | null
    createdBy?: StringFilter<"tournaments"> | string
    createdAt?: DateTimeFilter<"tournaments"> | Date | string
    games?: GamesListRelationFilter
    participants?: Tournament_participantsListRelationFilter
    matches?: Tournament_matchesListRelationFilter
    creator?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type tournamentsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
    maxPlayers?: SortOrderInput | SortOrder
    status?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    games?: gamesOrderByRelationAggregateInput
    participants?: tournament_participantsOrderByRelationAggregateInput
    matches?: tournament_matchesOrderByRelationAggregateInput
    creator?: usersOrderByWithRelationInput
  }

  export type tournamentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tournamentsWhereInput | tournamentsWhereInput[]
    OR?: tournamentsWhereInput[]
    NOT?: tournamentsWhereInput | tournamentsWhereInput[]
    name?: StringFilter<"tournaments"> | string
    description?: StringNullableFilter<"tournaments"> | string | null
    entryFee?: IntFilter<"tournaments"> | number
    prizePool?: IntFilter<"tournaments"> | number
    maxPlayers?: IntNullableFilter<"tournaments"> | number | null
    status?: EnumTournamentStatusFilter<"tournaments"> | $Enums.TournamentStatus
    startTime?: DateTimeNullableFilter<"tournaments"> | Date | string | null
    endTime?: DateTimeNullableFilter<"tournaments"> | Date | string | null
    createdBy?: StringFilter<"tournaments"> | string
    createdAt?: DateTimeFilter<"tournaments"> | Date | string
    games?: GamesListRelationFilter
    participants?: Tournament_participantsListRelationFilter
    matches?: Tournament_matchesListRelationFilter
    creator?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type tournamentsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
    maxPlayers?: SortOrderInput | SortOrder
    status?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: tournamentsCountOrderByAggregateInput
    _avg?: tournamentsAvgOrderByAggregateInput
    _max?: tournamentsMaxOrderByAggregateInput
    _min?: tournamentsMinOrderByAggregateInput
    _sum?: tournamentsSumOrderByAggregateInput
  }

  export type tournamentsScalarWhereWithAggregatesInput = {
    AND?: tournamentsScalarWhereWithAggregatesInput | tournamentsScalarWhereWithAggregatesInput[]
    OR?: tournamentsScalarWhereWithAggregatesInput[]
    NOT?: tournamentsScalarWhereWithAggregatesInput | tournamentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tournaments"> | string
    name?: StringWithAggregatesFilter<"tournaments"> | string
    description?: StringNullableWithAggregatesFilter<"tournaments"> | string | null
    entryFee?: IntWithAggregatesFilter<"tournaments"> | number
    prizePool?: IntWithAggregatesFilter<"tournaments"> | number
    maxPlayers?: IntNullableWithAggregatesFilter<"tournaments"> | number | null
    status?: EnumTournamentStatusWithAggregatesFilter<"tournaments"> | $Enums.TournamentStatus
    startTime?: DateTimeNullableWithAggregatesFilter<"tournaments"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"tournaments"> | Date | string | null
    createdBy?: StringWithAggregatesFilter<"tournaments"> | string
    createdAt?: DateTimeWithAggregatesFilter<"tournaments"> | Date | string
  }

  export type user_analyticsWhereInput = {
    AND?: user_analyticsWhereInput | user_analyticsWhereInput[]
    OR?: user_analyticsWhereInput[]
    NOT?: user_analyticsWhereInput | user_analyticsWhereInput[]
    id?: StringFilter<"user_analytics"> | string
    user_id?: StringFilter<"user_analytics"> | string
    date?: DateTimeFilter<"user_analytics"> | Date | string
    games_played?: IntFilter<"user_analytics"> | number
    games_won?: IntFilter<"user_analytics"> | number
    analyses_completed?: IntFilter<"user_analytics"> | number
    time_played?: IntFilter<"user_analytics"> | number
    avg_equity?: FloatFilter<"user_analytics"> | number
    elo_change?: IntFilter<"user_analytics"> | number
    claude_requests_today?: IntFilter<"user_analytics"> | number
    claude_requests_this_month?: IntFilter<"user_analytics"> | number
    claude_quota_remaining?: IntFilter<"user_analytics"> | number
    chatgpt_requests_today?: IntFilter<"user_analytics"> | number
    chatgpt_requests_this_month?: IntFilter<"user_analytics"> | number
    gurubot_requests_today?: IntFilter<"user_analytics"> | number
    gurubot_requests_this_month?: IntFilter<"user_analytics"> | number
    gurubot_quota_remaining?: IntFilter<"user_analytics"> | number
    easybot_requests_today?: IntFilter<"user_analytics"> | number
    createdAt?: DateTimeFilter<"user_analytics"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type user_analyticsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    games_played?: SortOrder
    games_won?: SortOrder
    analyses_completed?: SortOrder
    time_played?: SortOrder
    avg_equity?: SortOrder
    elo_change?: SortOrder
    claude_requests_today?: SortOrder
    claude_requests_this_month?: SortOrder
    claude_quota_remaining?: SortOrder
    chatgpt_requests_today?: SortOrder
    chatgpt_requests_this_month?: SortOrder
    gurubot_requests_today?: SortOrder
    gurubot_requests_this_month?: SortOrder
    gurubot_quota_remaining?: SortOrder
    easybot_requests_today?: SortOrder
    createdAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type user_analyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_date?: user_analyticsUser_idDateCompoundUniqueInput
    AND?: user_analyticsWhereInput | user_analyticsWhereInput[]
    OR?: user_analyticsWhereInput[]
    NOT?: user_analyticsWhereInput | user_analyticsWhereInput[]
    user_id?: StringFilter<"user_analytics"> | string
    date?: DateTimeFilter<"user_analytics"> | Date | string
    games_played?: IntFilter<"user_analytics"> | number
    games_won?: IntFilter<"user_analytics"> | number
    analyses_completed?: IntFilter<"user_analytics"> | number
    time_played?: IntFilter<"user_analytics"> | number
    avg_equity?: FloatFilter<"user_analytics"> | number
    elo_change?: IntFilter<"user_analytics"> | number
    claude_requests_today?: IntFilter<"user_analytics"> | number
    claude_requests_this_month?: IntFilter<"user_analytics"> | number
    claude_quota_remaining?: IntFilter<"user_analytics"> | number
    chatgpt_requests_today?: IntFilter<"user_analytics"> | number
    chatgpt_requests_this_month?: IntFilter<"user_analytics"> | number
    gurubot_requests_today?: IntFilter<"user_analytics"> | number
    gurubot_requests_this_month?: IntFilter<"user_analytics"> | number
    gurubot_quota_remaining?: IntFilter<"user_analytics"> | number
    easybot_requests_today?: IntFilter<"user_analytics"> | number
    createdAt?: DateTimeFilter<"user_analytics"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "user_id_date">

  export type user_analyticsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    games_played?: SortOrder
    games_won?: SortOrder
    analyses_completed?: SortOrder
    time_played?: SortOrder
    avg_equity?: SortOrder
    elo_change?: SortOrder
    claude_requests_today?: SortOrder
    claude_requests_this_month?: SortOrder
    claude_quota_remaining?: SortOrder
    chatgpt_requests_today?: SortOrder
    chatgpt_requests_this_month?: SortOrder
    gurubot_requests_today?: SortOrder
    gurubot_requests_this_month?: SortOrder
    gurubot_quota_remaining?: SortOrder
    easybot_requests_today?: SortOrder
    createdAt?: SortOrder
    _count?: user_analyticsCountOrderByAggregateInput
    _avg?: user_analyticsAvgOrderByAggregateInput
    _max?: user_analyticsMaxOrderByAggregateInput
    _min?: user_analyticsMinOrderByAggregateInput
    _sum?: user_analyticsSumOrderByAggregateInput
  }

  export type user_analyticsScalarWhereWithAggregatesInput = {
    AND?: user_analyticsScalarWhereWithAggregatesInput | user_analyticsScalarWhereWithAggregatesInput[]
    OR?: user_analyticsScalarWhereWithAggregatesInput[]
    NOT?: user_analyticsScalarWhereWithAggregatesInput | user_analyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user_analytics"> | string
    user_id?: StringWithAggregatesFilter<"user_analytics"> | string
    date?: DateTimeWithAggregatesFilter<"user_analytics"> | Date | string
    games_played?: IntWithAggregatesFilter<"user_analytics"> | number
    games_won?: IntWithAggregatesFilter<"user_analytics"> | number
    analyses_completed?: IntWithAggregatesFilter<"user_analytics"> | number
    time_played?: IntWithAggregatesFilter<"user_analytics"> | number
    avg_equity?: FloatWithAggregatesFilter<"user_analytics"> | number
    elo_change?: IntWithAggregatesFilter<"user_analytics"> | number
    claude_requests_today?: IntWithAggregatesFilter<"user_analytics"> | number
    claude_requests_this_month?: IntWithAggregatesFilter<"user_analytics"> | number
    claude_quota_remaining?: IntWithAggregatesFilter<"user_analytics"> | number
    chatgpt_requests_today?: IntWithAggregatesFilter<"user_analytics"> | number
    chatgpt_requests_this_month?: IntWithAggregatesFilter<"user_analytics"> | number
    gurubot_requests_today?: IntWithAggregatesFilter<"user_analytics"> | number
    gurubot_requests_this_month?: IntWithAggregatesFilter<"user_analytics"> | number
    gurubot_quota_remaining?: IntWithAggregatesFilter<"user_analytics"> | number
    easybot_requests_today?: IntWithAggregatesFilter<"user_analytics"> | number
    createdAt?: DateTimeWithAggregatesFilter<"user_analytics"> | Date | string
  }

  export type game_analysesWhereInput = {
    AND?: game_analysesWhereInput | game_analysesWhereInput[]
    OR?: game_analysesWhereInput[]
    NOT?: game_analysesWhereInput | game_analysesWhereInput[]
    id?: StringFilter<"game_analyses"> | string
    user_id?: StringFilter<"game_analyses"> | string
    game_id?: StringFilter<"game_analyses"> | string
    analysis_report?: JsonFilter<"game_analyses">
    ai_services_used?: StringNullableListFilter<"game_analyses">
    created_at?: DateTimeFilter<"game_analyses"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type game_analysesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    game_id?: SortOrder
    analysis_report?: SortOrder
    ai_services_used?: SortOrder
    created_at?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type game_analysesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_game_id?: game_analysesUser_idGame_idCompoundUniqueInput
    AND?: game_analysesWhereInput | game_analysesWhereInput[]
    OR?: game_analysesWhereInput[]
    NOT?: game_analysesWhereInput | game_analysesWhereInput[]
    user_id?: StringFilter<"game_analyses"> | string
    game_id?: StringFilter<"game_analyses"> | string
    analysis_report?: JsonFilter<"game_analyses">
    ai_services_used?: StringNullableListFilter<"game_analyses">
    created_at?: DateTimeFilter<"game_analyses"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "user_id_game_id">

  export type game_analysesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    game_id?: SortOrder
    analysis_report?: SortOrder
    ai_services_used?: SortOrder
    created_at?: SortOrder
    _count?: game_analysesCountOrderByAggregateInput
    _max?: game_analysesMaxOrderByAggregateInput
    _min?: game_analysesMinOrderByAggregateInput
  }

  export type game_analysesScalarWhereWithAggregatesInput = {
    AND?: game_analysesScalarWhereWithAggregatesInput | game_analysesScalarWhereWithAggregatesInput[]
    OR?: game_analysesScalarWhereWithAggregatesInput[]
    NOT?: game_analysesScalarWhereWithAggregatesInput | game_analysesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"game_analyses"> | string
    user_id?: StringWithAggregatesFilter<"game_analyses"> | string
    game_id?: StringWithAggregatesFilter<"game_analyses"> | string
    analysis_report?: JsonWithAggregatesFilter<"game_analyses">
    ai_services_used?: StringNullableListFilter<"game_analyses">
    created_at?: DateTimeWithAggregatesFilter<"game_analyses"> | Date | string
  }

  export type gamesWhereInput = {
    AND?: gamesWhereInput | gamesWhereInput[]
    OR?: gamesWhereInput[]
    NOT?: gamesWhereInput | gamesWhereInput[]
    id?: StringFilter<"games"> | string
    whitePlayerId?: StringFilter<"games"> | string
    blackPlayerId?: StringNullableFilter<"games"> | string | null
    tournamentId?: StringNullableFilter<"games"> | string | null
    gameMode?: EnumGameModeFilter<"games"> | $Enums.GameMode
    status?: EnumGameStatusFilter<"games"> | $Enums.GameStatus
    stake?: IntFilter<"games"> | number
    winner?: EnumPlayerNullableFilter<"games"> | $Enums.Player | null
    drawOfferedBy?: EnumPlayerNullableFilter<"games"> | $Enums.Player | null
    whiteScore?: IntFilter<"games"> | number
    blackScore?: IntFilter<"games"> | number
    boardState?: JsonFilter<"games">
    currentPlayer?: EnumPlayerFilter<"games"> | $Enums.Player
    dice?: IntNullableListFilter<"games">
    cubeLevel?: IntFilter<"games"> | number
    cubeOwner?: EnumPlayerNullableFilter<"games"> | $Enums.Player | null
    matchLength?: IntNullableFilter<"games"> | number | null
    doubleOfferedBy?: StringNullableFilter<"games"> | string | null
    doublePending?: BoolFilter<"games"> | boolean
    cubeHistory?: JsonFilter<"games">
    timeControlPreset?: EnumTimeControlPresetNullableFilter<"games"> | $Enums.TimeControlPreset | null
    timeControlTotalMs?: IntNullableFilter<"games"> | number | null
    timeControlIncrementMs?: IntNullableFilter<"games"> | number | null
    timeControlDelayMs?: IntNullableFilter<"games"> | number | null
    whiteTimeRemainingMs?: IntNullableFilter<"games"> | number | null
    blackTimeRemainingMs?: IntNullableFilter<"games"> | number | null
    activeTimer?: EnumPlayerNullableFilter<"games"> | $Enums.Player | null
    timerUpdatedAt?: DateTimeNullableFilter<"games"> | Date | string | null
    createdAt?: DateTimeFilter<"games"> | Date | string
    finishedAt?: DateTimeNullableFilter<"games"> | Date | string | null
    updatedAt?: DateTimeFilter<"games"> | Date | string
    resignationType?: EnumResignationTypeNullableFilter<"games"> | $Enums.ResignationType | null
    chatMessages?: Chat_messagesListRelationFilter
    gameMoves?: Game_movesListRelationFilter
    tournament?: XOR<TournamentsNullableRelationFilter, tournamentsWhereInput> | null
    websocketConnections?: Websocket_connectionsListRelationFilter
    whitePlayer?: XOR<UsersRelationFilter, usersWhereInput>
    blackPlayer?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    match?: XOR<MatchesNullableRelationFilter, matchesWhereInput> | null
    tournamentMatch?: XOR<Tournament_matchesNullableRelationFilter, tournament_matchesWhereInput> | null
    sessions?: GameSessionListRelationFilter
    events?: GameEventListRelationFilter
  }

  export type gamesOrderByWithRelationInput = {
    id?: SortOrder
    whitePlayerId?: SortOrder
    blackPlayerId?: SortOrderInput | SortOrder
    tournamentId?: SortOrderInput | SortOrder
    gameMode?: SortOrder
    status?: SortOrder
    stake?: SortOrder
    winner?: SortOrderInput | SortOrder
    drawOfferedBy?: SortOrderInput | SortOrder
    whiteScore?: SortOrder
    blackScore?: SortOrder
    boardState?: SortOrder
    currentPlayer?: SortOrder
    dice?: SortOrder
    cubeLevel?: SortOrder
    cubeOwner?: SortOrderInput | SortOrder
    matchLength?: SortOrderInput | SortOrder
    doubleOfferedBy?: SortOrderInput | SortOrder
    doublePending?: SortOrder
    cubeHistory?: SortOrder
    timeControlPreset?: SortOrderInput | SortOrder
    timeControlTotalMs?: SortOrderInput | SortOrder
    timeControlIncrementMs?: SortOrderInput | SortOrder
    timeControlDelayMs?: SortOrderInput | SortOrder
    whiteTimeRemainingMs?: SortOrderInput | SortOrder
    blackTimeRemainingMs?: SortOrderInput | SortOrder
    activeTimer?: SortOrderInput | SortOrder
    timerUpdatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    resignationType?: SortOrderInput | SortOrder
    chatMessages?: chat_messagesOrderByRelationAggregateInput
    gameMoves?: game_movesOrderByRelationAggregateInput
    tournament?: tournamentsOrderByWithRelationInput
    websocketConnections?: websocket_connectionsOrderByRelationAggregateInput
    whitePlayer?: usersOrderByWithRelationInput
    blackPlayer?: usersOrderByWithRelationInput
    match?: matchesOrderByWithRelationInput
    tournamentMatch?: tournament_matchesOrderByWithRelationInput
    sessions?: GameSessionOrderByRelationAggregateInput
    events?: GameEventOrderByRelationAggregateInput
  }

  export type gamesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: gamesWhereInput | gamesWhereInput[]
    OR?: gamesWhereInput[]
    NOT?: gamesWhereInput | gamesWhereInput[]
    whitePlayerId?: StringFilter<"games"> | string
    blackPlayerId?: StringNullableFilter<"games"> | string | null
    tournamentId?: StringNullableFilter<"games"> | string | null
    gameMode?: EnumGameModeFilter<"games"> | $Enums.GameMode
    status?: EnumGameStatusFilter<"games"> | $Enums.GameStatus
    stake?: IntFilter<"games"> | number
    winner?: EnumPlayerNullableFilter<"games"> | $Enums.Player | null
    drawOfferedBy?: EnumPlayerNullableFilter<"games"> | $Enums.Player | null
    whiteScore?: IntFilter<"games"> | number
    blackScore?: IntFilter<"games"> | number
    boardState?: JsonFilter<"games">
    currentPlayer?: EnumPlayerFilter<"games"> | $Enums.Player
    dice?: IntNullableListFilter<"games">
    cubeLevel?: IntFilter<"games"> | number
    cubeOwner?: EnumPlayerNullableFilter<"games"> | $Enums.Player | null
    matchLength?: IntNullableFilter<"games"> | number | null
    doubleOfferedBy?: StringNullableFilter<"games"> | string | null
    doublePending?: BoolFilter<"games"> | boolean
    cubeHistory?: JsonFilter<"games">
    timeControlPreset?: EnumTimeControlPresetNullableFilter<"games"> | $Enums.TimeControlPreset | null
    timeControlTotalMs?: IntNullableFilter<"games"> | number | null
    timeControlIncrementMs?: IntNullableFilter<"games"> | number | null
    timeControlDelayMs?: IntNullableFilter<"games"> | number | null
    whiteTimeRemainingMs?: IntNullableFilter<"games"> | number | null
    blackTimeRemainingMs?: IntNullableFilter<"games"> | number | null
    activeTimer?: EnumPlayerNullableFilter<"games"> | $Enums.Player | null
    timerUpdatedAt?: DateTimeNullableFilter<"games"> | Date | string | null
    createdAt?: DateTimeFilter<"games"> | Date | string
    finishedAt?: DateTimeNullableFilter<"games"> | Date | string | null
    updatedAt?: DateTimeFilter<"games"> | Date | string
    resignationType?: EnumResignationTypeNullableFilter<"games"> | $Enums.ResignationType | null
    chatMessages?: Chat_messagesListRelationFilter
    gameMoves?: Game_movesListRelationFilter
    tournament?: XOR<TournamentsNullableRelationFilter, tournamentsWhereInput> | null
    websocketConnections?: Websocket_connectionsListRelationFilter
    whitePlayer?: XOR<UsersRelationFilter, usersWhereInput>
    blackPlayer?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    match?: XOR<MatchesNullableRelationFilter, matchesWhereInput> | null
    tournamentMatch?: XOR<Tournament_matchesNullableRelationFilter, tournament_matchesWhereInput> | null
    sessions?: GameSessionListRelationFilter
    events?: GameEventListRelationFilter
  }, "id">

  export type gamesOrderByWithAggregationInput = {
    id?: SortOrder
    whitePlayerId?: SortOrder
    blackPlayerId?: SortOrderInput | SortOrder
    tournamentId?: SortOrderInput | SortOrder
    gameMode?: SortOrder
    status?: SortOrder
    stake?: SortOrder
    winner?: SortOrderInput | SortOrder
    drawOfferedBy?: SortOrderInput | SortOrder
    whiteScore?: SortOrder
    blackScore?: SortOrder
    boardState?: SortOrder
    currentPlayer?: SortOrder
    dice?: SortOrder
    cubeLevel?: SortOrder
    cubeOwner?: SortOrderInput | SortOrder
    matchLength?: SortOrderInput | SortOrder
    doubleOfferedBy?: SortOrderInput | SortOrder
    doublePending?: SortOrder
    cubeHistory?: SortOrder
    timeControlPreset?: SortOrderInput | SortOrder
    timeControlTotalMs?: SortOrderInput | SortOrder
    timeControlIncrementMs?: SortOrderInput | SortOrder
    timeControlDelayMs?: SortOrderInput | SortOrder
    whiteTimeRemainingMs?: SortOrderInput | SortOrder
    blackTimeRemainingMs?: SortOrderInput | SortOrder
    activeTimer?: SortOrderInput | SortOrder
    timerUpdatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    resignationType?: SortOrderInput | SortOrder
    _count?: gamesCountOrderByAggregateInput
    _avg?: gamesAvgOrderByAggregateInput
    _max?: gamesMaxOrderByAggregateInput
    _min?: gamesMinOrderByAggregateInput
    _sum?: gamesSumOrderByAggregateInput
  }

  export type gamesScalarWhereWithAggregatesInput = {
    AND?: gamesScalarWhereWithAggregatesInput | gamesScalarWhereWithAggregatesInput[]
    OR?: gamesScalarWhereWithAggregatesInput[]
    NOT?: gamesScalarWhereWithAggregatesInput | gamesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"games"> | string
    whitePlayerId?: StringWithAggregatesFilter<"games"> | string
    blackPlayerId?: StringNullableWithAggregatesFilter<"games"> | string | null
    tournamentId?: StringNullableWithAggregatesFilter<"games"> | string | null
    gameMode?: EnumGameModeWithAggregatesFilter<"games"> | $Enums.GameMode
    status?: EnumGameStatusWithAggregatesFilter<"games"> | $Enums.GameStatus
    stake?: IntWithAggregatesFilter<"games"> | number
    winner?: EnumPlayerNullableWithAggregatesFilter<"games"> | $Enums.Player | null
    drawOfferedBy?: EnumPlayerNullableWithAggregatesFilter<"games"> | $Enums.Player | null
    whiteScore?: IntWithAggregatesFilter<"games"> | number
    blackScore?: IntWithAggregatesFilter<"games"> | number
    boardState?: JsonWithAggregatesFilter<"games">
    currentPlayer?: EnumPlayerWithAggregatesFilter<"games"> | $Enums.Player
    dice?: IntNullableListFilter<"games">
    cubeLevel?: IntWithAggregatesFilter<"games"> | number
    cubeOwner?: EnumPlayerNullableWithAggregatesFilter<"games"> | $Enums.Player | null
    matchLength?: IntNullableWithAggregatesFilter<"games"> | number | null
    doubleOfferedBy?: StringNullableWithAggregatesFilter<"games"> | string | null
    doublePending?: BoolWithAggregatesFilter<"games"> | boolean
    cubeHistory?: JsonWithAggregatesFilter<"games">
    timeControlPreset?: EnumTimeControlPresetNullableWithAggregatesFilter<"games"> | $Enums.TimeControlPreset | null
    timeControlTotalMs?: IntNullableWithAggregatesFilter<"games"> | number | null
    timeControlIncrementMs?: IntNullableWithAggregatesFilter<"games"> | number | null
    timeControlDelayMs?: IntNullableWithAggregatesFilter<"games"> | number | null
    whiteTimeRemainingMs?: IntNullableWithAggregatesFilter<"games"> | number | null
    blackTimeRemainingMs?: IntNullableWithAggregatesFilter<"games"> | number | null
    activeTimer?: EnumPlayerNullableWithAggregatesFilter<"games"> | $Enums.Player | null
    timerUpdatedAt?: DateTimeNullableWithAggregatesFilter<"games"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"games"> | Date | string
    finishedAt?: DateTimeNullableWithAggregatesFilter<"games"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"games"> | Date | string
    resignationType?: EnumResignationTypeNullableWithAggregatesFilter<"games"> | $Enums.ResignationType | null
  }

  export type GameSessionWhereInput = {
    AND?: GameSessionWhereInput | GameSessionWhereInput[]
    OR?: GameSessionWhereInput[]
    NOT?: GameSessionWhereInput | GameSessionWhereInput[]
    id?: StringFilter<"GameSession"> | string
    gameId?: StringFilter<"GameSession"> | string
    userId?: StringFilter<"GameSession"> | string
    resumeTokenHash?: StringFilter<"GameSession"> | string
    lastAckSequence?: IntFilter<"GameSession"> | number
    lastHeartbeatAt?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    issuedAt?: DateTimeFilter<"GameSession"> | Date | string
    expiresAt?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    metadata?: JsonNullableFilter<"GameSession">
    createdAt?: DateTimeFilter<"GameSession"> | Date | string
    game?: XOR<GamesRelationFilter, gamesWhereInput>
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type GameSessionOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    resumeTokenHash?: SortOrder
    lastAckSequence?: SortOrder
    lastHeartbeatAt?: SortOrderInput | SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    game?: gamesOrderByWithRelationInput
    user?: usersOrderByWithRelationInput
  }

  export type GameSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gameId_userId?: GameSessionGameIdUserIdCompoundUniqueInput
    AND?: GameSessionWhereInput | GameSessionWhereInput[]
    OR?: GameSessionWhereInput[]
    NOT?: GameSessionWhereInput | GameSessionWhereInput[]
    gameId?: StringFilter<"GameSession"> | string
    userId?: StringFilter<"GameSession"> | string
    resumeTokenHash?: StringFilter<"GameSession"> | string
    lastAckSequence?: IntFilter<"GameSession"> | number
    lastHeartbeatAt?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    issuedAt?: DateTimeFilter<"GameSession"> | Date | string
    expiresAt?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    metadata?: JsonNullableFilter<"GameSession">
    createdAt?: DateTimeFilter<"GameSession"> | Date | string
    game?: XOR<GamesRelationFilter, gamesWhereInput>
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "gameId_userId">

  export type GameSessionOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    resumeTokenHash?: SortOrder
    lastAckSequence?: SortOrder
    lastHeartbeatAt?: SortOrderInput | SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GameSessionCountOrderByAggregateInput
    _avg?: GameSessionAvgOrderByAggregateInput
    _max?: GameSessionMaxOrderByAggregateInput
    _min?: GameSessionMinOrderByAggregateInput
    _sum?: GameSessionSumOrderByAggregateInput
  }

  export type GameSessionScalarWhereWithAggregatesInput = {
    AND?: GameSessionScalarWhereWithAggregatesInput | GameSessionScalarWhereWithAggregatesInput[]
    OR?: GameSessionScalarWhereWithAggregatesInput[]
    NOT?: GameSessionScalarWhereWithAggregatesInput | GameSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameSession"> | string
    gameId?: StringWithAggregatesFilter<"GameSession"> | string
    userId?: StringWithAggregatesFilter<"GameSession"> | string
    resumeTokenHash?: StringWithAggregatesFilter<"GameSession"> | string
    lastAckSequence?: IntWithAggregatesFilter<"GameSession"> | number
    lastHeartbeatAt?: DateTimeNullableWithAggregatesFilter<"GameSession"> | Date | string | null
    issuedAt?: DateTimeWithAggregatesFilter<"GameSession"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"GameSession"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"GameSession">
    createdAt?: DateTimeWithAggregatesFilter<"GameSession"> | Date | string
  }

  export type GameEventWhereInput = {
    AND?: GameEventWhereInput | GameEventWhereInput[]
    OR?: GameEventWhereInput[]
    NOT?: GameEventWhereInput | GameEventWhereInput[]
    id?: StringFilter<"GameEvent"> | string
    gameId?: StringFilter<"GameEvent"> | string
    sequence?: IntFilter<"GameEvent"> | number
    type?: StringFilter<"GameEvent"> | string
    payload?: JsonFilter<"GameEvent">
    createdAt?: DateTimeFilter<"GameEvent"> | Date | string
    game?: XOR<GamesRelationFilter, gamesWhereInput>
  }

  export type GameEventOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    sequence?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    createdAt?: SortOrder
    game?: gamesOrderByWithRelationInput
  }

  export type GameEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gameId_sequence?: GameEventGameIdSequenceCompoundUniqueInput
    AND?: GameEventWhereInput | GameEventWhereInput[]
    OR?: GameEventWhereInput[]
    NOT?: GameEventWhereInput | GameEventWhereInput[]
    gameId?: StringFilter<"GameEvent"> | string
    sequence?: IntFilter<"GameEvent"> | number
    type?: StringFilter<"GameEvent"> | string
    payload?: JsonFilter<"GameEvent">
    createdAt?: DateTimeFilter<"GameEvent"> | Date | string
    game?: XOR<GamesRelationFilter, gamesWhereInput>
  }, "id" | "gameId_sequence">

  export type GameEventOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    sequence?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    createdAt?: SortOrder
    _count?: GameEventCountOrderByAggregateInput
    _avg?: GameEventAvgOrderByAggregateInput
    _max?: GameEventMaxOrderByAggregateInput
    _min?: GameEventMinOrderByAggregateInput
    _sum?: GameEventSumOrderByAggregateInput
  }

  export type GameEventScalarWhereWithAggregatesInput = {
    AND?: GameEventScalarWhereWithAggregatesInput | GameEventScalarWhereWithAggregatesInput[]
    OR?: GameEventScalarWhereWithAggregatesInput[]
    NOT?: GameEventScalarWhereWithAggregatesInput | GameEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameEvent"> | string
    gameId?: StringWithAggregatesFilter<"GameEvent"> | string
    sequence?: IntWithAggregatesFilter<"GameEvent"> | number
    type?: StringWithAggregatesFilter<"GameEvent"> | string
    payload?: JsonWithAggregatesFilter<"GameEvent">
    createdAt?: DateTimeWithAggregatesFilter<"GameEvent"> | Date | string
  }

  export type matchesWhereInput = {
    AND?: matchesWhereInput | matchesWhereInput[]
    OR?: matchesWhereInput[]
    NOT?: matchesWhereInput | matchesWhereInput[]
    id?: StringFilter<"matches"> | string
    gameId?: StringFilter<"matches"> | string
    length?: IntFilter<"matches"> | number
    rules?: JsonFilter<"matches">
    state?: EnumMatchStateFilter<"matches"> | $Enums.MatchState
    crawfordUsed?: BoolFilter<"matches"> | boolean
    cubeHistory?: JsonFilter<"matches">
    createdAt?: DateTimeFilter<"matches"> | Date | string
    updatedAt?: DateTimeFilter<"matches"> | Date | string
    game?: XOR<GamesRelationFilter, gamesWhereInput>
  }

  export type matchesOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    length?: SortOrder
    rules?: SortOrder
    state?: SortOrder
    crawfordUsed?: SortOrder
    cubeHistory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    game?: gamesOrderByWithRelationInput
  }

  export type matchesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gameId?: string
    AND?: matchesWhereInput | matchesWhereInput[]
    OR?: matchesWhereInput[]
    NOT?: matchesWhereInput | matchesWhereInput[]
    length?: IntFilter<"matches"> | number
    rules?: JsonFilter<"matches">
    state?: EnumMatchStateFilter<"matches"> | $Enums.MatchState
    crawfordUsed?: BoolFilter<"matches"> | boolean
    cubeHistory?: JsonFilter<"matches">
    createdAt?: DateTimeFilter<"matches"> | Date | string
    updatedAt?: DateTimeFilter<"matches"> | Date | string
    game?: XOR<GamesRelationFilter, gamesWhereInput>
  }, "id" | "gameId">

  export type matchesOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    length?: SortOrder
    rules?: SortOrder
    state?: SortOrder
    crawfordUsed?: SortOrder
    cubeHistory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: matchesCountOrderByAggregateInput
    _avg?: matchesAvgOrderByAggregateInput
    _max?: matchesMaxOrderByAggregateInput
    _min?: matchesMinOrderByAggregateInput
    _sum?: matchesSumOrderByAggregateInput
  }

  export type matchesScalarWhereWithAggregatesInput = {
    AND?: matchesScalarWhereWithAggregatesInput | matchesScalarWhereWithAggregatesInput[]
    OR?: matchesScalarWhereWithAggregatesInput[]
    NOT?: matchesScalarWhereWithAggregatesInput | matchesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"matches"> | string
    gameId?: StringWithAggregatesFilter<"matches"> | string
    length?: IntWithAggregatesFilter<"matches"> | number
    rules?: JsonWithAggregatesFilter<"matches">
    state?: EnumMatchStateWithAggregatesFilter<"matches"> | $Enums.MatchState
    crawfordUsed?: BoolWithAggregatesFilter<"matches"> | boolean
    cubeHistory?: JsonWithAggregatesFilter<"matches">
    createdAt?: DateTimeWithAggregatesFilter<"matches"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"matches"> | Date | string
  }

  export type user_learning_progressWhereInput = {
    AND?: user_learning_progressWhereInput | user_learning_progressWhereInput[]
    OR?: user_learning_progressWhereInput[]
    NOT?: user_learning_progressWhereInput | user_learning_progressWhereInput[]
    id?: StringFilter<"user_learning_progress"> | string
    user_id?: StringFilter<"user_learning_progress"> | string
    rule_key?: StringFilter<"user_learning_progress"> | string
    viewed_at?: DateTimeFilter<"user_learning_progress"> | Date | string
    completed?: BoolFilter<"user_learning_progress"> | boolean
    completed_at?: DateTimeNullableFilter<"user_learning_progress"> | Date | string | null
    score?: IntNullableFilter<"user_learning_progress"> | number | null
    created_at?: DateTimeFilter<"user_learning_progress"> | Date | string
    updated_at?: DateTimeFilter<"user_learning_progress"> | Date | string
  }

  export type user_learning_progressOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    rule_key?: SortOrder
    viewed_at?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_learning_progressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_rule_key?: user_learning_progressUser_idRule_keyCompoundUniqueInput
    AND?: user_learning_progressWhereInput | user_learning_progressWhereInput[]
    OR?: user_learning_progressWhereInput[]
    NOT?: user_learning_progressWhereInput | user_learning_progressWhereInput[]
    user_id?: StringFilter<"user_learning_progress"> | string
    rule_key?: StringFilter<"user_learning_progress"> | string
    viewed_at?: DateTimeFilter<"user_learning_progress"> | Date | string
    completed?: BoolFilter<"user_learning_progress"> | boolean
    completed_at?: DateTimeNullableFilter<"user_learning_progress"> | Date | string | null
    score?: IntNullableFilter<"user_learning_progress"> | number | null
    created_at?: DateTimeFilter<"user_learning_progress"> | Date | string
    updated_at?: DateTimeFilter<"user_learning_progress"> | Date | string
  }, "id" | "user_id_rule_key">

  export type user_learning_progressOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    rule_key?: SortOrder
    viewed_at?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: user_learning_progressCountOrderByAggregateInput
    _avg?: user_learning_progressAvgOrderByAggregateInput
    _max?: user_learning_progressMaxOrderByAggregateInput
    _min?: user_learning_progressMinOrderByAggregateInput
    _sum?: user_learning_progressSumOrderByAggregateInput
  }

  export type user_learning_progressScalarWhereWithAggregatesInput = {
    AND?: user_learning_progressScalarWhereWithAggregatesInput | user_learning_progressScalarWhereWithAggregatesInput[]
    OR?: user_learning_progressScalarWhereWithAggregatesInput[]
    NOT?: user_learning_progressScalarWhereWithAggregatesInput | user_learning_progressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user_learning_progress"> | string
    user_id?: StringWithAggregatesFilter<"user_learning_progress"> | string
    rule_key?: StringWithAggregatesFilter<"user_learning_progress"> | string
    viewed_at?: DateTimeWithAggregatesFilter<"user_learning_progress"> | Date | string
    completed?: BoolWithAggregatesFilter<"user_learning_progress"> | boolean
    completed_at?: DateTimeNullableWithAggregatesFilter<"user_learning_progress"> | Date | string | null
    score?: IntNullableWithAggregatesFilter<"user_learning_progress"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"user_learning_progress"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"user_learning_progress"> | Date | string
  }

  export type user_achievementsWhereInput = {
    AND?: user_achievementsWhereInput | user_achievementsWhereInput[]
    OR?: user_achievementsWhereInput[]
    NOT?: user_achievementsWhereInput | user_achievementsWhereInput[]
    id?: StringFilter<"user_achievements"> | string
    user_id?: StringFilter<"user_achievements"> | string
    achievement?: StringFilter<"user_achievements"> | string
    description?: StringFilter<"user_achievements"> | string
    icon?: StringFilter<"user_achievements"> | string
    unlocked_at?: DateTimeFilter<"user_achievements"> | Date | string
    category?: StringFilter<"user_achievements"> | string
  }

  export type user_achievementsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    achievement?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    unlocked_at?: SortOrder
    category?: SortOrder
  }

  export type user_achievementsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: user_achievementsWhereInput | user_achievementsWhereInput[]
    OR?: user_achievementsWhereInput[]
    NOT?: user_achievementsWhereInput | user_achievementsWhereInput[]
    user_id?: StringFilter<"user_achievements"> | string
    achievement?: StringFilter<"user_achievements"> | string
    description?: StringFilter<"user_achievements"> | string
    icon?: StringFilter<"user_achievements"> | string
    unlocked_at?: DateTimeFilter<"user_achievements"> | Date | string
    category?: StringFilter<"user_achievements"> | string
  }, "id">

  export type user_achievementsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    achievement?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    unlocked_at?: SortOrder
    category?: SortOrder
    _count?: user_achievementsCountOrderByAggregateInput
    _max?: user_achievementsMaxOrderByAggregateInput
    _min?: user_achievementsMinOrderByAggregateInput
  }

  export type user_achievementsScalarWhereWithAggregatesInput = {
    AND?: user_achievementsScalarWhereWithAggregatesInput | user_achievementsScalarWhereWithAggregatesInput[]
    OR?: user_achievementsScalarWhereWithAggregatesInput[]
    NOT?: user_achievementsScalarWhereWithAggregatesInput | user_achievementsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user_achievements"> | string
    user_id?: StringWithAggregatesFilter<"user_achievements"> | string
    achievement?: StringWithAggregatesFilter<"user_achievements"> | string
    description?: StringWithAggregatesFilter<"user_achievements"> | string
    icon?: StringWithAggregatesFilter<"user_achievements"> | string
    unlocked_at?: DateTimeWithAggregatesFilter<"user_achievements"> | Date | string
    category?: StringWithAggregatesFilter<"user_achievements"> | string
  }

  export type user_preferencesWhereInput = {
    AND?: user_preferencesWhereInput | user_preferencesWhereInput[]
    OR?: user_preferencesWhereInput[]
    NOT?: user_preferencesWhereInput | user_preferencesWhereInput[]
    id?: StringFilter<"user_preferences"> | string
    user_id?: StringFilter<"user_preferences"> | string
    language?: StringFilter<"user_preferences"> | string
    theme?: StringFilter<"user_preferences"> | string
    sound?: BoolFilter<"user_preferences"> | boolean
    notifications?: BoolFilter<"user_preferences"> | boolean
    created_at?: DateTimeFilter<"user_preferences"> | Date | string
    updated_at?: DateTimeFilter<"user_preferences"> | Date | string
  }

  export type user_preferencesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    language?: SortOrder
    theme?: SortOrder
    sound?: SortOrder
    notifications?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_preferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id?: string
    AND?: user_preferencesWhereInput | user_preferencesWhereInput[]
    OR?: user_preferencesWhereInput[]
    NOT?: user_preferencesWhereInput | user_preferencesWhereInput[]
    language?: StringFilter<"user_preferences"> | string
    theme?: StringFilter<"user_preferences"> | string
    sound?: BoolFilter<"user_preferences"> | boolean
    notifications?: BoolFilter<"user_preferences"> | boolean
    created_at?: DateTimeFilter<"user_preferences"> | Date | string
    updated_at?: DateTimeFilter<"user_preferences"> | Date | string
  }, "id" | "user_id">

  export type user_preferencesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    language?: SortOrder
    theme?: SortOrder
    sound?: SortOrder
    notifications?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: user_preferencesCountOrderByAggregateInput
    _max?: user_preferencesMaxOrderByAggregateInput
    _min?: user_preferencesMinOrderByAggregateInput
  }

  export type user_preferencesScalarWhereWithAggregatesInput = {
    AND?: user_preferencesScalarWhereWithAggregatesInput | user_preferencesScalarWhereWithAggregatesInput[]
    OR?: user_preferencesScalarWhereWithAggregatesInput[]
    NOT?: user_preferencesScalarWhereWithAggregatesInput | user_preferencesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user_preferences"> | string
    user_id?: StringWithAggregatesFilter<"user_preferences"> | string
    language?: StringWithAggregatesFilter<"user_preferences"> | string
    theme?: StringWithAggregatesFilter<"user_preferences"> | string
    sound?: BoolWithAggregatesFilter<"user_preferences"> | boolean
    notifications?: BoolWithAggregatesFilter<"user_preferences"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"user_preferences"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"user_preferences"> | Date | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    username?: StringNullableFilter<"users"> | string | null
    firstName?: StringNullableFilter<"users"> | string | null
    lastName?: StringNullableFilter<"users"> | string | null
    avatarUrl?: StringNullableFilter<"users"> | string | null
    country?: StringNullableFilter<"users"> | string | null
    eloRating?: IntFilter<"users"> | number
    gamesPlayed?: IntFilter<"users"> | number
    gamesWon?: IntFilter<"users"> | number
    winRate?: FloatFilter<"users"> | number
    currentStreak?: IntFilter<"users"> | number
    bestStreak?: IntFilter<"users"> | number
    subscriptionType?: EnumSubscriptionTypeFilter<"users"> | $Enums.SubscriptionType
    subscriptionExpiresAt?: DateTimeNullableFilter<"users"> | Date | string | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    analyses?: AnalysesListRelationFilter
    analysisQuotas?: AnalysisQuotaListRelationFilter
    iaQuota?: XOR<IAQuotaNullableRelationFilter, IAQuotaWhereInput> | null
    sessions?: UserSessionListRelationFilter
    chatMessages?: Chat_messagesListRelationFilter
    gameMoves?: Game_movesListRelationFilter
    userAnalytics?: User_analyticsListRelationFilter
    gameAnalyses?: Game_analysesListRelationFilter
    subscription?: XOR<SubscriptionsNullableRelationFilter, subscriptionsWhereInput> | null
    tournamentParticipants?: Tournament_participantsListRelationFilter
    tournaments?: TournamentsListRelationFilter
    websocketConnections?: Websocket_connectionsListRelationFilter
    whiteGames?: GamesListRelationFilter
    blackGames?: GamesListRelationFilter
    gameSessions?: GameSessionListRelationFilter
    seasonStats?: User_season_statsListRelationFilter
    seasonLeaderboards?: Season_leaderboardListRelationFilter
    quotaHistory?: User_quota_historyListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    eloRating?: SortOrder
    gamesPlayed?: SortOrder
    gamesWon?: SortOrder
    winRate?: SortOrder
    currentStreak?: SortOrder
    bestStreak?: SortOrder
    subscriptionType?: SortOrder
    subscriptionExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    analyses?: analysesOrderByRelationAggregateInput
    analysisQuotas?: AnalysisQuotaOrderByRelationAggregateInput
    iaQuota?: IAQuotaOrderByWithRelationInput
    sessions?: UserSessionOrderByRelationAggregateInput
    chatMessages?: chat_messagesOrderByRelationAggregateInput
    gameMoves?: game_movesOrderByRelationAggregateInput
    userAnalytics?: user_analyticsOrderByRelationAggregateInput
    gameAnalyses?: game_analysesOrderByRelationAggregateInput
    subscription?: subscriptionsOrderByWithRelationInput
    tournamentParticipants?: tournament_participantsOrderByRelationAggregateInput
    tournaments?: tournamentsOrderByRelationAggregateInput
    websocketConnections?: websocket_connectionsOrderByRelationAggregateInput
    whiteGames?: gamesOrderByRelationAggregateInput
    blackGames?: gamesOrderByRelationAggregateInput
    gameSessions?: GameSessionOrderByRelationAggregateInput
    seasonStats?: user_season_statsOrderByRelationAggregateInput
    seasonLeaderboards?: season_leaderboardOrderByRelationAggregateInput
    quotaHistory?: user_quota_historyOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    password?: StringFilter<"users"> | string
    firstName?: StringNullableFilter<"users"> | string | null
    lastName?: StringNullableFilter<"users"> | string | null
    avatarUrl?: StringNullableFilter<"users"> | string | null
    country?: StringNullableFilter<"users"> | string | null
    eloRating?: IntFilter<"users"> | number
    gamesPlayed?: IntFilter<"users"> | number
    gamesWon?: IntFilter<"users"> | number
    winRate?: FloatFilter<"users"> | number
    currentStreak?: IntFilter<"users"> | number
    bestStreak?: IntFilter<"users"> | number
    subscriptionType?: EnumSubscriptionTypeFilter<"users"> | $Enums.SubscriptionType
    subscriptionExpiresAt?: DateTimeNullableFilter<"users"> | Date | string | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    analyses?: AnalysesListRelationFilter
    analysisQuotas?: AnalysisQuotaListRelationFilter
    iaQuota?: XOR<IAQuotaNullableRelationFilter, IAQuotaWhereInput> | null
    sessions?: UserSessionListRelationFilter
    chatMessages?: Chat_messagesListRelationFilter
    gameMoves?: Game_movesListRelationFilter
    userAnalytics?: User_analyticsListRelationFilter
    gameAnalyses?: Game_analysesListRelationFilter
    subscription?: XOR<SubscriptionsNullableRelationFilter, subscriptionsWhereInput> | null
    tournamentParticipants?: Tournament_participantsListRelationFilter
    tournaments?: TournamentsListRelationFilter
    websocketConnections?: Websocket_connectionsListRelationFilter
    whiteGames?: GamesListRelationFilter
    blackGames?: GamesListRelationFilter
    gameSessions?: GameSessionListRelationFilter
    seasonStats?: User_season_statsListRelationFilter
    seasonLeaderboards?: Season_leaderboardListRelationFilter
    quotaHistory?: User_quota_historyListRelationFilter
  }, "id" | "email" | "username">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    eloRating?: SortOrder
    gamesPlayed?: SortOrder
    gamesWon?: SortOrder
    winRate?: SortOrder
    currentStreak?: SortOrder
    bestStreak?: SortOrder
    subscriptionType?: SortOrder
    subscriptionExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    username?: StringNullableWithAggregatesFilter<"users"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"users"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"users"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"users"> | string | null
    country?: StringNullableWithAggregatesFilter<"users"> | string | null
    eloRating?: IntWithAggregatesFilter<"users"> | number
    gamesPlayed?: IntWithAggregatesFilter<"users"> | number
    gamesWon?: IntWithAggregatesFilter<"users"> | number
    winRate?: FloatWithAggregatesFilter<"users"> | number
    currentStreak?: IntWithAggregatesFilter<"users"> | number
    bestStreak?: IntWithAggregatesFilter<"users"> | number
    subscriptionType?: EnumSubscriptionTypeWithAggregatesFilter<"users"> | $Enums.SubscriptionType
    subscriptionExpiresAt?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
  }

  export type seasonsWhereInput = {
    AND?: seasonsWhereInput | seasonsWhereInput[]
    OR?: seasonsWhereInput[]
    NOT?: seasonsWhereInput | seasonsWhereInput[]
    id?: StringFilter<"seasons"> | string
    name?: StringFilter<"seasons"> | string
    startDate?: DateTimeFilter<"seasons"> | Date | string
    endDate?: DateTimeNullableFilter<"seasons"> | Date | string | null
    createdAt?: DateTimeFilter<"seasons"> | Date | string
    updatedAt?: DateTimeFilter<"seasons"> | Date | string
    seasonStats?: User_season_statsListRelationFilter
    leaderboards?: Season_leaderboardListRelationFilter
    quotaHistory?: User_quota_historyListRelationFilter
  }

  export type seasonsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonStats?: user_season_statsOrderByRelationAggregateInput
    leaderboards?: season_leaderboardOrderByRelationAggregateInput
    quotaHistory?: user_quota_historyOrderByRelationAggregateInput
  }

  export type seasonsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: seasonsWhereInput | seasonsWhereInput[]
    OR?: seasonsWhereInput[]
    NOT?: seasonsWhereInput | seasonsWhereInput[]
    name?: StringFilter<"seasons"> | string
    startDate?: DateTimeFilter<"seasons"> | Date | string
    endDate?: DateTimeNullableFilter<"seasons"> | Date | string | null
    createdAt?: DateTimeFilter<"seasons"> | Date | string
    updatedAt?: DateTimeFilter<"seasons"> | Date | string
    seasonStats?: User_season_statsListRelationFilter
    leaderboards?: Season_leaderboardListRelationFilter
    quotaHistory?: User_quota_historyListRelationFilter
  }, "id">

  export type seasonsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: seasonsCountOrderByAggregateInput
    _max?: seasonsMaxOrderByAggregateInput
    _min?: seasonsMinOrderByAggregateInput
  }

  export type seasonsScalarWhereWithAggregatesInput = {
    AND?: seasonsScalarWhereWithAggregatesInput | seasonsScalarWhereWithAggregatesInput[]
    OR?: seasonsScalarWhereWithAggregatesInput[]
    NOT?: seasonsScalarWhereWithAggregatesInput | seasonsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"seasons"> | string
    name?: StringWithAggregatesFilter<"seasons"> | string
    startDate?: DateTimeWithAggregatesFilter<"seasons"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"seasons"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"seasons"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"seasons"> | Date | string
  }

  export type user_season_statsWhereInput = {
    AND?: user_season_statsWhereInput | user_season_statsWhereInput[]
    OR?: user_season_statsWhereInput[]
    NOT?: user_season_statsWhereInput | user_season_statsWhereInput[]
    id?: StringFilter<"user_season_stats"> | string
    userId?: StringFilter<"user_season_stats"> | string
    seasonId?: StringFilter<"user_season_stats"> | string
    elo?: IntFilter<"user_season_stats"> | number
    winrate?: FloatFilter<"user_season_stats"> | number
    gamesPlayed?: IntFilter<"user_season_stats"> | number
    createdAt?: DateTimeFilter<"user_season_stats"> | Date | string
    updatedAt?: DateTimeFilter<"user_season_stats"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    season?: XOR<SeasonsRelationFilter, seasonsWhereInput>
  }

  export type user_season_statsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    seasonId?: SortOrder
    elo?: SortOrder
    winrate?: SortOrder
    gamesPlayed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
    season?: seasonsOrderByWithRelationInput
  }

  export type user_season_statsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_seasonId?: user_season_statsUserIdSeasonIdCompoundUniqueInput
    AND?: user_season_statsWhereInput | user_season_statsWhereInput[]
    OR?: user_season_statsWhereInput[]
    NOT?: user_season_statsWhereInput | user_season_statsWhereInput[]
    userId?: StringFilter<"user_season_stats"> | string
    seasonId?: StringFilter<"user_season_stats"> | string
    elo?: IntFilter<"user_season_stats"> | number
    winrate?: FloatFilter<"user_season_stats"> | number
    gamesPlayed?: IntFilter<"user_season_stats"> | number
    createdAt?: DateTimeFilter<"user_season_stats"> | Date | string
    updatedAt?: DateTimeFilter<"user_season_stats"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    season?: XOR<SeasonsRelationFilter, seasonsWhereInput>
  }, "id" | "userId_seasonId">

  export type user_season_statsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    seasonId?: SortOrder
    elo?: SortOrder
    winrate?: SortOrder
    gamesPlayed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: user_season_statsCountOrderByAggregateInput
    _avg?: user_season_statsAvgOrderByAggregateInput
    _max?: user_season_statsMaxOrderByAggregateInput
    _min?: user_season_statsMinOrderByAggregateInput
    _sum?: user_season_statsSumOrderByAggregateInput
  }

  export type user_season_statsScalarWhereWithAggregatesInput = {
    AND?: user_season_statsScalarWhereWithAggregatesInput | user_season_statsScalarWhereWithAggregatesInput[]
    OR?: user_season_statsScalarWhereWithAggregatesInput[]
    NOT?: user_season_statsScalarWhereWithAggregatesInput | user_season_statsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user_season_stats"> | string
    userId?: StringWithAggregatesFilter<"user_season_stats"> | string
    seasonId?: StringWithAggregatesFilter<"user_season_stats"> | string
    elo?: IntWithAggregatesFilter<"user_season_stats"> | number
    winrate?: FloatWithAggregatesFilter<"user_season_stats"> | number
    gamesPlayed?: IntWithAggregatesFilter<"user_season_stats"> | number
    createdAt?: DateTimeWithAggregatesFilter<"user_season_stats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user_season_stats"> | Date | string
  }

  export type season_leaderboardWhereInput = {
    AND?: season_leaderboardWhereInput | season_leaderboardWhereInput[]
    OR?: season_leaderboardWhereInput[]
    NOT?: season_leaderboardWhereInput | season_leaderboardWhereInput[]
    id?: StringFilter<"season_leaderboard"> | string
    seasonId?: StringFilter<"season_leaderboard"> | string
    userId?: StringFilter<"season_leaderboard"> | string
    rankGlobal?: IntFilter<"season_leaderboard"> | number
    rankCountry?: IntFilter<"season_leaderboard"> | number
    createdAt?: DateTimeFilter<"season_leaderboard"> | Date | string
    updatedAt?: DateTimeFilter<"season_leaderboard"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    season?: XOR<SeasonsRelationFilter, seasonsWhereInput>
  }

  export type season_leaderboardOrderByWithRelationInput = {
    id?: SortOrder
    seasonId?: SortOrder
    userId?: SortOrder
    rankGlobal?: SortOrder
    rankCountry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
    season?: seasonsOrderByWithRelationInput
  }

  export type season_leaderboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seasonId_userId?: season_leaderboardSeasonIdUserIdCompoundUniqueInput
    AND?: season_leaderboardWhereInput | season_leaderboardWhereInput[]
    OR?: season_leaderboardWhereInput[]
    NOT?: season_leaderboardWhereInput | season_leaderboardWhereInput[]
    seasonId?: StringFilter<"season_leaderboard"> | string
    userId?: StringFilter<"season_leaderboard"> | string
    rankGlobal?: IntFilter<"season_leaderboard"> | number
    rankCountry?: IntFilter<"season_leaderboard"> | number
    createdAt?: DateTimeFilter<"season_leaderboard"> | Date | string
    updatedAt?: DateTimeFilter<"season_leaderboard"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    season?: XOR<SeasonsRelationFilter, seasonsWhereInput>
  }, "id" | "seasonId_userId">

  export type season_leaderboardOrderByWithAggregationInput = {
    id?: SortOrder
    seasonId?: SortOrder
    userId?: SortOrder
    rankGlobal?: SortOrder
    rankCountry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: season_leaderboardCountOrderByAggregateInput
    _avg?: season_leaderboardAvgOrderByAggregateInput
    _max?: season_leaderboardMaxOrderByAggregateInput
    _min?: season_leaderboardMinOrderByAggregateInput
    _sum?: season_leaderboardSumOrderByAggregateInput
  }

  export type season_leaderboardScalarWhereWithAggregatesInput = {
    AND?: season_leaderboardScalarWhereWithAggregatesInput | season_leaderboardScalarWhereWithAggregatesInput[]
    OR?: season_leaderboardScalarWhereWithAggregatesInput[]
    NOT?: season_leaderboardScalarWhereWithAggregatesInput | season_leaderboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"season_leaderboard"> | string
    seasonId?: StringWithAggregatesFilter<"season_leaderboard"> | string
    userId?: StringWithAggregatesFilter<"season_leaderboard"> | string
    rankGlobal?: IntWithAggregatesFilter<"season_leaderboard"> | number
    rankCountry?: IntWithAggregatesFilter<"season_leaderboard"> | number
    createdAt?: DateTimeWithAggregatesFilter<"season_leaderboard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"season_leaderboard"> | Date | string
  }

  export type user_quota_historyWhereInput = {
    AND?: user_quota_historyWhereInput | user_quota_historyWhereInput[]
    OR?: user_quota_historyWhereInput[]
    NOT?: user_quota_historyWhereInput | user_quota_historyWhereInput[]
    id?: StringFilter<"user_quota_history"> | string
    userId?: StringFilter<"user_quota_history"> | string
    seasonId?: StringFilter<"user_quota_history"> | string
    quotaUsed?: IntFilter<"user_quota_history"> | number
    timestamp?: DateTimeFilter<"user_quota_history"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    season?: XOR<SeasonsRelationFilter, seasonsWhereInput>
  }

  export type user_quota_historyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    seasonId?: SortOrder
    quotaUsed?: SortOrder
    timestamp?: SortOrder
    user?: usersOrderByWithRelationInput
    season?: seasonsOrderByWithRelationInput
  }

  export type user_quota_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: user_quota_historyWhereInput | user_quota_historyWhereInput[]
    OR?: user_quota_historyWhereInput[]
    NOT?: user_quota_historyWhereInput | user_quota_historyWhereInput[]
    userId?: StringFilter<"user_quota_history"> | string
    seasonId?: StringFilter<"user_quota_history"> | string
    quotaUsed?: IntFilter<"user_quota_history"> | number
    timestamp?: DateTimeFilter<"user_quota_history"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    season?: XOR<SeasonsRelationFilter, seasonsWhereInput>
  }, "id">

  export type user_quota_historyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    seasonId?: SortOrder
    quotaUsed?: SortOrder
    timestamp?: SortOrder
    _count?: user_quota_historyCountOrderByAggregateInput
    _avg?: user_quota_historyAvgOrderByAggregateInput
    _max?: user_quota_historyMaxOrderByAggregateInput
    _min?: user_quota_historyMinOrderByAggregateInput
    _sum?: user_quota_historySumOrderByAggregateInput
  }

  export type user_quota_historyScalarWhereWithAggregatesInput = {
    AND?: user_quota_historyScalarWhereWithAggregatesInput | user_quota_historyScalarWhereWithAggregatesInput[]
    OR?: user_quota_historyScalarWhereWithAggregatesInput[]
    NOT?: user_quota_historyScalarWhereWithAggregatesInput | user_quota_historyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user_quota_history"> | string
    userId?: StringWithAggregatesFilter<"user_quota_history"> | string
    seasonId?: StringWithAggregatesFilter<"user_quota_history"> | string
    quotaUsed?: IntWithAggregatesFilter<"user_quota_history"> | number
    timestamp?: DateTimeWithAggregatesFilter<"user_quota_history"> | Date | string
  }

  export type websocket_connectionsWhereInput = {
    AND?: websocket_connectionsWhereInput | websocket_connectionsWhereInput[]
    OR?: websocket_connectionsWhereInput[]
    NOT?: websocket_connectionsWhereInput | websocket_connectionsWhereInput[]
    id?: StringFilter<"websocket_connections"> | string
    connectionId?: StringFilter<"websocket_connections"> | string
    userId?: StringFilter<"websocket_connections"> | string
    gameId?: StringNullableFilter<"websocket_connections"> | string | null
    connectedAt?: DateTimeFilter<"websocket_connections"> | Date | string
    lastPing?: DateTimeFilter<"websocket_connections"> | Date | string
    isActive?: BoolFilter<"websocket_connections"> | boolean
    game?: XOR<GamesNullableRelationFilter, gamesWhereInput> | null
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type websocket_connectionsOrderByWithRelationInput = {
    id?: SortOrder
    connectionId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrderInput | SortOrder
    connectedAt?: SortOrder
    lastPing?: SortOrder
    isActive?: SortOrder
    game?: gamesOrderByWithRelationInput
    user?: usersOrderByWithRelationInput
  }

  export type websocket_connectionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    connectionId?: string
    AND?: websocket_connectionsWhereInput | websocket_connectionsWhereInput[]
    OR?: websocket_connectionsWhereInput[]
    NOT?: websocket_connectionsWhereInput | websocket_connectionsWhereInput[]
    userId?: StringFilter<"websocket_connections"> | string
    gameId?: StringNullableFilter<"websocket_connections"> | string | null
    connectedAt?: DateTimeFilter<"websocket_connections"> | Date | string
    lastPing?: DateTimeFilter<"websocket_connections"> | Date | string
    isActive?: BoolFilter<"websocket_connections"> | boolean
    game?: XOR<GamesNullableRelationFilter, gamesWhereInput> | null
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "connectionId">

  export type websocket_connectionsOrderByWithAggregationInput = {
    id?: SortOrder
    connectionId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrderInput | SortOrder
    connectedAt?: SortOrder
    lastPing?: SortOrder
    isActive?: SortOrder
    _count?: websocket_connectionsCountOrderByAggregateInput
    _max?: websocket_connectionsMaxOrderByAggregateInput
    _min?: websocket_connectionsMinOrderByAggregateInput
  }

  export type websocket_connectionsScalarWhereWithAggregatesInput = {
    AND?: websocket_connectionsScalarWhereWithAggregatesInput | websocket_connectionsScalarWhereWithAggregatesInput[]
    OR?: websocket_connectionsScalarWhereWithAggregatesInput[]
    NOT?: websocket_connectionsScalarWhereWithAggregatesInput | websocket_connectionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"websocket_connections"> | string
    connectionId?: StringWithAggregatesFilter<"websocket_connections"> | string
    userId?: StringWithAggregatesFilter<"websocket_connections"> | string
    gameId?: StringNullableWithAggregatesFilter<"websocket_connections"> | string | null
    connectedAt?: DateTimeWithAggregatesFilter<"websocket_connections"> | Date | string
    lastPing?: DateTimeWithAggregatesFilter<"websocket_connections"> | Date | string
    isActive?: BoolWithAggregatesFilter<"websocket_connections"> | boolean
  }

  export type analysesCreateInput = {
    id: string
    boardState: string
    dice?: analysesCreatediceInput | number[]
    move: string
    bestMove: string
    equity: number
    pr: number
    explanation: string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysisType?: $Enums.AnalysisType
    createdAt?: Date | string
    user: usersCreateNestedOneWithoutAnalysesInput
  }

  export type analysesUncheckedCreateInput = {
    id: string
    userId: string
    boardState: string
    dice?: analysesCreatediceInput | number[]
    move: string
    bestMove: string
    equity: number
    pr: number
    explanation: string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysisType?: $Enums.AnalysisType
    createdAt?: Date | string
  }

  export type analysesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardState?: StringFieldUpdateOperationsInput | string
    dice?: analysesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    bestMove?: StringFieldUpdateOperationsInput | string
    equity?: FloatFieldUpdateOperationsInput | number
    pr?: FloatFieldUpdateOperationsInput | number
    explanation?: StringFieldUpdateOperationsInput | string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutAnalysesNestedInput
  }

  export type analysesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    boardState?: StringFieldUpdateOperationsInput | string
    dice?: analysesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    bestMove?: StringFieldUpdateOperationsInput | string
    equity?: FloatFieldUpdateOperationsInput | number
    pr?: FloatFieldUpdateOperationsInput | number
    explanation?: StringFieldUpdateOperationsInput | string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analysesCreateManyInput = {
    id: string
    userId: string
    boardState: string
    dice?: analysesCreatediceInput | number[]
    move: string
    bestMove: string
    equity: number
    pr: number
    explanation: string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysisType?: $Enums.AnalysisType
    createdAt?: Date | string
  }

  export type analysesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardState?: StringFieldUpdateOperationsInput | string
    dice?: analysesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    bestMove?: StringFieldUpdateOperationsInput | string
    equity?: FloatFieldUpdateOperationsInput | number
    pr?: FloatFieldUpdateOperationsInput | number
    explanation?: StringFieldUpdateOperationsInput | string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analysesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    boardState?: StringFieldUpdateOperationsInput | string
    dice?: analysesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    bestMove?: StringFieldUpdateOperationsInput | string
    equity?: FloatFieldUpdateOperationsInput | number
    pr?: FloatFieldUpdateOperationsInput | number
    explanation?: StringFieldUpdateOperationsInput | string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisQuotaCreateInput = {
    id?: string
    date: Date | string
    count: number
    extraQuota?: number
    initialFree?: boolean
    user: usersCreateNestedOneWithoutAnalysisQuotasInput
  }

  export type AnalysisQuotaUncheckedCreateInput = {
    id?: string
    userId: string
    date: Date | string
    count: number
    extraQuota?: number
    initialFree?: boolean
  }

  export type AnalysisQuotaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    extraQuota?: IntFieldUpdateOperationsInput | number
    initialFree?: BoolFieldUpdateOperationsInput | boolean
    user?: usersUpdateOneRequiredWithoutAnalysisQuotasNestedInput
  }

  export type AnalysisQuotaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    extraQuota?: IntFieldUpdateOperationsInput | number
    initialFree?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnalysisQuotaCreateManyInput = {
    id?: string
    userId: string
    date: Date | string
    count: number
    extraQuota?: number
    initialFree?: boolean
  }

  export type AnalysisQuotaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    extraQuota?: IntFieldUpdateOperationsInput | number
    initialFree?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnalysisQuotaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    extraQuota?: IntFieldUpdateOperationsInput | number
    initialFree?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IAQuotaCreateInput = {
    id?: string
    dailyQuota?: number
    premiumQuota?: number
    extrasUsed?: number
    resetAt: Date | string
    user: usersCreateNestedOneWithoutIaQuotaInput
  }

  export type IAQuotaUncheckedCreateInput = {
    id?: string
    userId: string
    dailyQuota?: number
    premiumQuota?: number
    extrasUsed?: number
    resetAt: Date | string
  }

  export type IAQuotaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dailyQuota?: IntFieldUpdateOperationsInput | number
    premiumQuota?: IntFieldUpdateOperationsInput | number
    extrasUsed?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutIaQuotaNestedInput
  }

  export type IAQuotaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dailyQuota?: IntFieldUpdateOperationsInput | number
    premiumQuota?: IntFieldUpdateOperationsInput | number
    extrasUsed?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IAQuotaCreateManyInput = {
    id?: string
    userId: string
    dailyQuota?: number
    premiumQuota?: number
    extrasUsed?: number
    resetAt: Date | string
  }

  export type IAQuotaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dailyQuota?: IntFieldUpdateOperationsInput | number
    premiumQuota?: IntFieldUpdateOperationsInput | number
    extrasUsed?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IAQuotaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dailyQuota?: IntFieldUpdateOperationsInput | number
    premiumQuota?: IntFieldUpdateOperationsInput | number
    extrasUsed?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateInput = {
    id?: string
    tokenHash: string
    jti: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: string
    userId: string
    tokenHash: string
    jti: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateManyInput = {
    id?: string
    userId: string
    tokenHash: string
    jti: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesCreateInput = {
    id: string
    message: string
    messageType?: $Enums.MessageType
    createdAt?: Date | string
    game: gamesCreateNestedOneWithoutChatMessagesInput
    user?: usersCreateNestedOneWithoutChatMessagesInput
  }

  export type chat_messagesUncheckedCreateInput = {
    id: string
    gameId: string
    userId?: string | null
    message: string
    messageType?: $Enums.MessageType
    createdAt?: Date | string
  }

  export type chat_messagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: gamesUpdateOneRequiredWithoutChatMessagesNestedInput
    user?: usersUpdateOneWithoutChatMessagesNestedInput
  }

  export type chat_messagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesCreateManyInput = {
    id: string
    gameId: string
    userId?: string | null
    message: string
    messageType?: $Enums.MessageType
    createdAt?: Date | string
  }

  export type chat_messagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_movesCreateInput = {
    id: string
    player: $Enums.Player
    dice?: game_movesCreatediceInput | number[]
    move: string
    fromPoint?: number | null
    toPoint?: number | null
    equity?: number | null
    pr?: number | null
    thinkingTime?: number | null
    createdAt?: Date | string
    game: gamesCreateNestedOneWithoutGameMovesInput
    user?: usersCreateNestedOneWithoutGameMovesInput
  }

  export type game_movesUncheckedCreateInput = {
    id: string
    gameId: string
    userId?: string | null
    player: $Enums.Player
    dice?: game_movesCreatediceInput | number[]
    move: string
    fromPoint?: number | null
    toPoint?: number | null
    equity?: number | null
    pr?: number | null
    thinkingTime?: number | null
    createdAt?: Date | string
  }

  export type game_movesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    fromPoint?: NullableIntFieldUpdateOperationsInput | number | null
    toPoint?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinkingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: gamesUpdateOneRequiredWithoutGameMovesNestedInput
    user?: usersUpdateOneWithoutGameMovesNestedInput
  }

  export type game_movesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    fromPoint?: NullableIntFieldUpdateOperationsInput | number | null
    toPoint?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinkingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_movesCreateManyInput = {
    id: string
    gameId: string
    userId?: string | null
    player: $Enums.Player
    dice?: game_movesCreatediceInput | number[]
    move: string
    fromPoint?: number | null
    toPoint?: number | null
    equity?: number | null
    pr?: number | null
    thinkingTime?: number | null
    createdAt?: Date | string
  }

  export type game_movesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    fromPoint?: NullableIntFieldUpdateOperationsInput | number | null
    toPoint?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinkingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_movesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    fromPoint?: NullableIntFieldUpdateOperationsInput | number | null
    toPoint?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinkingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionsCreateInput = {
    id: string
    stripe_subscription_id?: string | null
    stripe_customer_id?: string | null
    plan: $Enums.SubscriptionPlan
    status: $Enums.SubscriptionStatus
    current_period_start?: Date | string | null
    current_period_end?: Date | string | null
    cancel_at_period_end?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    users: usersCreateNestedOneWithoutSubscriptionInput
  }

  export type subscriptionsUncheckedCreateInput = {
    id: string
    user_id: string
    stripe_subscription_id?: string | null
    stripe_customer_id?: string | null
    plan: $Enums.SubscriptionPlan
    status: $Enums.SubscriptionStatus
    current_period_start?: Date | string | null
    current_period_end?: Date | string | null
    cancel_at_period_end?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type subscriptionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    current_period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type subscriptionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    current_period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionsCreateManyInput = {
    id: string
    user_id: string
    stripe_subscription_id?: string | null
    stripe_customer_id?: string | null
    plan: $Enums.SubscriptionPlan
    status: $Enums.SubscriptionStatus
    current_period_start?: Date | string | null
    current_period_end?: Date | string | null
    cancel_at_period_end?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type subscriptionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    current_period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    current_period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournament_participantsCreateInput = {
    id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
    tournaments: tournamentsCreateNestedOneWithoutParticipantsInput
    users: usersCreateNestedOneWithoutTournamentParticipantsInput
    whiteMatches?: tournament_matchesCreateNestedManyWithoutWhiteInput
    blackMatches?: tournament_matchesCreateNestedManyWithoutBlackInput
    wonMatches?: tournament_matchesCreateNestedManyWithoutWinnerInput
  }

  export type tournament_participantsUncheckedCreateInput = {
    id: string
    tournament_id: string
    user_id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
    whiteMatches?: tournament_matchesUncheckedCreateNestedManyWithoutWhiteInput
    blackMatches?: tournament_matchesUncheckedCreateNestedManyWithoutBlackInput
    wonMatches?: tournament_matchesUncheckedCreateNestedManyWithoutWinnerInput
  }

  export type tournament_participantsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tournaments?: tournamentsUpdateOneRequiredWithoutParticipantsNestedInput
    users?: usersUpdateOneRequiredWithoutTournamentParticipantsNestedInput
    whiteMatches?: tournament_matchesUpdateManyWithoutWhiteNestedInput
    blackMatches?: tournament_matchesUpdateManyWithoutBlackNestedInput
    wonMatches?: tournament_matchesUpdateManyWithoutWinnerNestedInput
  }

  export type tournament_participantsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournament_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whiteMatches?: tournament_matchesUncheckedUpdateManyWithoutWhiteNestedInput
    blackMatches?: tournament_matchesUncheckedUpdateManyWithoutBlackNestedInput
    wonMatches?: tournament_matchesUncheckedUpdateManyWithoutWinnerNestedInput
  }

  export type tournament_participantsCreateManyInput = {
    id: string
    tournament_id: string
    user_id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
  }

  export type tournament_participantsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tournament_participantsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournament_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tournament_matchesCreateInput = {
    id?: string
    round: number
    matchNumber: number
    status?: $Enums.TournamentMatchStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournament: tournamentsCreateNestedOneWithoutMatchesInput
    white?: tournament_participantsCreateNestedOneWithoutWhiteMatchesInput
    black?: tournament_participantsCreateNestedOneWithoutBlackMatchesInput
    winner?: tournament_participantsCreateNestedOneWithoutWonMatchesInput
    game?: gamesCreateNestedOneWithoutTournamentMatchInput
  }

  export type tournament_matchesUncheckedCreateInput = {
    id?: string
    tournamentId: string
    round: number
    matchNumber: number
    whiteParticipantId?: string | null
    blackParticipantId?: string | null
    winnerParticipantId?: string | null
    status?: $Enums.TournamentMatchStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    gameId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tournament_matchesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumTournamentMatchStatusFieldUpdateOperationsInput | $Enums.TournamentMatchStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: tournamentsUpdateOneRequiredWithoutMatchesNestedInput
    white?: tournament_participantsUpdateOneWithoutWhiteMatchesNestedInput
    black?: tournament_participantsUpdateOneWithoutBlackMatchesNestedInput
    winner?: tournament_participantsUpdateOneWithoutWonMatchesNestedInput
    game?: gamesUpdateOneWithoutTournamentMatchNestedInput
  }

  export type tournament_matchesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    whiteParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    blackParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTournamentMatchStatusFieldUpdateOperationsInput | $Enums.TournamentMatchStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournament_matchesCreateManyInput = {
    id?: string
    tournamentId: string
    round: number
    matchNumber: number
    whiteParticipantId?: string | null
    blackParticipantId?: string | null
    winnerParticipantId?: string | null
    status?: $Enums.TournamentMatchStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    gameId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tournament_matchesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumTournamentMatchStatusFieldUpdateOperationsInput | $Enums.TournamentMatchStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournament_matchesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    whiteParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    blackParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTournamentMatchStatusFieldUpdateOperationsInput | $Enums.TournamentMatchStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournamentsCreateInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    games?: gamesCreateNestedManyWithoutTournamentInput
    participants?: tournament_participantsCreateNestedManyWithoutTournamentsInput
    matches?: tournament_matchesCreateNestedManyWithoutTournamentInput
    creator: usersCreateNestedOneWithoutTournamentsInput
  }

  export type tournamentsUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    games?: gamesUncheckedCreateNestedManyWithoutTournamentInput
    participants?: tournament_participantsUncheckedCreateNestedManyWithoutTournamentsInput
    matches?: tournament_matchesUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type tournamentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: gamesUpdateManyWithoutTournamentNestedInput
    participants?: tournament_participantsUpdateManyWithoutTournamentsNestedInput
    matches?: tournament_matchesUpdateManyWithoutTournamentNestedInput
    creator?: usersUpdateOneRequiredWithoutTournamentsNestedInput
  }

  export type tournamentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: gamesUncheckedUpdateManyWithoutTournamentNestedInput
    participants?: tournament_participantsUncheckedUpdateManyWithoutTournamentsNestedInput
    matches?: tournament_matchesUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type tournamentsCreateManyInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type tournamentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournamentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_analyticsCreateInput = {
    id: string
    date?: Date | string
    games_played?: number
    games_won?: number
    analyses_completed?: number
    time_played?: number
    avg_equity?: number
    elo_change?: number
    claude_requests_today?: number
    claude_requests_this_month?: number
    claude_quota_remaining?: number
    chatgpt_requests_today?: number
    chatgpt_requests_this_month?: number
    gurubot_requests_today?: number
    gurubot_requests_this_month?: number
    gurubot_quota_remaining?: number
    easybot_requests_today?: number
    createdAt?: Date | string
    users: usersCreateNestedOneWithoutUserAnalyticsInput
  }

  export type user_analyticsUncheckedCreateInput = {
    id: string
    user_id: string
    date?: Date | string
    games_played?: number
    games_won?: number
    analyses_completed?: number
    time_played?: number
    avg_equity?: number
    elo_change?: number
    claude_requests_today?: number
    claude_requests_this_month?: number
    claude_quota_remaining?: number
    chatgpt_requests_today?: number
    chatgpt_requests_this_month?: number
    gurubot_requests_today?: number
    gurubot_requests_this_month?: number
    gurubot_quota_remaining?: number
    easybot_requests_today?: number
    createdAt?: Date | string
  }

  export type user_analyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    games_played?: IntFieldUpdateOperationsInput | number
    games_won?: IntFieldUpdateOperationsInput | number
    analyses_completed?: IntFieldUpdateOperationsInput | number
    time_played?: IntFieldUpdateOperationsInput | number
    avg_equity?: FloatFieldUpdateOperationsInput | number
    elo_change?: IntFieldUpdateOperationsInput | number
    claude_requests_today?: IntFieldUpdateOperationsInput | number
    claude_requests_this_month?: IntFieldUpdateOperationsInput | number
    claude_quota_remaining?: IntFieldUpdateOperationsInput | number
    chatgpt_requests_today?: IntFieldUpdateOperationsInput | number
    chatgpt_requests_this_month?: IntFieldUpdateOperationsInput | number
    gurubot_requests_today?: IntFieldUpdateOperationsInput | number
    gurubot_requests_this_month?: IntFieldUpdateOperationsInput | number
    gurubot_quota_remaining?: IntFieldUpdateOperationsInput | number
    easybot_requests_today?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutUserAnalyticsNestedInput
  }

  export type user_analyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    games_played?: IntFieldUpdateOperationsInput | number
    games_won?: IntFieldUpdateOperationsInput | number
    analyses_completed?: IntFieldUpdateOperationsInput | number
    time_played?: IntFieldUpdateOperationsInput | number
    avg_equity?: FloatFieldUpdateOperationsInput | number
    elo_change?: IntFieldUpdateOperationsInput | number
    claude_requests_today?: IntFieldUpdateOperationsInput | number
    claude_requests_this_month?: IntFieldUpdateOperationsInput | number
    claude_quota_remaining?: IntFieldUpdateOperationsInput | number
    chatgpt_requests_today?: IntFieldUpdateOperationsInput | number
    chatgpt_requests_this_month?: IntFieldUpdateOperationsInput | number
    gurubot_requests_today?: IntFieldUpdateOperationsInput | number
    gurubot_requests_this_month?: IntFieldUpdateOperationsInput | number
    gurubot_quota_remaining?: IntFieldUpdateOperationsInput | number
    easybot_requests_today?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_analyticsCreateManyInput = {
    id: string
    user_id: string
    date?: Date | string
    games_played?: number
    games_won?: number
    analyses_completed?: number
    time_played?: number
    avg_equity?: number
    elo_change?: number
    claude_requests_today?: number
    claude_requests_this_month?: number
    claude_quota_remaining?: number
    chatgpt_requests_today?: number
    chatgpt_requests_this_month?: number
    gurubot_requests_today?: number
    gurubot_requests_this_month?: number
    gurubot_quota_remaining?: number
    easybot_requests_today?: number
    createdAt?: Date | string
  }

  export type user_analyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    games_played?: IntFieldUpdateOperationsInput | number
    games_won?: IntFieldUpdateOperationsInput | number
    analyses_completed?: IntFieldUpdateOperationsInput | number
    time_played?: IntFieldUpdateOperationsInput | number
    avg_equity?: FloatFieldUpdateOperationsInput | number
    elo_change?: IntFieldUpdateOperationsInput | number
    claude_requests_today?: IntFieldUpdateOperationsInput | number
    claude_requests_this_month?: IntFieldUpdateOperationsInput | number
    claude_quota_remaining?: IntFieldUpdateOperationsInput | number
    chatgpt_requests_today?: IntFieldUpdateOperationsInput | number
    chatgpt_requests_this_month?: IntFieldUpdateOperationsInput | number
    gurubot_requests_today?: IntFieldUpdateOperationsInput | number
    gurubot_requests_this_month?: IntFieldUpdateOperationsInput | number
    gurubot_quota_remaining?: IntFieldUpdateOperationsInput | number
    easybot_requests_today?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_analyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    games_played?: IntFieldUpdateOperationsInput | number
    games_won?: IntFieldUpdateOperationsInput | number
    analyses_completed?: IntFieldUpdateOperationsInput | number
    time_played?: IntFieldUpdateOperationsInput | number
    avg_equity?: FloatFieldUpdateOperationsInput | number
    elo_change?: IntFieldUpdateOperationsInput | number
    claude_requests_today?: IntFieldUpdateOperationsInput | number
    claude_requests_this_month?: IntFieldUpdateOperationsInput | number
    claude_quota_remaining?: IntFieldUpdateOperationsInput | number
    chatgpt_requests_today?: IntFieldUpdateOperationsInput | number
    chatgpt_requests_this_month?: IntFieldUpdateOperationsInput | number
    gurubot_requests_today?: IntFieldUpdateOperationsInput | number
    gurubot_requests_this_month?: IntFieldUpdateOperationsInput | number
    gurubot_quota_remaining?: IntFieldUpdateOperationsInput | number
    easybot_requests_today?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_analysesCreateInput = {
    id?: string
    game_id: string
    analysis_report: JsonNullValueInput | InputJsonValue
    ai_services_used?: game_analysesCreateai_services_usedInput | string[]
    created_at?: Date | string
    users: usersCreateNestedOneWithoutGameAnalysesInput
  }

  export type game_analysesUncheckedCreateInput = {
    id?: string
    user_id: string
    game_id: string
    analysis_report: JsonNullValueInput | InputJsonValue
    ai_services_used?: game_analysesCreateai_services_usedInput | string[]
    created_at?: Date | string
  }

  export type game_analysesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    game_id?: StringFieldUpdateOperationsInput | string
    analysis_report?: JsonNullValueInput | InputJsonValue
    ai_services_used?: game_analysesUpdateai_services_usedInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutGameAnalysesNestedInput
  }

  export type game_analysesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    game_id?: StringFieldUpdateOperationsInput | string
    analysis_report?: JsonNullValueInput | InputJsonValue
    ai_services_used?: game_analysesUpdateai_services_usedInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_analysesCreateManyInput = {
    id?: string
    user_id: string
    game_id: string
    analysis_report: JsonNullValueInput | InputJsonValue
    ai_services_used?: game_analysesCreateai_services_usedInput | string[]
    created_at?: Date | string
  }

  export type game_analysesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    game_id?: StringFieldUpdateOperationsInput | string
    analysis_report?: JsonNullValueInput | InputJsonValue
    ai_services_used?: game_analysesUpdateai_services_usedInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_analysesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    game_id?: StringFieldUpdateOperationsInput | string
    analysis_report?: JsonNullValueInput | InputJsonValue
    ai_services_used?: game_analysesUpdateai_services_usedInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type gamesCreateInput = {
    id: string
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesCreateNestedManyWithoutGameInput
    gameMoves?: game_movesCreateNestedManyWithoutGameInput
    tournament?: tournamentsCreateNestedOneWithoutGamesInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutGameInput
    whitePlayer: usersCreateNestedOneWithoutWhiteGamesInput
    blackPlayer?: usersCreateNestedOneWithoutBlackGamesInput
    match?: matchesCreateNestedOneWithoutGameInput
    tournamentMatch?: tournament_matchesCreateNestedOneWithoutGameInput
    sessions?: GameSessionCreateNestedManyWithoutGameInput
    events?: GameEventCreateNestedManyWithoutGameInput
  }

  export type gamesUncheckedCreateInput = {
    id: string
    whitePlayerId: string
    blackPlayerId?: string | null
    tournamentId?: string | null
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutGameInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutGameInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutGameInput
    match?: matchesUncheckedCreateNestedOneWithoutGameInput
    tournamentMatch?: tournament_matchesUncheckedCreateNestedOneWithoutGameInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    events?: GameEventUncheckedCreateNestedManyWithoutGameInput
  }

  export type gamesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUpdateManyWithoutGameNestedInput
    gameMoves?: game_movesUpdateManyWithoutGameNestedInput
    tournament?: tournamentsUpdateOneWithoutGamesNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutGameNestedInput
    whitePlayer?: usersUpdateOneRequiredWithoutWhiteGamesNestedInput
    blackPlayer?: usersUpdateOneWithoutBlackGamesNestedInput
    match?: matchesUpdateOneWithoutGameNestedInput
    tournamentMatch?: tournament_matchesUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUpdateManyWithoutGameNestedInput
    events?: GameEventUpdateManyWithoutGameNestedInput
  }

  export type gamesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    whitePlayerId?: StringFieldUpdateOperationsInput | string
    blackPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutGameNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutGameNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutGameNestedInput
    match?: matchesUncheckedUpdateOneWithoutGameNestedInput
    tournamentMatch?: tournament_matchesUncheckedUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    events?: GameEventUncheckedUpdateManyWithoutGameNestedInput
  }

  export type gamesCreateManyInput = {
    id: string
    whitePlayerId: string
    blackPlayerId?: string | null
    tournamentId?: string | null
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
  }

  export type gamesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
  }

  export type gamesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    whitePlayerId?: StringFieldUpdateOperationsInput | string
    blackPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
  }

  export type GameSessionCreateInput = {
    id?: string
    resumeTokenHash: string
    lastAckSequence?: number
    lastHeartbeatAt?: Date | string | null
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    game: gamesCreateNestedOneWithoutSessionsInput
    user: usersCreateNestedOneWithoutGameSessionsInput
  }

  export type GameSessionUncheckedCreateInput = {
    id?: string
    gameId: string
    userId: string
    resumeTokenHash: string
    lastAckSequence?: number
    lastHeartbeatAt?: Date | string | null
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GameSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeTokenHash?: StringFieldUpdateOperationsInput | string
    lastAckSequence?: IntFieldUpdateOperationsInput | number
    lastHeartbeatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: gamesUpdateOneRequiredWithoutSessionsNestedInput
    user?: usersUpdateOneRequiredWithoutGameSessionsNestedInput
  }

  export type GameSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeTokenHash?: StringFieldUpdateOperationsInput | string
    lastAckSequence?: IntFieldUpdateOperationsInput | number
    lastHeartbeatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionCreateManyInput = {
    id?: string
    gameId: string
    userId: string
    resumeTokenHash: string
    lastAckSequence?: number
    lastHeartbeatAt?: Date | string | null
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GameSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeTokenHash?: StringFieldUpdateOperationsInput | string
    lastAckSequence?: IntFieldUpdateOperationsInput | number
    lastHeartbeatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeTokenHash?: StringFieldUpdateOperationsInput | string
    lastAckSequence?: IntFieldUpdateOperationsInput | number
    lastHeartbeatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameEventCreateInput = {
    id?: string
    sequence: number
    type: string
    payload: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    game: gamesCreateNestedOneWithoutEventsInput
  }

  export type GameEventUncheckedCreateInput = {
    id?: string
    gameId: string
    sequence: number
    type: string
    payload: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GameEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: gamesUpdateOneRequiredWithoutEventsNestedInput
  }

  export type GameEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameEventCreateManyInput = {
    id?: string
    gameId: string
    sequence: number
    type: string
    payload: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GameEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type matchesCreateInput = {
    id?: string
    length: number
    rules?: JsonNullValueInput | InputJsonValue
    state?: $Enums.MatchState
    crawfordUsed?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    game: gamesCreateNestedOneWithoutMatchInput
  }

  export type matchesUncheckedCreateInput = {
    id?: string
    gameId: string
    length: number
    rules?: JsonNullValueInput | InputJsonValue
    state?: $Enums.MatchState
    crawfordUsed?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type matchesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    rules?: JsonNullValueInput | InputJsonValue
    state?: EnumMatchStateFieldUpdateOperationsInput | $Enums.MatchState
    crawfordUsed?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: gamesUpdateOneRequiredWithoutMatchNestedInput
  }

  export type matchesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    rules?: JsonNullValueInput | InputJsonValue
    state?: EnumMatchStateFieldUpdateOperationsInput | $Enums.MatchState
    crawfordUsed?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type matchesCreateManyInput = {
    id?: string
    gameId: string
    length: number
    rules?: JsonNullValueInput | InputJsonValue
    state?: $Enums.MatchState
    crawfordUsed?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type matchesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    rules?: JsonNullValueInput | InputJsonValue
    state?: EnumMatchStateFieldUpdateOperationsInput | $Enums.MatchState
    crawfordUsed?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type matchesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    rules?: JsonNullValueInput | InputJsonValue
    state?: EnumMatchStateFieldUpdateOperationsInput | $Enums.MatchState
    crawfordUsed?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_learning_progressCreateInput = {
    id?: string
    user_id: string
    rule_key: string
    viewed_at?: Date | string
    completed?: boolean
    completed_at?: Date | string | null
    score?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_learning_progressUncheckedCreateInput = {
    id?: string
    user_id: string
    rule_key: string
    viewed_at?: Date | string
    completed?: boolean
    completed_at?: Date | string | null
    score?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_learning_progressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    rule_key?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_learning_progressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    rule_key?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_learning_progressCreateManyInput = {
    id?: string
    user_id: string
    rule_key: string
    viewed_at?: Date | string
    completed?: boolean
    completed_at?: Date | string | null
    score?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_learning_progressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    rule_key?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_learning_progressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    rule_key?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_achievementsCreateInput = {
    id?: string
    user_id: string
    achievement: string
    description: string
    icon: string
    unlocked_at?: Date | string
    category: string
  }

  export type user_achievementsUncheckedCreateInput = {
    id?: string
    user_id: string
    achievement: string
    description: string
    icon: string
    unlocked_at?: Date | string
    category: string
  }

  export type user_achievementsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    achievement?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    unlocked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type user_achievementsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    achievement?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    unlocked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type user_achievementsCreateManyInput = {
    id?: string
    user_id: string
    achievement: string
    description: string
    icon: string
    unlocked_at?: Date | string
    category: string
  }

  export type user_achievementsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    achievement?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    unlocked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type user_achievementsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    achievement?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    unlocked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type user_preferencesCreateInput = {
    id?: string
    user_id: string
    language?: string
    theme?: string
    sound?: boolean
    notifications?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_preferencesUncheckedCreateInput = {
    id?: string
    user_id: string
    language?: string
    theme?: string
    sound?: boolean
    notifications?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_preferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    sound?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_preferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    sound?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_preferencesCreateManyInput = {
    id?: string
    user_id: string
    language?: string
    theme?: string
    sound?: boolean
    notifications?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_preferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    sound?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_preferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    sound?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesCreateNestedManyWithoutUserInput
    gameMoves?: game_movesCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutUserInput
    whiteGames?: gamesCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaUncheckedCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutUserInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesUncheckedCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutUserInput
    whiteGames?: gamesUncheckedCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesUncheckedCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUncheckedUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUncheckedUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUncheckedUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUncheckedUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUncheckedUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateManyInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type seasonsCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonStats?: user_season_statsCreateNestedManyWithoutSeasonInput
    leaderboards?: season_leaderboardCreateNestedManyWithoutSeasonInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutSeasonInput
  }

  export type seasonsUncheckedCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutSeasonInput
    leaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutSeasonInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type seasonsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonStats?: user_season_statsUpdateManyWithoutSeasonNestedInput
    leaderboards?: season_leaderboardUpdateManyWithoutSeasonNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutSeasonNestedInput
  }

  export type seasonsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutSeasonNestedInput
    leaderboards?: season_leaderboardUncheckedUpdateManyWithoutSeasonNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type seasonsCreateManyInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type seasonsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type seasonsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_season_statsCreateInput = {
    id?: string
    elo: number
    winrate: number
    gamesPlayed: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutSeasonStatsInput
    season: seasonsCreateNestedOneWithoutSeasonStatsInput
  }

  export type user_season_statsUncheckedCreateInput = {
    id?: string
    userId: string
    seasonId: string
    elo: number
    winrate: number
    gamesPlayed: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_season_statsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    elo?: IntFieldUpdateOperationsInput | number
    winrate?: FloatFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutSeasonStatsNestedInput
    season?: seasonsUpdateOneRequiredWithoutSeasonStatsNestedInput
  }

  export type user_season_statsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    elo?: IntFieldUpdateOperationsInput | number
    winrate?: FloatFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_season_statsCreateManyInput = {
    id?: string
    userId: string
    seasonId: string
    elo: number
    winrate: number
    gamesPlayed: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_season_statsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    elo?: IntFieldUpdateOperationsInput | number
    winrate?: FloatFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_season_statsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    elo?: IntFieldUpdateOperationsInput | number
    winrate?: FloatFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type season_leaderboardCreateInput = {
    id?: string
    rankGlobal: number
    rankCountry: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutSeasonLeaderboardsInput
    season: seasonsCreateNestedOneWithoutLeaderboardsInput
  }

  export type season_leaderboardUncheckedCreateInput = {
    id?: string
    seasonId: string
    userId: string
    rankGlobal: number
    rankCountry: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type season_leaderboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rankGlobal?: IntFieldUpdateOperationsInput | number
    rankCountry?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutSeasonLeaderboardsNestedInput
    season?: seasonsUpdateOneRequiredWithoutLeaderboardsNestedInput
  }

  export type season_leaderboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rankGlobal?: IntFieldUpdateOperationsInput | number
    rankCountry?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type season_leaderboardCreateManyInput = {
    id?: string
    seasonId: string
    userId: string
    rankGlobal: number
    rankCountry: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type season_leaderboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rankGlobal?: IntFieldUpdateOperationsInput | number
    rankCountry?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type season_leaderboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rankGlobal?: IntFieldUpdateOperationsInput | number
    rankCountry?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_quota_historyCreateInput = {
    id?: string
    quotaUsed: number
    timestamp?: Date | string
    user: usersCreateNestedOneWithoutQuotaHistoryInput
    season: seasonsCreateNestedOneWithoutQuotaHistoryInput
  }

  export type user_quota_historyUncheckedCreateInput = {
    id?: string
    userId: string
    seasonId: string
    quotaUsed: number
    timestamp?: Date | string
  }

  export type user_quota_historyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotaUsed?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutQuotaHistoryNestedInput
    season?: seasonsUpdateOneRequiredWithoutQuotaHistoryNestedInput
  }

  export type user_quota_historyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    quotaUsed?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_quota_historyCreateManyInput = {
    id?: string
    userId: string
    seasonId: string
    quotaUsed: number
    timestamp?: Date | string
  }

  export type user_quota_historyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotaUsed?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_quota_historyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    quotaUsed?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type websocket_connectionsCreateInput = {
    id: string
    connectionId: string
    connectedAt?: Date | string
    lastPing?: Date | string
    isActive?: boolean
    game?: gamesCreateNestedOneWithoutWebsocketConnectionsInput
    user: usersCreateNestedOneWithoutWebsocketConnectionsInput
  }

  export type websocket_connectionsUncheckedCreateInput = {
    id: string
    connectionId: string
    userId: string
    gameId?: string | null
    connectedAt?: Date | string
    lastPing?: Date | string
    isActive?: boolean
  }

  export type websocket_connectionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionId?: StringFieldUpdateOperationsInput | string
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPing?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    game?: gamesUpdateOneWithoutWebsocketConnectionsNestedInput
    user?: usersUpdateOneRequiredWithoutWebsocketConnectionsNestedInput
  }

  export type websocket_connectionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPing?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type websocket_connectionsCreateManyInput = {
    id: string
    connectionId: string
    userId: string
    gameId?: string | null
    connectedAt?: Date | string
    lastPing?: Date | string
    isActive?: boolean
  }

  export type websocket_connectionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionId?: StringFieldUpdateOperationsInput | string
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPing?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type websocket_connectionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPing?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumAnalysisTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisTypeFilter<$PrismaModel> | $Enums.AnalysisType
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type analysesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    boardState?: SortOrder
    dice?: SortOrder
    move?: SortOrder
    bestMove?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    explanation?: SortOrder
    alternatives?: SortOrder
    analysisType?: SortOrder
    createdAt?: SortOrder
  }

  export type analysesAvgOrderByAggregateInput = {
    dice?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
  }

  export type analysesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    boardState?: SortOrder
    move?: SortOrder
    bestMove?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    explanation?: SortOrder
    analysisType?: SortOrder
    createdAt?: SortOrder
  }

  export type analysesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    boardState?: SortOrder
    move?: SortOrder
    bestMove?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    explanation?: SortOrder
    analysisType?: SortOrder
    createdAt?: SortOrder
  }

  export type analysesSumOrderByAggregateInput = {
    dice?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumAnalysisTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisTypeWithAggregatesFilter<$PrismaModel> | $Enums.AnalysisType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnalysisTypeFilter<$PrismaModel>
    _max?: NestedEnumAnalysisTypeFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AnalysisQuotaUserId_dateCompoundUniqueInput = {
    userId: string
    date: Date | string
  }

  export type AnalysisQuotaCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    count?: SortOrder
    extraQuota?: SortOrder
    initialFree?: SortOrder
  }

  export type AnalysisQuotaAvgOrderByAggregateInput = {
    count?: SortOrder
    extraQuota?: SortOrder
  }

  export type AnalysisQuotaMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    count?: SortOrder
    extraQuota?: SortOrder
    initialFree?: SortOrder
  }

  export type AnalysisQuotaMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    count?: SortOrder
    extraQuota?: SortOrder
    initialFree?: SortOrder
  }

  export type AnalysisQuotaSumOrderByAggregateInput = {
    count?: SortOrder
    extraQuota?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IAQuotaCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dailyQuota?: SortOrder
    premiumQuota?: SortOrder
    extrasUsed?: SortOrder
    resetAt?: SortOrder
  }

  export type IAQuotaAvgOrderByAggregateInput = {
    dailyQuota?: SortOrder
    premiumQuota?: SortOrder
    extrasUsed?: SortOrder
  }

  export type IAQuotaMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dailyQuota?: SortOrder
    premiumQuota?: SortOrder
    extrasUsed?: SortOrder
    resetAt?: SortOrder
  }

  export type IAQuotaMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dailyQuota?: SortOrder
    premiumQuota?: SortOrder
    extrasUsed?: SortOrder
    resetAt?: SortOrder
  }

  export type IAQuotaSumOrderByAggregateInput = {
    dailyQuota?: SortOrder
    premiumQuota?: SortOrder
    extrasUsed?: SortOrder
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    jti?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    jti?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    jti?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type GamesRelationFilter = {
    is?: gamesWhereInput
    isNot?: gamesWhereInput
  }

  export type UsersNullableRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type chat_messagesCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    messageType?: SortOrder
    createdAt?: SortOrder
  }

  export type chat_messagesMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    messageType?: SortOrder
    createdAt?: SortOrder
  }

  export type chat_messagesMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    messageType?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type EnumPlayerFilter<$PrismaModel = never> = {
    equals?: $Enums.Player | EnumPlayerFieldRefInput<$PrismaModel>
    in?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel>
    notIn?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerFilter<$PrismaModel> | $Enums.Player
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type game_movesCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    player?: SortOrder
    dice?: SortOrder
    move?: SortOrder
    fromPoint?: SortOrder
    toPoint?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    thinkingTime?: SortOrder
    createdAt?: SortOrder
  }

  export type game_movesAvgOrderByAggregateInput = {
    dice?: SortOrder
    fromPoint?: SortOrder
    toPoint?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    thinkingTime?: SortOrder
  }

  export type game_movesMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    player?: SortOrder
    move?: SortOrder
    fromPoint?: SortOrder
    toPoint?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    thinkingTime?: SortOrder
    createdAt?: SortOrder
  }

  export type game_movesMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    player?: SortOrder
    move?: SortOrder
    fromPoint?: SortOrder
    toPoint?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    thinkingTime?: SortOrder
    createdAt?: SortOrder
  }

  export type game_movesSumOrderByAggregateInput = {
    dice?: SortOrder
    fromPoint?: SortOrder
    toPoint?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    thinkingTime?: SortOrder
  }

  export type EnumPlayerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Player | EnumPlayerFieldRefInput<$PrismaModel>
    in?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel>
    notIn?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerWithAggregatesFilter<$PrismaModel> | $Enums.Player
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlayerFilter<$PrismaModel>
    _max?: NestedEnumPlayerFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type subscriptionsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    stripe_subscription_id?: SortOrder
    stripe_customer_id?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    current_period_start?: SortOrder
    current_period_end?: SortOrder
    cancel_at_period_end?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subscriptionsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    stripe_subscription_id?: SortOrder
    stripe_customer_id?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    current_period_start?: SortOrder
    current_period_end?: SortOrder
    cancel_at_period_end?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subscriptionsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    stripe_subscription_id?: SortOrder
    stripe_customer_id?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    current_period_start?: SortOrder
    current_period_end?: SortOrder
    cancel_at_period_end?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type TournamentsRelationFilter = {
    is?: tournamentsWhereInput
    isNot?: tournamentsWhereInput
  }

  export type Tournament_matchesListRelationFilter = {
    every?: tournament_matchesWhereInput
    some?: tournament_matchesWhereInput
    none?: tournament_matchesWhereInput
  }

  export type tournament_matchesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tournament_participantsTournament_idUser_idCompoundUniqueInput = {
    tournament_id: string
    user_id: string
  }

  export type tournament_participantsCountOrderByAggregateInput = {
    id?: SortOrder
    tournament_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrder
    current_position?: SortOrder
    eliminated_at?: SortOrder
  }

  export type tournament_participantsAvgOrderByAggregateInput = {
    current_position?: SortOrder
  }

  export type tournament_participantsMaxOrderByAggregateInput = {
    id?: SortOrder
    tournament_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrder
    current_position?: SortOrder
    eliminated_at?: SortOrder
  }

  export type tournament_participantsMinOrderByAggregateInput = {
    id?: SortOrder
    tournament_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrder
    current_position?: SortOrder
    eliminated_at?: SortOrder
  }

  export type tournament_participantsSumOrderByAggregateInput = {
    current_position?: SortOrder
  }

  export type EnumTournamentMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentMatchStatus | EnumTournamentMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentMatchStatus[] | ListEnumTournamentMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentMatchStatus[] | ListEnumTournamentMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentMatchStatusFilter<$PrismaModel> | $Enums.TournamentMatchStatus
  }

  export type Tournament_participantsNullableRelationFilter = {
    is?: tournament_participantsWhereInput | null
    isNot?: tournament_participantsWhereInput | null
  }

  export type GamesNullableRelationFilter = {
    is?: gamesWhereInput | null
    isNot?: gamesWhereInput | null
  }

  export type tournament_matchesCountOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    round?: SortOrder
    matchNumber?: SortOrder
    whiteParticipantId?: SortOrder
    blackParticipantId?: SortOrder
    winnerParticipantId?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    gameId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tournament_matchesAvgOrderByAggregateInput = {
    round?: SortOrder
    matchNumber?: SortOrder
  }

  export type tournament_matchesMaxOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    round?: SortOrder
    matchNumber?: SortOrder
    whiteParticipantId?: SortOrder
    blackParticipantId?: SortOrder
    winnerParticipantId?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    gameId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tournament_matchesMinOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    round?: SortOrder
    matchNumber?: SortOrder
    whiteParticipantId?: SortOrder
    blackParticipantId?: SortOrder
    winnerParticipantId?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    gameId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tournament_matchesSumOrderByAggregateInput = {
    round?: SortOrder
    matchNumber?: SortOrder
  }

  export type EnumTournamentMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentMatchStatus | EnumTournamentMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentMatchStatus[] | ListEnumTournamentMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentMatchStatus[] | ListEnumTournamentMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.TournamentMatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTournamentMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumTournamentMatchStatusFilter<$PrismaModel>
  }

  export type EnumTournamentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusFilter<$PrismaModel> | $Enums.TournamentStatus
  }

  export type GamesListRelationFilter = {
    every?: gamesWhereInput
    some?: gamesWhereInput
    none?: gamesWhereInput
  }

  export type Tournament_participantsListRelationFilter = {
    every?: tournament_participantsWhereInput
    some?: tournament_participantsWhereInput
    none?: tournament_participantsWhereInput
  }

  export type gamesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tournament_participantsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tournamentsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
    maxPlayers?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type tournamentsAvgOrderByAggregateInput = {
    entryFee?: SortOrder
    prizePool?: SortOrder
    maxPlayers?: SortOrder
  }

  export type tournamentsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
    maxPlayers?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type tournamentsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
    maxPlayers?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type tournamentsSumOrderByAggregateInput = {
    entryFee?: SortOrder
    prizePool?: SortOrder
    maxPlayers?: SortOrder
  }

  export type EnumTournamentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusWithAggregatesFilter<$PrismaModel> | $Enums.TournamentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTournamentStatusFilter<$PrismaModel>
    _max?: NestedEnumTournamentStatusFilter<$PrismaModel>
  }

  export type user_analyticsUser_idDateCompoundUniqueInput = {
    user_id: string
    date: Date | string
  }

  export type user_analyticsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    games_played?: SortOrder
    games_won?: SortOrder
    analyses_completed?: SortOrder
    time_played?: SortOrder
    avg_equity?: SortOrder
    elo_change?: SortOrder
    claude_requests_today?: SortOrder
    claude_requests_this_month?: SortOrder
    claude_quota_remaining?: SortOrder
    chatgpt_requests_today?: SortOrder
    chatgpt_requests_this_month?: SortOrder
    gurubot_requests_today?: SortOrder
    gurubot_requests_this_month?: SortOrder
    gurubot_quota_remaining?: SortOrder
    easybot_requests_today?: SortOrder
    createdAt?: SortOrder
  }

  export type user_analyticsAvgOrderByAggregateInput = {
    games_played?: SortOrder
    games_won?: SortOrder
    analyses_completed?: SortOrder
    time_played?: SortOrder
    avg_equity?: SortOrder
    elo_change?: SortOrder
    claude_requests_today?: SortOrder
    claude_requests_this_month?: SortOrder
    claude_quota_remaining?: SortOrder
    chatgpt_requests_today?: SortOrder
    chatgpt_requests_this_month?: SortOrder
    gurubot_requests_today?: SortOrder
    gurubot_requests_this_month?: SortOrder
    gurubot_quota_remaining?: SortOrder
    easybot_requests_today?: SortOrder
  }

  export type user_analyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    games_played?: SortOrder
    games_won?: SortOrder
    analyses_completed?: SortOrder
    time_played?: SortOrder
    avg_equity?: SortOrder
    elo_change?: SortOrder
    claude_requests_today?: SortOrder
    claude_requests_this_month?: SortOrder
    claude_quota_remaining?: SortOrder
    chatgpt_requests_today?: SortOrder
    chatgpt_requests_this_month?: SortOrder
    gurubot_requests_today?: SortOrder
    gurubot_requests_this_month?: SortOrder
    gurubot_quota_remaining?: SortOrder
    easybot_requests_today?: SortOrder
    createdAt?: SortOrder
  }

  export type user_analyticsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    games_played?: SortOrder
    games_won?: SortOrder
    analyses_completed?: SortOrder
    time_played?: SortOrder
    avg_equity?: SortOrder
    elo_change?: SortOrder
    claude_requests_today?: SortOrder
    claude_requests_this_month?: SortOrder
    claude_quota_remaining?: SortOrder
    chatgpt_requests_today?: SortOrder
    chatgpt_requests_this_month?: SortOrder
    gurubot_requests_today?: SortOrder
    gurubot_requests_this_month?: SortOrder
    gurubot_quota_remaining?: SortOrder
    easybot_requests_today?: SortOrder
    createdAt?: SortOrder
  }

  export type user_analyticsSumOrderByAggregateInput = {
    games_played?: SortOrder
    games_won?: SortOrder
    analyses_completed?: SortOrder
    time_played?: SortOrder
    avg_equity?: SortOrder
    elo_change?: SortOrder
    claude_requests_today?: SortOrder
    claude_requests_this_month?: SortOrder
    claude_quota_remaining?: SortOrder
    chatgpt_requests_today?: SortOrder
    chatgpt_requests_this_month?: SortOrder
    gurubot_requests_today?: SortOrder
    gurubot_requests_this_month?: SortOrder
    gurubot_quota_remaining?: SortOrder
    easybot_requests_today?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type game_analysesUser_idGame_idCompoundUniqueInput = {
    user_id: string
    game_id: string
  }

  export type game_analysesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    game_id?: SortOrder
    analysis_report?: SortOrder
    ai_services_used?: SortOrder
    created_at?: SortOrder
  }

  export type game_analysesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    game_id?: SortOrder
    created_at?: SortOrder
  }

  export type game_analysesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    game_id?: SortOrder
    created_at?: SortOrder
  }

  export type EnumGameModeFilter<$PrismaModel = never> = {
    equals?: $Enums.GameMode | EnumGameModeFieldRefInput<$PrismaModel>
    in?: $Enums.GameMode[] | ListEnumGameModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameMode[] | ListEnumGameModeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameModeFilter<$PrismaModel> | $Enums.GameMode
  }

  export type EnumGameStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusFilter<$PrismaModel> | $Enums.GameStatus
  }

  export type EnumPlayerNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Player | EnumPlayerFieldRefInput<$PrismaModel> | null
    in?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlayerNullableFilter<$PrismaModel> | $Enums.Player | null
  }

  export type EnumTimeControlPresetNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeControlPreset | EnumTimeControlPresetFieldRefInput<$PrismaModel> | null
    in?: $Enums.TimeControlPreset[] | ListEnumTimeControlPresetFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TimeControlPreset[] | ListEnumTimeControlPresetFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTimeControlPresetNullableFilter<$PrismaModel> | $Enums.TimeControlPreset | null
  }

  export type EnumResignationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ResignationType | EnumResignationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResignationType[] | ListEnumResignationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResignationType[] | ListEnumResignationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResignationTypeNullableFilter<$PrismaModel> | $Enums.ResignationType | null
  }

  export type Chat_messagesListRelationFilter = {
    every?: chat_messagesWhereInput
    some?: chat_messagesWhereInput
    none?: chat_messagesWhereInput
  }

  export type Game_movesListRelationFilter = {
    every?: game_movesWhereInput
    some?: game_movesWhereInput
    none?: game_movesWhereInput
  }

  export type TournamentsNullableRelationFilter = {
    is?: tournamentsWhereInput | null
    isNot?: tournamentsWhereInput | null
  }

  export type Websocket_connectionsListRelationFilter = {
    every?: websocket_connectionsWhereInput
    some?: websocket_connectionsWhereInput
    none?: websocket_connectionsWhereInput
  }

  export type MatchesNullableRelationFilter = {
    is?: matchesWhereInput | null
    isNot?: matchesWhereInput | null
  }

  export type Tournament_matchesNullableRelationFilter = {
    is?: tournament_matchesWhereInput | null
    isNot?: tournament_matchesWhereInput | null
  }

  export type GameSessionListRelationFilter = {
    every?: GameSessionWhereInput
    some?: GameSessionWhereInput
    none?: GameSessionWhereInput
  }

  export type GameEventListRelationFilter = {
    every?: GameEventWhereInput
    some?: GameEventWhereInput
    none?: GameEventWhereInput
  }

  export type chat_messagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type game_movesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type websocket_connectionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type gamesCountOrderByAggregateInput = {
    id?: SortOrder
    whitePlayerId?: SortOrder
    blackPlayerId?: SortOrder
    tournamentId?: SortOrder
    gameMode?: SortOrder
    status?: SortOrder
    stake?: SortOrder
    winner?: SortOrder
    drawOfferedBy?: SortOrder
    whiteScore?: SortOrder
    blackScore?: SortOrder
    boardState?: SortOrder
    currentPlayer?: SortOrder
    dice?: SortOrder
    cubeLevel?: SortOrder
    cubeOwner?: SortOrder
    matchLength?: SortOrder
    doubleOfferedBy?: SortOrder
    doublePending?: SortOrder
    cubeHistory?: SortOrder
    timeControlPreset?: SortOrder
    timeControlTotalMs?: SortOrder
    timeControlIncrementMs?: SortOrder
    timeControlDelayMs?: SortOrder
    whiteTimeRemainingMs?: SortOrder
    blackTimeRemainingMs?: SortOrder
    activeTimer?: SortOrder
    timerUpdatedAt?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrder
    updatedAt?: SortOrder
    resignationType?: SortOrder
  }

  export type gamesAvgOrderByAggregateInput = {
    stake?: SortOrder
    whiteScore?: SortOrder
    blackScore?: SortOrder
    dice?: SortOrder
    cubeLevel?: SortOrder
    matchLength?: SortOrder
    timeControlTotalMs?: SortOrder
    timeControlIncrementMs?: SortOrder
    timeControlDelayMs?: SortOrder
    whiteTimeRemainingMs?: SortOrder
    blackTimeRemainingMs?: SortOrder
  }

  export type gamesMaxOrderByAggregateInput = {
    id?: SortOrder
    whitePlayerId?: SortOrder
    blackPlayerId?: SortOrder
    tournamentId?: SortOrder
    gameMode?: SortOrder
    status?: SortOrder
    stake?: SortOrder
    winner?: SortOrder
    drawOfferedBy?: SortOrder
    whiteScore?: SortOrder
    blackScore?: SortOrder
    currentPlayer?: SortOrder
    cubeLevel?: SortOrder
    cubeOwner?: SortOrder
    matchLength?: SortOrder
    doubleOfferedBy?: SortOrder
    doublePending?: SortOrder
    timeControlPreset?: SortOrder
    timeControlTotalMs?: SortOrder
    timeControlIncrementMs?: SortOrder
    timeControlDelayMs?: SortOrder
    whiteTimeRemainingMs?: SortOrder
    blackTimeRemainingMs?: SortOrder
    activeTimer?: SortOrder
    timerUpdatedAt?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrder
    updatedAt?: SortOrder
    resignationType?: SortOrder
  }

  export type gamesMinOrderByAggregateInput = {
    id?: SortOrder
    whitePlayerId?: SortOrder
    blackPlayerId?: SortOrder
    tournamentId?: SortOrder
    gameMode?: SortOrder
    status?: SortOrder
    stake?: SortOrder
    winner?: SortOrder
    drawOfferedBy?: SortOrder
    whiteScore?: SortOrder
    blackScore?: SortOrder
    currentPlayer?: SortOrder
    cubeLevel?: SortOrder
    cubeOwner?: SortOrder
    matchLength?: SortOrder
    doubleOfferedBy?: SortOrder
    doublePending?: SortOrder
    timeControlPreset?: SortOrder
    timeControlTotalMs?: SortOrder
    timeControlIncrementMs?: SortOrder
    timeControlDelayMs?: SortOrder
    whiteTimeRemainingMs?: SortOrder
    blackTimeRemainingMs?: SortOrder
    activeTimer?: SortOrder
    timerUpdatedAt?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrder
    updatedAt?: SortOrder
    resignationType?: SortOrder
  }

  export type gamesSumOrderByAggregateInput = {
    stake?: SortOrder
    whiteScore?: SortOrder
    blackScore?: SortOrder
    dice?: SortOrder
    cubeLevel?: SortOrder
    matchLength?: SortOrder
    timeControlTotalMs?: SortOrder
    timeControlIncrementMs?: SortOrder
    timeControlDelayMs?: SortOrder
    whiteTimeRemainingMs?: SortOrder
    blackTimeRemainingMs?: SortOrder
  }

  export type EnumGameModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameMode | EnumGameModeFieldRefInput<$PrismaModel>
    in?: $Enums.GameMode[] | ListEnumGameModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameMode[] | ListEnumGameModeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameModeWithAggregatesFilter<$PrismaModel> | $Enums.GameMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameModeFilter<$PrismaModel>
    _max?: NestedEnumGameModeFilter<$PrismaModel>
  }

  export type EnumGameStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusWithAggregatesFilter<$PrismaModel> | $Enums.GameStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameStatusFilter<$PrismaModel>
    _max?: NestedEnumGameStatusFilter<$PrismaModel>
  }

  export type EnumPlayerNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Player | EnumPlayerFieldRefInput<$PrismaModel> | null
    in?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlayerNullableWithAggregatesFilter<$PrismaModel> | $Enums.Player | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlayerNullableFilter<$PrismaModel>
    _max?: NestedEnumPlayerNullableFilter<$PrismaModel>
  }

  export type EnumTimeControlPresetNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeControlPreset | EnumTimeControlPresetFieldRefInput<$PrismaModel> | null
    in?: $Enums.TimeControlPreset[] | ListEnumTimeControlPresetFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TimeControlPreset[] | ListEnumTimeControlPresetFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTimeControlPresetNullableWithAggregatesFilter<$PrismaModel> | $Enums.TimeControlPreset | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTimeControlPresetNullableFilter<$PrismaModel>
    _max?: NestedEnumTimeControlPresetNullableFilter<$PrismaModel>
  }

  export type EnumResignationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResignationType | EnumResignationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResignationType[] | ListEnumResignationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResignationType[] | ListEnumResignationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResignationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ResignationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumResignationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumResignationTypeNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type GameSessionGameIdUserIdCompoundUniqueInput = {
    gameId: string
    userId: string
  }

  export type GameSessionCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    resumeTokenHash?: SortOrder
    lastAckSequence?: SortOrder
    lastHeartbeatAt?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type GameSessionAvgOrderByAggregateInput = {
    lastAckSequence?: SortOrder
  }

  export type GameSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    resumeTokenHash?: SortOrder
    lastAckSequence?: SortOrder
    lastHeartbeatAt?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type GameSessionMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    resumeTokenHash?: SortOrder
    lastAckSequence?: SortOrder
    lastHeartbeatAt?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type GameSessionSumOrderByAggregateInput = {
    lastAckSequence?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type GameEventGameIdSequenceCompoundUniqueInput = {
    gameId: string
    sequence: number
  }

  export type GameEventCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    sequence?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    createdAt?: SortOrder
  }

  export type GameEventAvgOrderByAggregateInput = {
    sequence?: SortOrder
  }

  export type GameEventMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    sequence?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type GameEventMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    sequence?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type GameEventSumOrderByAggregateInput = {
    sequence?: SortOrder
  }

  export type EnumMatchStateFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchState | EnumMatchStateFieldRefInput<$PrismaModel>
    in?: $Enums.MatchState[] | ListEnumMatchStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchState[] | ListEnumMatchStateFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStateFilter<$PrismaModel> | $Enums.MatchState
  }

  export type matchesCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    length?: SortOrder
    rules?: SortOrder
    state?: SortOrder
    crawfordUsed?: SortOrder
    cubeHistory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type matchesAvgOrderByAggregateInput = {
    length?: SortOrder
  }

  export type matchesMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    length?: SortOrder
    state?: SortOrder
    crawfordUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type matchesMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    length?: SortOrder
    state?: SortOrder
    crawfordUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type matchesSumOrderByAggregateInput = {
    length?: SortOrder
  }

  export type EnumMatchStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchState | EnumMatchStateFieldRefInput<$PrismaModel>
    in?: $Enums.MatchState[] | ListEnumMatchStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchState[] | ListEnumMatchStateFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStateWithAggregatesFilter<$PrismaModel> | $Enums.MatchState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStateFilter<$PrismaModel>
    _max?: NestedEnumMatchStateFilter<$PrismaModel>
  }

  export type user_learning_progressUser_idRule_keyCompoundUniqueInput = {
    user_id: string
    rule_key: string
  }

  export type user_learning_progressCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    rule_key?: SortOrder
    viewed_at?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrder
    score?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_learning_progressAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type user_learning_progressMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    rule_key?: SortOrder
    viewed_at?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrder
    score?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_learning_progressMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    rule_key?: SortOrder
    viewed_at?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrder
    score?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_learning_progressSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type user_achievementsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    achievement?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    unlocked_at?: SortOrder
    category?: SortOrder
  }

  export type user_achievementsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    achievement?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    unlocked_at?: SortOrder
    category?: SortOrder
  }

  export type user_achievementsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    achievement?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    unlocked_at?: SortOrder
    category?: SortOrder
  }

  export type user_preferencesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    language?: SortOrder
    theme?: SortOrder
    sound?: SortOrder
    notifications?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_preferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    language?: SortOrder
    theme?: SortOrder
    sound?: SortOrder
    notifications?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_preferencesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    language?: SortOrder
    theme?: SortOrder
    sound?: SortOrder
    notifications?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumSubscriptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeFilter<$PrismaModel> | $Enums.SubscriptionType
  }

  export type AnalysesListRelationFilter = {
    every?: analysesWhereInput
    some?: analysesWhereInput
    none?: analysesWhereInput
  }

  export type AnalysisQuotaListRelationFilter = {
    every?: AnalysisQuotaWhereInput
    some?: AnalysisQuotaWhereInput
    none?: AnalysisQuotaWhereInput
  }

  export type IAQuotaNullableRelationFilter = {
    is?: IAQuotaWhereInput | null
    isNot?: IAQuotaWhereInput | null
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type User_analyticsListRelationFilter = {
    every?: user_analyticsWhereInput
    some?: user_analyticsWhereInput
    none?: user_analyticsWhereInput
  }

  export type Game_analysesListRelationFilter = {
    every?: game_analysesWhereInput
    some?: game_analysesWhereInput
    none?: game_analysesWhereInput
  }

  export type SubscriptionsNullableRelationFilter = {
    is?: subscriptionsWhereInput | null
    isNot?: subscriptionsWhereInput | null
  }

  export type TournamentsListRelationFilter = {
    every?: tournamentsWhereInput
    some?: tournamentsWhereInput
    none?: tournamentsWhereInput
  }

  export type User_season_statsListRelationFilter = {
    every?: user_season_statsWhereInput
    some?: user_season_statsWhereInput
    none?: user_season_statsWhereInput
  }

  export type Season_leaderboardListRelationFilter = {
    every?: season_leaderboardWhereInput
    some?: season_leaderboardWhereInput
    none?: season_leaderboardWhereInput
  }

  export type User_quota_historyListRelationFilter = {
    every?: user_quota_historyWhereInput
    some?: user_quota_historyWhereInput
    none?: user_quota_historyWhereInput
  }

  export type analysesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalysisQuotaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_analyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type game_analysesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tournamentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_season_statsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type season_leaderboardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_quota_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    country?: SortOrder
    eloRating?: SortOrder
    gamesPlayed?: SortOrder
    gamesWon?: SortOrder
    winRate?: SortOrder
    currentStreak?: SortOrder
    bestStreak?: SortOrder
    subscriptionType?: SortOrder
    subscriptionExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    eloRating?: SortOrder
    gamesPlayed?: SortOrder
    gamesWon?: SortOrder
    winRate?: SortOrder
    currentStreak?: SortOrder
    bestStreak?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    country?: SortOrder
    eloRating?: SortOrder
    gamesPlayed?: SortOrder
    gamesWon?: SortOrder
    winRate?: SortOrder
    currentStreak?: SortOrder
    bestStreak?: SortOrder
    subscriptionType?: SortOrder
    subscriptionExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    country?: SortOrder
    eloRating?: SortOrder
    gamesPlayed?: SortOrder
    gamesWon?: SortOrder
    winRate?: SortOrder
    currentStreak?: SortOrder
    bestStreak?: SortOrder
    subscriptionType?: SortOrder
    subscriptionExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    eloRating?: SortOrder
    gamesPlayed?: SortOrder
    gamesWon?: SortOrder
    winRate?: SortOrder
    currentStreak?: SortOrder
    bestStreak?: SortOrder
  }

  export type EnumSubscriptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
  }

  export type seasonsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type seasonsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type seasonsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeasonsRelationFilter = {
    is?: seasonsWhereInput
    isNot?: seasonsWhereInput
  }

  export type user_season_statsUserIdSeasonIdCompoundUniqueInput = {
    userId: string
    seasonId: string
  }

  export type user_season_statsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    seasonId?: SortOrder
    elo?: SortOrder
    winrate?: SortOrder
    gamesPlayed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_season_statsAvgOrderByAggregateInput = {
    elo?: SortOrder
    winrate?: SortOrder
    gamesPlayed?: SortOrder
  }

  export type user_season_statsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    seasonId?: SortOrder
    elo?: SortOrder
    winrate?: SortOrder
    gamesPlayed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_season_statsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    seasonId?: SortOrder
    elo?: SortOrder
    winrate?: SortOrder
    gamesPlayed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_season_statsSumOrderByAggregateInput = {
    elo?: SortOrder
    winrate?: SortOrder
    gamesPlayed?: SortOrder
  }

  export type season_leaderboardSeasonIdUserIdCompoundUniqueInput = {
    seasonId: string
    userId: string
  }

  export type season_leaderboardCountOrderByAggregateInput = {
    id?: SortOrder
    seasonId?: SortOrder
    userId?: SortOrder
    rankGlobal?: SortOrder
    rankCountry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type season_leaderboardAvgOrderByAggregateInput = {
    rankGlobal?: SortOrder
    rankCountry?: SortOrder
  }

  export type season_leaderboardMaxOrderByAggregateInput = {
    id?: SortOrder
    seasonId?: SortOrder
    userId?: SortOrder
    rankGlobal?: SortOrder
    rankCountry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type season_leaderboardMinOrderByAggregateInput = {
    id?: SortOrder
    seasonId?: SortOrder
    userId?: SortOrder
    rankGlobal?: SortOrder
    rankCountry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type season_leaderboardSumOrderByAggregateInput = {
    rankGlobal?: SortOrder
    rankCountry?: SortOrder
  }

  export type user_quota_historyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    seasonId?: SortOrder
    quotaUsed?: SortOrder
    timestamp?: SortOrder
  }

  export type user_quota_historyAvgOrderByAggregateInput = {
    quotaUsed?: SortOrder
  }

  export type user_quota_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    seasonId?: SortOrder
    quotaUsed?: SortOrder
    timestamp?: SortOrder
  }

  export type user_quota_historyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    seasonId?: SortOrder
    quotaUsed?: SortOrder
    timestamp?: SortOrder
  }

  export type user_quota_historySumOrderByAggregateInput = {
    quotaUsed?: SortOrder
  }

  export type websocket_connectionsCountOrderByAggregateInput = {
    id?: SortOrder
    connectionId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    connectedAt?: SortOrder
    lastPing?: SortOrder
    isActive?: SortOrder
  }

  export type websocket_connectionsMaxOrderByAggregateInput = {
    id?: SortOrder
    connectionId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    connectedAt?: SortOrder
    lastPing?: SortOrder
    isActive?: SortOrder
  }

  export type websocket_connectionsMinOrderByAggregateInput = {
    id?: SortOrder
    connectionId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    connectedAt?: SortOrder
    lastPing?: SortOrder
    isActive?: SortOrder
  }

  export type analysesCreatediceInput = {
    set: number[]
  }

  export type usersCreateNestedOneWithoutAnalysesInput = {
    create?: XOR<usersCreateWithoutAnalysesInput, usersUncheckedCreateWithoutAnalysesInput>
    connectOrCreate?: usersCreateOrConnectWithoutAnalysesInput
    connect?: usersWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type analysesUpdatediceInput = {
    set?: number[]
    push?: number | number[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumAnalysisTypeFieldUpdateOperationsInput = {
    set?: $Enums.AnalysisType
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type usersUpdateOneRequiredWithoutAnalysesNestedInput = {
    create?: XOR<usersCreateWithoutAnalysesInput, usersUncheckedCreateWithoutAnalysesInput>
    connectOrCreate?: usersCreateOrConnectWithoutAnalysesInput
    upsert?: usersUpsertWithoutAnalysesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAnalysesInput, usersUpdateWithoutAnalysesInput>, usersUncheckedUpdateWithoutAnalysesInput>
  }

  export type usersCreateNestedOneWithoutAnalysisQuotasInput = {
    create?: XOR<usersCreateWithoutAnalysisQuotasInput, usersUncheckedCreateWithoutAnalysisQuotasInput>
    connectOrCreate?: usersCreateOrConnectWithoutAnalysisQuotasInput
    connect?: usersWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type usersUpdateOneRequiredWithoutAnalysisQuotasNestedInput = {
    create?: XOR<usersCreateWithoutAnalysisQuotasInput, usersUncheckedCreateWithoutAnalysisQuotasInput>
    connectOrCreate?: usersCreateOrConnectWithoutAnalysisQuotasInput
    upsert?: usersUpsertWithoutAnalysisQuotasInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAnalysisQuotasInput, usersUpdateWithoutAnalysisQuotasInput>, usersUncheckedUpdateWithoutAnalysisQuotasInput>
  }

  export type usersCreateNestedOneWithoutIaQuotaInput = {
    create?: XOR<usersCreateWithoutIaQuotaInput, usersUncheckedCreateWithoutIaQuotaInput>
    connectOrCreate?: usersCreateOrConnectWithoutIaQuotaInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutIaQuotaNestedInput = {
    create?: XOR<usersCreateWithoutIaQuotaInput, usersUncheckedCreateWithoutIaQuotaInput>
    connectOrCreate?: usersCreateOrConnectWithoutIaQuotaInput
    upsert?: usersUpsertWithoutIaQuotaInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutIaQuotaInput, usersUpdateWithoutIaQuotaInput>, usersUncheckedUpdateWithoutIaQuotaInput>
  }

  export type usersCreateNestedOneWithoutSessionsInput = {
    create?: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSessionsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSessionsInput
    upsert?: usersUpsertWithoutSessionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSessionsInput, usersUpdateWithoutSessionsInput>, usersUncheckedUpdateWithoutSessionsInput>
  }

  export type gamesCreateNestedOneWithoutChatMessagesInput = {
    create?: XOR<gamesCreateWithoutChatMessagesInput, gamesUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: gamesCreateOrConnectWithoutChatMessagesInput
    connect?: gamesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutChatMessagesInput = {
    create?: XOR<usersCreateWithoutChatMessagesInput, usersUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: usersCreateOrConnectWithoutChatMessagesInput
    connect?: usersWhereUniqueInput
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type gamesUpdateOneRequiredWithoutChatMessagesNestedInput = {
    create?: XOR<gamesCreateWithoutChatMessagesInput, gamesUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: gamesCreateOrConnectWithoutChatMessagesInput
    upsert?: gamesUpsertWithoutChatMessagesInput
    connect?: gamesWhereUniqueInput
    update?: XOR<XOR<gamesUpdateToOneWithWhereWithoutChatMessagesInput, gamesUpdateWithoutChatMessagesInput>, gamesUncheckedUpdateWithoutChatMessagesInput>
  }

  export type usersUpdateOneWithoutChatMessagesNestedInput = {
    create?: XOR<usersCreateWithoutChatMessagesInput, usersUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: usersCreateOrConnectWithoutChatMessagesInput
    upsert?: usersUpsertWithoutChatMessagesInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutChatMessagesInput, usersUpdateWithoutChatMessagesInput>, usersUncheckedUpdateWithoutChatMessagesInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type game_movesCreatediceInput = {
    set: number[]
  }

  export type gamesCreateNestedOneWithoutGameMovesInput = {
    create?: XOR<gamesCreateWithoutGameMovesInput, gamesUncheckedCreateWithoutGameMovesInput>
    connectOrCreate?: gamesCreateOrConnectWithoutGameMovesInput
    connect?: gamesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutGameMovesInput = {
    create?: XOR<usersCreateWithoutGameMovesInput, usersUncheckedCreateWithoutGameMovesInput>
    connectOrCreate?: usersCreateOrConnectWithoutGameMovesInput
    connect?: usersWhereUniqueInput
  }

  export type EnumPlayerFieldUpdateOperationsInput = {
    set?: $Enums.Player
  }

  export type game_movesUpdatediceInput = {
    set?: number[]
    push?: number | number[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type gamesUpdateOneRequiredWithoutGameMovesNestedInput = {
    create?: XOR<gamesCreateWithoutGameMovesInput, gamesUncheckedCreateWithoutGameMovesInput>
    connectOrCreate?: gamesCreateOrConnectWithoutGameMovesInput
    upsert?: gamesUpsertWithoutGameMovesInput
    connect?: gamesWhereUniqueInput
    update?: XOR<XOR<gamesUpdateToOneWithWhereWithoutGameMovesInput, gamesUpdateWithoutGameMovesInput>, gamesUncheckedUpdateWithoutGameMovesInput>
  }

  export type usersUpdateOneWithoutGameMovesNestedInput = {
    create?: XOR<usersCreateWithoutGameMovesInput, usersUncheckedCreateWithoutGameMovesInput>
    connectOrCreate?: usersCreateOrConnectWithoutGameMovesInput
    upsert?: usersUpsertWithoutGameMovesInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutGameMovesInput, usersUpdateWithoutGameMovesInput>, usersUncheckedUpdateWithoutGameMovesInput>
  }

  export type usersCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<usersCreateWithoutSubscriptionInput, usersUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: usersCreateOrConnectWithoutSubscriptionInput
    connect?: usersWhereUniqueInput
  }

  export type EnumSubscriptionPlanFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionPlan
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type usersUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<usersCreateWithoutSubscriptionInput, usersUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: usersCreateOrConnectWithoutSubscriptionInput
    upsert?: usersUpsertWithoutSubscriptionInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSubscriptionInput, usersUpdateWithoutSubscriptionInput>, usersUncheckedUpdateWithoutSubscriptionInput>
  }

  export type tournamentsCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<tournamentsCreateWithoutParticipantsInput, tournamentsUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: tournamentsCreateOrConnectWithoutParticipantsInput
    connect?: tournamentsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutTournamentParticipantsInput = {
    create?: XOR<usersCreateWithoutTournamentParticipantsInput, usersUncheckedCreateWithoutTournamentParticipantsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTournamentParticipantsInput
    connect?: usersWhereUniqueInput
  }

  export type tournament_matchesCreateNestedManyWithoutWhiteInput = {
    create?: XOR<tournament_matchesCreateWithoutWhiteInput, tournament_matchesUncheckedCreateWithoutWhiteInput> | tournament_matchesCreateWithoutWhiteInput[] | tournament_matchesUncheckedCreateWithoutWhiteInput[]
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutWhiteInput | tournament_matchesCreateOrConnectWithoutWhiteInput[]
    createMany?: tournament_matchesCreateManyWhiteInputEnvelope
    connect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
  }

  export type tournament_matchesCreateNestedManyWithoutBlackInput = {
    create?: XOR<tournament_matchesCreateWithoutBlackInput, tournament_matchesUncheckedCreateWithoutBlackInput> | tournament_matchesCreateWithoutBlackInput[] | tournament_matchesUncheckedCreateWithoutBlackInput[]
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutBlackInput | tournament_matchesCreateOrConnectWithoutBlackInput[]
    createMany?: tournament_matchesCreateManyBlackInputEnvelope
    connect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
  }

  export type tournament_matchesCreateNestedManyWithoutWinnerInput = {
    create?: XOR<tournament_matchesCreateWithoutWinnerInput, tournament_matchesUncheckedCreateWithoutWinnerInput> | tournament_matchesCreateWithoutWinnerInput[] | tournament_matchesUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutWinnerInput | tournament_matchesCreateOrConnectWithoutWinnerInput[]
    createMany?: tournament_matchesCreateManyWinnerInputEnvelope
    connect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
  }

  export type tournament_matchesUncheckedCreateNestedManyWithoutWhiteInput = {
    create?: XOR<tournament_matchesCreateWithoutWhiteInput, tournament_matchesUncheckedCreateWithoutWhiteInput> | tournament_matchesCreateWithoutWhiteInput[] | tournament_matchesUncheckedCreateWithoutWhiteInput[]
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutWhiteInput | tournament_matchesCreateOrConnectWithoutWhiteInput[]
    createMany?: tournament_matchesCreateManyWhiteInputEnvelope
    connect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
  }

  export type tournament_matchesUncheckedCreateNestedManyWithoutBlackInput = {
    create?: XOR<tournament_matchesCreateWithoutBlackInput, tournament_matchesUncheckedCreateWithoutBlackInput> | tournament_matchesCreateWithoutBlackInput[] | tournament_matchesUncheckedCreateWithoutBlackInput[]
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutBlackInput | tournament_matchesCreateOrConnectWithoutBlackInput[]
    createMany?: tournament_matchesCreateManyBlackInputEnvelope
    connect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
  }

  export type tournament_matchesUncheckedCreateNestedManyWithoutWinnerInput = {
    create?: XOR<tournament_matchesCreateWithoutWinnerInput, tournament_matchesUncheckedCreateWithoutWinnerInput> | tournament_matchesCreateWithoutWinnerInput[] | tournament_matchesUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutWinnerInput | tournament_matchesCreateOrConnectWithoutWinnerInput[]
    createMany?: tournament_matchesCreateManyWinnerInputEnvelope
    connect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
  }

  export type tournamentsUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<tournamentsCreateWithoutParticipantsInput, tournamentsUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: tournamentsCreateOrConnectWithoutParticipantsInput
    upsert?: tournamentsUpsertWithoutParticipantsInput
    connect?: tournamentsWhereUniqueInput
    update?: XOR<XOR<tournamentsUpdateToOneWithWhereWithoutParticipantsInput, tournamentsUpdateWithoutParticipantsInput>, tournamentsUncheckedUpdateWithoutParticipantsInput>
  }

  export type usersUpdateOneRequiredWithoutTournamentParticipantsNestedInput = {
    create?: XOR<usersCreateWithoutTournamentParticipantsInput, usersUncheckedCreateWithoutTournamentParticipantsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTournamentParticipantsInput
    upsert?: usersUpsertWithoutTournamentParticipantsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTournamentParticipantsInput, usersUpdateWithoutTournamentParticipantsInput>, usersUncheckedUpdateWithoutTournamentParticipantsInput>
  }

  export type tournament_matchesUpdateManyWithoutWhiteNestedInput = {
    create?: XOR<tournament_matchesCreateWithoutWhiteInput, tournament_matchesUncheckedCreateWithoutWhiteInput> | tournament_matchesCreateWithoutWhiteInput[] | tournament_matchesUncheckedCreateWithoutWhiteInput[]
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutWhiteInput | tournament_matchesCreateOrConnectWithoutWhiteInput[]
    upsert?: tournament_matchesUpsertWithWhereUniqueWithoutWhiteInput | tournament_matchesUpsertWithWhereUniqueWithoutWhiteInput[]
    createMany?: tournament_matchesCreateManyWhiteInputEnvelope
    set?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    disconnect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    delete?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    connect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    update?: tournament_matchesUpdateWithWhereUniqueWithoutWhiteInput | tournament_matchesUpdateWithWhereUniqueWithoutWhiteInput[]
    updateMany?: tournament_matchesUpdateManyWithWhereWithoutWhiteInput | tournament_matchesUpdateManyWithWhereWithoutWhiteInput[]
    deleteMany?: tournament_matchesScalarWhereInput | tournament_matchesScalarWhereInput[]
  }

  export type tournament_matchesUpdateManyWithoutBlackNestedInput = {
    create?: XOR<tournament_matchesCreateWithoutBlackInput, tournament_matchesUncheckedCreateWithoutBlackInput> | tournament_matchesCreateWithoutBlackInput[] | tournament_matchesUncheckedCreateWithoutBlackInput[]
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutBlackInput | tournament_matchesCreateOrConnectWithoutBlackInput[]
    upsert?: tournament_matchesUpsertWithWhereUniqueWithoutBlackInput | tournament_matchesUpsertWithWhereUniqueWithoutBlackInput[]
    createMany?: tournament_matchesCreateManyBlackInputEnvelope
    set?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    disconnect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    delete?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    connect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    update?: tournament_matchesUpdateWithWhereUniqueWithoutBlackInput | tournament_matchesUpdateWithWhereUniqueWithoutBlackInput[]
    updateMany?: tournament_matchesUpdateManyWithWhereWithoutBlackInput | tournament_matchesUpdateManyWithWhereWithoutBlackInput[]
    deleteMany?: tournament_matchesScalarWhereInput | tournament_matchesScalarWhereInput[]
  }

  export type tournament_matchesUpdateManyWithoutWinnerNestedInput = {
    create?: XOR<tournament_matchesCreateWithoutWinnerInput, tournament_matchesUncheckedCreateWithoutWinnerInput> | tournament_matchesCreateWithoutWinnerInput[] | tournament_matchesUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutWinnerInput | tournament_matchesCreateOrConnectWithoutWinnerInput[]
    upsert?: tournament_matchesUpsertWithWhereUniqueWithoutWinnerInput | tournament_matchesUpsertWithWhereUniqueWithoutWinnerInput[]
    createMany?: tournament_matchesCreateManyWinnerInputEnvelope
    set?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    disconnect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    delete?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    connect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    update?: tournament_matchesUpdateWithWhereUniqueWithoutWinnerInput | tournament_matchesUpdateWithWhereUniqueWithoutWinnerInput[]
    updateMany?: tournament_matchesUpdateManyWithWhereWithoutWinnerInput | tournament_matchesUpdateManyWithWhereWithoutWinnerInput[]
    deleteMany?: tournament_matchesScalarWhereInput | tournament_matchesScalarWhereInput[]
  }

  export type tournament_matchesUncheckedUpdateManyWithoutWhiteNestedInput = {
    create?: XOR<tournament_matchesCreateWithoutWhiteInput, tournament_matchesUncheckedCreateWithoutWhiteInput> | tournament_matchesCreateWithoutWhiteInput[] | tournament_matchesUncheckedCreateWithoutWhiteInput[]
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutWhiteInput | tournament_matchesCreateOrConnectWithoutWhiteInput[]
    upsert?: tournament_matchesUpsertWithWhereUniqueWithoutWhiteInput | tournament_matchesUpsertWithWhereUniqueWithoutWhiteInput[]
    createMany?: tournament_matchesCreateManyWhiteInputEnvelope
    set?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    disconnect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    delete?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    connect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    update?: tournament_matchesUpdateWithWhereUniqueWithoutWhiteInput | tournament_matchesUpdateWithWhereUniqueWithoutWhiteInput[]
    updateMany?: tournament_matchesUpdateManyWithWhereWithoutWhiteInput | tournament_matchesUpdateManyWithWhereWithoutWhiteInput[]
    deleteMany?: tournament_matchesScalarWhereInput | tournament_matchesScalarWhereInput[]
  }

  export type tournament_matchesUncheckedUpdateManyWithoutBlackNestedInput = {
    create?: XOR<tournament_matchesCreateWithoutBlackInput, tournament_matchesUncheckedCreateWithoutBlackInput> | tournament_matchesCreateWithoutBlackInput[] | tournament_matchesUncheckedCreateWithoutBlackInput[]
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutBlackInput | tournament_matchesCreateOrConnectWithoutBlackInput[]
    upsert?: tournament_matchesUpsertWithWhereUniqueWithoutBlackInput | tournament_matchesUpsertWithWhereUniqueWithoutBlackInput[]
    createMany?: tournament_matchesCreateManyBlackInputEnvelope
    set?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    disconnect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    delete?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    connect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    update?: tournament_matchesUpdateWithWhereUniqueWithoutBlackInput | tournament_matchesUpdateWithWhereUniqueWithoutBlackInput[]
    updateMany?: tournament_matchesUpdateManyWithWhereWithoutBlackInput | tournament_matchesUpdateManyWithWhereWithoutBlackInput[]
    deleteMany?: tournament_matchesScalarWhereInput | tournament_matchesScalarWhereInput[]
  }

  export type tournament_matchesUncheckedUpdateManyWithoutWinnerNestedInput = {
    create?: XOR<tournament_matchesCreateWithoutWinnerInput, tournament_matchesUncheckedCreateWithoutWinnerInput> | tournament_matchesCreateWithoutWinnerInput[] | tournament_matchesUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutWinnerInput | tournament_matchesCreateOrConnectWithoutWinnerInput[]
    upsert?: tournament_matchesUpsertWithWhereUniqueWithoutWinnerInput | tournament_matchesUpsertWithWhereUniqueWithoutWinnerInput[]
    createMany?: tournament_matchesCreateManyWinnerInputEnvelope
    set?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    disconnect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    delete?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    connect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    update?: tournament_matchesUpdateWithWhereUniqueWithoutWinnerInput | tournament_matchesUpdateWithWhereUniqueWithoutWinnerInput[]
    updateMany?: tournament_matchesUpdateManyWithWhereWithoutWinnerInput | tournament_matchesUpdateManyWithWhereWithoutWinnerInput[]
    deleteMany?: tournament_matchesScalarWhereInput | tournament_matchesScalarWhereInput[]
  }

  export type tournamentsCreateNestedOneWithoutMatchesInput = {
    create?: XOR<tournamentsCreateWithoutMatchesInput, tournamentsUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: tournamentsCreateOrConnectWithoutMatchesInput
    connect?: tournamentsWhereUniqueInput
  }

  export type tournament_participantsCreateNestedOneWithoutWhiteMatchesInput = {
    create?: XOR<tournament_participantsCreateWithoutWhiteMatchesInput, tournament_participantsUncheckedCreateWithoutWhiteMatchesInput>
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutWhiteMatchesInput
    connect?: tournament_participantsWhereUniqueInput
  }

  export type tournament_participantsCreateNestedOneWithoutBlackMatchesInput = {
    create?: XOR<tournament_participantsCreateWithoutBlackMatchesInput, tournament_participantsUncheckedCreateWithoutBlackMatchesInput>
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutBlackMatchesInput
    connect?: tournament_participantsWhereUniqueInput
  }

  export type tournament_participantsCreateNestedOneWithoutWonMatchesInput = {
    create?: XOR<tournament_participantsCreateWithoutWonMatchesInput, tournament_participantsUncheckedCreateWithoutWonMatchesInput>
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutWonMatchesInput
    connect?: tournament_participantsWhereUniqueInput
  }

  export type gamesCreateNestedOneWithoutTournamentMatchInput = {
    create?: XOR<gamesCreateWithoutTournamentMatchInput, gamesUncheckedCreateWithoutTournamentMatchInput>
    connectOrCreate?: gamesCreateOrConnectWithoutTournamentMatchInput
    connect?: gamesWhereUniqueInput
  }

  export type EnumTournamentMatchStatusFieldUpdateOperationsInput = {
    set?: $Enums.TournamentMatchStatus
  }

  export type tournamentsUpdateOneRequiredWithoutMatchesNestedInput = {
    create?: XOR<tournamentsCreateWithoutMatchesInput, tournamentsUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: tournamentsCreateOrConnectWithoutMatchesInput
    upsert?: tournamentsUpsertWithoutMatchesInput
    connect?: tournamentsWhereUniqueInput
    update?: XOR<XOR<tournamentsUpdateToOneWithWhereWithoutMatchesInput, tournamentsUpdateWithoutMatchesInput>, tournamentsUncheckedUpdateWithoutMatchesInput>
  }

  export type tournament_participantsUpdateOneWithoutWhiteMatchesNestedInput = {
    create?: XOR<tournament_participantsCreateWithoutWhiteMatchesInput, tournament_participantsUncheckedCreateWithoutWhiteMatchesInput>
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutWhiteMatchesInput
    upsert?: tournament_participantsUpsertWithoutWhiteMatchesInput
    disconnect?: tournament_participantsWhereInput | boolean
    delete?: tournament_participantsWhereInput | boolean
    connect?: tournament_participantsWhereUniqueInput
    update?: XOR<XOR<tournament_participantsUpdateToOneWithWhereWithoutWhiteMatchesInput, tournament_participantsUpdateWithoutWhiteMatchesInput>, tournament_participantsUncheckedUpdateWithoutWhiteMatchesInput>
  }

  export type tournament_participantsUpdateOneWithoutBlackMatchesNestedInput = {
    create?: XOR<tournament_participantsCreateWithoutBlackMatchesInput, tournament_participantsUncheckedCreateWithoutBlackMatchesInput>
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutBlackMatchesInput
    upsert?: tournament_participantsUpsertWithoutBlackMatchesInput
    disconnect?: tournament_participantsWhereInput | boolean
    delete?: tournament_participantsWhereInput | boolean
    connect?: tournament_participantsWhereUniqueInput
    update?: XOR<XOR<tournament_participantsUpdateToOneWithWhereWithoutBlackMatchesInput, tournament_participantsUpdateWithoutBlackMatchesInput>, tournament_participantsUncheckedUpdateWithoutBlackMatchesInput>
  }

  export type tournament_participantsUpdateOneWithoutWonMatchesNestedInput = {
    create?: XOR<tournament_participantsCreateWithoutWonMatchesInput, tournament_participantsUncheckedCreateWithoutWonMatchesInput>
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutWonMatchesInput
    upsert?: tournament_participantsUpsertWithoutWonMatchesInput
    disconnect?: tournament_participantsWhereInput | boolean
    delete?: tournament_participantsWhereInput | boolean
    connect?: tournament_participantsWhereUniqueInput
    update?: XOR<XOR<tournament_participantsUpdateToOneWithWhereWithoutWonMatchesInput, tournament_participantsUpdateWithoutWonMatchesInput>, tournament_participantsUncheckedUpdateWithoutWonMatchesInput>
  }

  export type gamesUpdateOneWithoutTournamentMatchNestedInput = {
    create?: XOR<gamesCreateWithoutTournamentMatchInput, gamesUncheckedCreateWithoutTournamentMatchInput>
    connectOrCreate?: gamesCreateOrConnectWithoutTournamentMatchInput
    upsert?: gamesUpsertWithoutTournamentMatchInput
    disconnect?: gamesWhereInput | boolean
    delete?: gamesWhereInput | boolean
    connect?: gamesWhereUniqueInput
    update?: XOR<XOR<gamesUpdateToOneWithWhereWithoutTournamentMatchInput, gamesUpdateWithoutTournamentMatchInput>, gamesUncheckedUpdateWithoutTournamentMatchInput>
  }

  export type gamesCreateNestedManyWithoutTournamentInput = {
    create?: XOR<gamesCreateWithoutTournamentInput, gamesUncheckedCreateWithoutTournamentInput> | gamesCreateWithoutTournamentInput[] | gamesUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutTournamentInput | gamesCreateOrConnectWithoutTournamentInput[]
    createMany?: gamesCreateManyTournamentInputEnvelope
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
  }

  export type tournament_participantsCreateNestedManyWithoutTournamentsInput = {
    create?: XOR<tournament_participantsCreateWithoutTournamentsInput, tournament_participantsUncheckedCreateWithoutTournamentsInput> | tournament_participantsCreateWithoutTournamentsInput[] | tournament_participantsUncheckedCreateWithoutTournamentsInput[]
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutTournamentsInput | tournament_participantsCreateOrConnectWithoutTournamentsInput[]
    createMany?: tournament_participantsCreateManyTournamentsInputEnvelope
    connect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
  }

  export type tournament_matchesCreateNestedManyWithoutTournamentInput = {
    create?: XOR<tournament_matchesCreateWithoutTournamentInput, tournament_matchesUncheckedCreateWithoutTournamentInput> | tournament_matchesCreateWithoutTournamentInput[] | tournament_matchesUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutTournamentInput | tournament_matchesCreateOrConnectWithoutTournamentInput[]
    createMany?: tournament_matchesCreateManyTournamentInputEnvelope
    connect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutTournamentsInput = {
    create?: XOR<usersCreateWithoutTournamentsInput, usersUncheckedCreateWithoutTournamentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTournamentsInput
    connect?: usersWhereUniqueInput
  }

  export type gamesUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<gamesCreateWithoutTournamentInput, gamesUncheckedCreateWithoutTournamentInput> | gamesCreateWithoutTournamentInput[] | gamesUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutTournamentInput | gamesCreateOrConnectWithoutTournamentInput[]
    createMany?: gamesCreateManyTournamentInputEnvelope
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
  }

  export type tournament_participantsUncheckedCreateNestedManyWithoutTournamentsInput = {
    create?: XOR<tournament_participantsCreateWithoutTournamentsInput, tournament_participantsUncheckedCreateWithoutTournamentsInput> | tournament_participantsCreateWithoutTournamentsInput[] | tournament_participantsUncheckedCreateWithoutTournamentsInput[]
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutTournamentsInput | tournament_participantsCreateOrConnectWithoutTournamentsInput[]
    createMany?: tournament_participantsCreateManyTournamentsInputEnvelope
    connect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
  }

  export type tournament_matchesUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<tournament_matchesCreateWithoutTournamentInput, tournament_matchesUncheckedCreateWithoutTournamentInput> | tournament_matchesCreateWithoutTournamentInput[] | tournament_matchesUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutTournamentInput | tournament_matchesCreateOrConnectWithoutTournamentInput[]
    createMany?: tournament_matchesCreateManyTournamentInputEnvelope
    connect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
  }

  export type EnumTournamentStatusFieldUpdateOperationsInput = {
    set?: $Enums.TournamentStatus
  }

  export type gamesUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<gamesCreateWithoutTournamentInput, gamesUncheckedCreateWithoutTournamentInput> | gamesCreateWithoutTournamentInput[] | gamesUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutTournamentInput | gamesCreateOrConnectWithoutTournamentInput[]
    upsert?: gamesUpsertWithWhereUniqueWithoutTournamentInput | gamesUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: gamesCreateManyTournamentInputEnvelope
    set?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    disconnect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    delete?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    update?: gamesUpdateWithWhereUniqueWithoutTournamentInput | gamesUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: gamesUpdateManyWithWhereWithoutTournamentInput | gamesUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: gamesScalarWhereInput | gamesScalarWhereInput[]
  }

  export type tournament_participantsUpdateManyWithoutTournamentsNestedInput = {
    create?: XOR<tournament_participantsCreateWithoutTournamentsInput, tournament_participantsUncheckedCreateWithoutTournamentsInput> | tournament_participantsCreateWithoutTournamentsInput[] | tournament_participantsUncheckedCreateWithoutTournamentsInput[]
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutTournamentsInput | tournament_participantsCreateOrConnectWithoutTournamentsInput[]
    upsert?: tournament_participantsUpsertWithWhereUniqueWithoutTournamentsInput | tournament_participantsUpsertWithWhereUniqueWithoutTournamentsInput[]
    createMany?: tournament_participantsCreateManyTournamentsInputEnvelope
    set?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    disconnect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    delete?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    connect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    update?: tournament_participantsUpdateWithWhereUniqueWithoutTournamentsInput | tournament_participantsUpdateWithWhereUniqueWithoutTournamentsInput[]
    updateMany?: tournament_participantsUpdateManyWithWhereWithoutTournamentsInput | tournament_participantsUpdateManyWithWhereWithoutTournamentsInput[]
    deleteMany?: tournament_participantsScalarWhereInput | tournament_participantsScalarWhereInput[]
  }

  export type tournament_matchesUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<tournament_matchesCreateWithoutTournamentInput, tournament_matchesUncheckedCreateWithoutTournamentInput> | tournament_matchesCreateWithoutTournamentInput[] | tournament_matchesUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutTournamentInput | tournament_matchesCreateOrConnectWithoutTournamentInput[]
    upsert?: tournament_matchesUpsertWithWhereUniqueWithoutTournamentInput | tournament_matchesUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: tournament_matchesCreateManyTournamentInputEnvelope
    set?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    disconnect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    delete?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    connect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    update?: tournament_matchesUpdateWithWhereUniqueWithoutTournamentInput | tournament_matchesUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: tournament_matchesUpdateManyWithWhereWithoutTournamentInput | tournament_matchesUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: tournament_matchesScalarWhereInput | tournament_matchesScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutTournamentsNestedInput = {
    create?: XOR<usersCreateWithoutTournamentsInput, usersUncheckedCreateWithoutTournamentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTournamentsInput
    upsert?: usersUpsertWithoutTournamentsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTournamentsInput, usersUpdateWithoutTournamentsInput>, usersUncheckedUpdateWithoutTournamentsInput>
  }

  export type gamesUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<gamesCreateWithoutTournamentInput, gamesUncheckedCreateWithoutTournamentInput> | gamesCreateWithoutTournamentInput[] | gamesUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutTournamentInput | gamesCreateOrConnectWithoutTournamentInput[]
    upsert?: gamesUpsertWithWhereUniqueWithoutTournamentInput | gamesUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: gamesCreateManyTournamentInputEnvelope
    set?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    disconnect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    delete?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    update?: gamesUpdateWithWhereUniqueWithoutTournamentInput | gamesUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: gamesUpdateManyWithWhereWithoutTournamentInput | gamesUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: gamesScalarWhereInput | gamesScalarWhereInput[]
  }

  export type tournament_participantsUncheckedUpdateManyWithoutTournamentsNestedInput = {
    create?: XOR<tournament_participantsCreateWithoutTournamentsInput, tournament_participantsUncheckedCreateWithoutTournamentsInput> | tournament_participantsCreateWithoutTournamentsInput[] | tournament_participantsUncheckedCreateWithoutTournamentsInput[]
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutTournamentsInput | tournament_participantsCreateOrConnectWithoutTournamentsInput[]
    upsert?: tournament_participantsUpsertWithWhereUniqueWithoutTournamentsInput | tournament_participantsUpsertWithWhereUniqueWithoutTournamentsInput[]
    createMany?: tournament_participantsCreateManyTournamentsInputEnvelope
    set?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    disconnect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    delete?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    connect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    update?: tournament_participantsUpdateWithWhereUniqueWithoutTournamentsInput | tournament_participantsUpdateWithWhereUniqueWithoutTournamentsInput[]
    updateMany?: tournament_participantsUpdateManyWithWhereWithoutTournamentsInput | tournament_participantsUpdateManyWithWhereWithoutTournamentsInput[]
    deleteMany?: tournament_participantsScalarWhereInput | tournament_participantsScalarWhereInput[]
  }

  export type tournament_matchesUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<tournament_matchesCreateWithoutTournamentInput, tournament_matchesUncheckedCreateWithoutTournamentInput> | tournament_matchesCreateWithoutTournamentInput[] | tournament_matchesUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutTournamentInput | tournament_matchesCreateOrConnectWithoutTournamentInput[]
    upsert?: tournament_matchesUpsertWithWhereUniqueWithoutTournamentInput | tournament_matchesUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: tournament_matchesCreateManyTournamentInputEnvelope
    set?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    disconnect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    delete?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    connect?: tournament_matchesWhereUniqueInput | tournament_matchesWhereUniqueInput[]
    update?: tournament_matchesUpdateWithWhereUniqueWithoutTournamentInput | tournament_matchesUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: tournament_matchesUpdateManyWithWhereWithoutTournamentInput | tournament_matchesUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: tournament_matchesScalarWhereInput | tournament_matchesScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutUserAnalyticsInput = {
    create?: XOR<usersCreateWithoutUserAnalyticsInput, usersUncheckedCreateWithoutUserAnalyticsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUserAnalyticsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUserAnalyticsNestedInput = {
    create?: XOR<usersCreateWithoutUserAnalyticsInput, usersUncheckedCreateWithoutUserAnalyticsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUserAnalyticsInput
    upsert?: usersUpsertWithoutUserAnalyticsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUserAnalyticsInput, usersUpdateWithoutUserAnalyticsInput>, usersUncheckedUpdateWithoutUserAnalyticsInput>
  }

  export type game_analysesCreateai_services_usedInput = {
    set: string[]
  }

  export type usersCreateNestedOneWithoutGameAnalysesInput = {
    create?: XOR<usersCreateWithoutGameAnalysesInput, usersUncheckedCreateWithoutGameAnalysesInput>
    connectOrCreate?: usersCreateOrConnectWithoutGameAnalysesInput
    connect?: usersWhereUniqueInput
  }

  export type game_analysesUpdateai_services_usedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type usersUpdateOneRequiredWithoutGameAnalysesNestedInput = {
    create?: XOR<usersCreateWithoutGameAnalysesInput, usersUncheckedCreateWithoutGameAnalysesInput>
    connectOrCreate?: usersCreateOrConnectWithoutGameAnalysesInput
    upsert?: usersUpsertWithoutGameAnalysesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutGameAnalysesInput, usersUpdateWithoutGameAnalysesInput>, usersUncheckedUpdateWithoutGameAnalysesInput>
  }

  export type gamesCreatediceInput = {
    set: number[]
  }

  export type chat_messagesCreateNestedManyWithoutGameInput = {
    create?: XOR<chat_messagesCreateWithoutGameInput, chat_messagesUncheckedCreateWithoutGameInput> | chat_messagesCreateWithoutGameInput[] | chat_messagesUncheckedCreateWithoutGameInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutGameInput | chat_messagesCreateOrConnectWithoutGameInput[]
    createMany?: chat_messagesCreateManyGameInputEnvelope
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
  }

  export type game_movesCreateNestedManyWithoutGameInput = {
    create?: XOR<game_movesCreateWithoutGameInput, game_movesUncheckedCreateWithoutGameInput> | game_movesCreateWithoutGameInput[] | game_movesUncheckedCreateWithoutGameInput[]
    connectOrCreate?: game_movesCreateOrConnectWithoutGameInput | game_movesCreateOrConnectWithoutGameInput[]
    createMany?: game_movesCreateManyGameInputEnvelope
    connect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
  }

  export type tournamentsCreateNestedOneWithoutGamesInput = {
    create?: XOR<tournamentsCreateWithoutGamesInput, tournamentsUncheckedCreateWithoutGamesInput>
    connectOrCreate?: tournamentsCreateOrConnectWithoutGamesInput
    connect?: tournamentsWhereUniqueInput
  }

  export type websocket_connectionsCreateNestedManyWithoutGameInput = {
    create?: XOR<websocket_connectionsCreateWithoutGameInput, websocket_connectionsUncheckedCreateWithoutGameInput> | websocket_connectionsCreateWithoutGameInput[] | websocket_connectionsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: websocket_connectionsCreateOrConnectWithoutGameInput | websocket_connectionsCreateOrConnectWithoutGameInput[]
    createMany?: websocket_connectionsCreateManyGameInputEnvelope
    connect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutWhiteGamesInput = {
    create?: XOR<usersCreateWithoutWhiteGamesInput, usersUncheckedCreateWithoutWhiteGamesInput>
    connectOrCreate?: usersCreateOrConnectWithoutWhiteGamesInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutBlackGamesInput = {
    create?: XOR<usersCreateWithoutBlackGamesInput, usersUncheckedCreateWithoutBlackGamesInput>
    connectOrCreate?: usersCreateOrConnectWithoutBlackGamesInput
    connect?: usersWhereUniqueInput
  }

  export type matchesCreateNestedOneWithoutGameInput = {
    create?: XOR<matchesCreateWithoutGameInput, matchesUncheckedCreateWithoutGameInput>
    connectOrCreate?: matchesCreateOrConnectWithoutGameInput
    connect?: matchesWhereUniqueInput
  }

  export type tournament_matchesCreateNestedOneWithoutGameInput = {
    create?: XOR<tournament_matchesCreateWithoutGameInput, tournament_matchesUncheckedCreateWithoutGameInput>
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutGameInput
    connect?: tournament_matchesWhereUniqueInput
  }

  export type GameSessionCreateNestedManyWithoutGameInput = {
    create?: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput> | GameSessionCreateWithoutGameInput[] | GameSessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutGameInput | GameSessionCreateOrConnectWithoutGameInput[]
    createMany?: GameSessionCreateManyGameInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type GameEventCreateNestedManyWithoutGameInput = {
    create?: XOR<GameEventCreateWithoutGameInput, GameEventUncheckedCreateWithoutGameInput> | GameEventCreateWithoutGameInput[] | GameEventUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutGameInput | GameEventCreateOrConnectWithoutGameInput[]
    createMany?: GameEventCreateManyGameInputEnvelope
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
  }

  export type chat_messagesUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<chat_messagesCreateWithoutGameInput, chat_messagesUncheckedCreateWithoutGameInput> | chat_messagesCreateWithoutGameInput[] | chat_messagesUncheckedCreateWithoutGameInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutGameInput | chat_messagesCreateOrConnectWithoutGameInput[]
    createMany?: chat_messagesCreateManyGameInputEnvelope
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
  }

  export type game_movesUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<game_movesCreateWithoutGameInput, game_movesUncheckedCreateWithoutGameInput> | game_movesCreateWithoutGameInput[] | game_movesUncheckedCreateWithoutGameInput[]
    connectOrCreate?: game_movesCreateOrConnectWithoutGameInput | game_movesCreateOrConnectWithoutGameInput[]
    createMany?: game_movesCreateManyGameInputEnvelope
    connect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
  }

  export type websocket_connectionsUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<websocket_connectionsCreateWithoutGameInput, websocket_connectionsUncheckedCreateWithoutGameInput> | websocket_connectionsCreateWithoutGameInput[] | websocket_connectionsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: websocket_connectionsCreateOrConnectWithoutGameInput | websocket_connectionsCreateOrConnectWithoutGameInput[]
    createMany?: websocket_connectionsCreateManyGameInputEnvelope
    connect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
  }

  export type matchesUncheckedCreateNestedOneWithoutGameInput = {
    create?: XOR<matchesCreateWithoutGameInput, matchesUncheckedCreateWithoutGameInput>
    connectOrCreate?: matchesCreateOrConnectWithoutGameInput
    connect?: matchesWhereUniqueInput
  }

  export type tournament_matchesUncheckedCreateNestedOneWithoutGameInput = {
    create?: XOR<tournament_matchesCreateWithoutGameInput, tournament_matchesUncheckedCreateWithoutGameInput>
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutGameInput
    connect?: tournament_matchesWhereUniqueInput
  }

  export type GameSessionUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput> | GameSessionCreateWithoutGameInput[] | GameSessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutGameInput | GameSessionCreateOrConnectWithoutGameInput[]
    createMany?: GameSessionCreateManyGameInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type GameEventUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<GameEventCreateWithoutGameInput, GameEventUncheckedCreateWithoutGameInput> | GameEventCreateWithoutGameInput[] | GameEventUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutGameInput | GameEventCreateOrConnectWithoutGameInput[]
    createMany?: GameEventCreateManyGameInputEnvelope
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
  }

  export type EnumGameModeFieldUpdateOperationsInput = {
    set?: $Enums.GameMode
  }

  export type EnumGameStatusFieldUpdateOperationsInput = {
    set?: $Enums.GameStatus
  }

  export type NullableEnumPlayerFieldUpdateOperationsInput = {
    set?: $Enums.Player | null
  }

  export type gamesUpdatediceInput = {
    set?: number[]
    push?: number | number[]
  }

  export type NullableEnumTimeControlPresetFieldUpdateOperationsInput = {
    set?: $Enums.TimeControlPreset | null
  }

  export type NullableEnumResignationTypeFieldUpdateOperationsInput = {
    set?: $Enums.ResignationType | null
  }

  export type chat_messagesUpdateManyWithoutGameNestedInput = {
    create?: XOR<chat_messagesCreateWithoutGameInput, chat_messagesUncheckedCreateWithoutGameInput> | chat_messagesCreateWithoutGameInput[] | chat_messagesUncheckedCreateWithoutGameInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutGameInput | chat_messagesCreateOrConnectWithoutGameInput[]
    upsert?: chat_messagesUpsertWithWhereUniqueWithoutGameInput | chat_messagesUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: chat_messagesCreateManyGameInputEnvelope
    set?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    disconnect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    delete?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    update?: chat_messagesUpdateWithWhereUniqueWithoutGameInput | chat_messagesUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: chat_messagesUpdateManyWithWhereWithoutGameInput | chat_messagesUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
  }

  export type game_movesUpdateManyWithoutGameNestedInput = {
    create?: XOR<game_movesCreateWithoutGameInput, game_movesUncheckedCreateWithoutGameInput> | game_movesCreateWithoutGameInput[] | game_movesUncheckedCreateWithoutGameInput[]
    connectOrCreate?: game_movesCreateOrConnectWithoutGameInput | game_movesCreateOrConnectWithoutGameInput[]
    upsert?: game_movesUpsertWithWhereUniqueWithoutGameInput | game_movesUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: game_movesCreateManyGameInputEnvelope
    set?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    disconnect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    delete?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    connect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    update?: game_movesUpdateWithWhereUniqueWithoutGameInput | game_movesUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: game_movesUpdateManyWithWhereWithoutGameInput | game_movesUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: game_movesScalarWhereInput | game_movesScalarWhereInput[]
  }

  export type tournamentsUpdateOneWithoutGamesNestedInput = {
    create?: XOR<tournamentsCreateWithoutGamesInput, tournamentsUncheckedCreateWithoutGamesInput>
    connectOrCreate?: tournamentsCreateOrConnectWithoutGamesInput
    upsert?: tournamentsUpsertWithoutGamesInput
    disconnect?: tournamentsWhereInput | boolean
    delete?: tournamentsWhereInput | boolean
    connect?: tournamentsWhereUniqueInput
    update?: XOR<XOR<tournamentsUpdateToOneWithWhereWithoutGamesInput, tournamentsUpdateWithoutGamesInput>, tournamentsUncheckedUpdateWithoutGamesInput>
  }

  export type websocket_connectionsUpdateManyWithoutGameNestedInput = {
    create?: XOR<websocket_connectionsCreateWithoutGameInput, websocket_connectionsUncheckedCreateWithoutGameInput> | websocket_connectionsCreateWithoutGameInput[] | websocket_connectionsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: websocket_connectionsCreateOrConnectWithoutGameInput | websocket_connectionsCreateOrConnectWithoutGameInput[]
    upsert?: websocket_connectionsUpsertWithWhereUniqueWithoutGameInput | websocket_connectionsUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: websocket_connectionsCreateManyGameInputEnvelope
    set?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    disconnect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    delete?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    connect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    update?: websocket_connectionsUpdateWithWhereUniqueWithoutGameInput | websocket_connectionsUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: websocket_connectionsUpdateManyWithWhereWithoutGameInput | websocket_connectionsUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: websocket_connectionsScalarWhereInput | websocket_connectionsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutWhiteGamesNestedInput = {
    create?: XOR<usersCreateWithoutWhiteGamesInput, usersUncheckedCreateWithoutWhiteGamesInput>
    connectOrCreate?: usersCreateOrConnectWithoutWhiteGamesInput
    upsert?: usersUpsertWithoutWhiteGamesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutWhiteGamesInput, usersUpdateWithoutWhiteGamesInput>, usersUncheckedUpdateWithoutWhiteGamesInput>
  }

  export type usersUpdateOneWithoutBlackGamesNestedInput = {
    create?: XOR<usersCreateWithoutBlackGamesInput, usersUncheckedCreateWithoutBlackGamesInput>
    connectOrCreate?: usersCreateOrConnectWithoutBlackGamesInput
    upsert?: usersUpsertWithoutBlackGamesInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutBlackGamesInput, usersUpdateWithoutBlackGamesInput>, usersUncheckedUpdateWithoutBlackGamesInput>
  }

  export type matchesUpdateOneWithoutGameNestedInput = {
    create?: XOR<matchesCreateWithoutGameInput, matchesUncheckedCreateWithoutGameInput>
    connectOrCreate?: matchesCreateOrConnectWithoutGameInput
    upsert?: matchesUpsertWithoutGameInput
    disconnect?: matchesWhereInput | boolean
    delete?: matchesWhereInput | boolean
    connect?: matchesWhereUniqueInput
    update?: XOR<XOR<matchesUpdateToOneWithWhereWithoutGameInput, matchesUpdateWithoutGameInput>, matchesUncheckedUpdateWithoutGameInput>
  }

  export type tournament_matchesUpdateOneWithoutGameNestedInput = {
    create?: XOR<tournament_matchesCreateWithoutGameInput, tournament_matchesUncheckedCreateWithoutGameInput>
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutGameInput
    upsert?: tournament_matchesUpsertWithoutGameInput
    disconnect?: tournament_matchesWhereInput | boolean
    delete?: tournament_matchesWhereInput | boolean
    connect?: tournament_matchesWhereUniqueInput
    update?: XOR<XOR<tournament_matchesUpdateToOneWithWhereWithoutGameInput, tournament_matchesUpdateWithoutGameInput>, tournament_matchesUncheckedUpdateWithoutGameInput>
  }

  export type GameSessionUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput> | GameSessionCreateWithoutGameInput[] | GameSessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutGameInput | GameSessionCreateOrConnectWithoutGameInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutGameInput | GameSessionUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameSessionCreateManyGameInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutGameInput | GameSessionUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutGameInput | GameSessionUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type GameEventUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameEventCreateWithoutGameInput, GameEventUncheckedCreateWithoutGameInput> | GameEventCreateWithoutGameInput[] | GameEventUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutGameInput | GameEventCreateOrConnectWithoutGameInput[]
    upsert?: GameEventUpsertWithWhereUniqueWithoutGameInput | GameEventUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameEventCreateManyGameInputEnvelope
    set?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    disconnect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    delete?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    update?: GameEventUpdateWithWhereUniqueWithoutGameInput | GameEventUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameEventUpdateManyWithWhereWithoutGameInput | GameEventUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameEventScalarWhereInput | GameEventScalarWhereInput[]
  }

  export type chat_messagesUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<chat_messagesCreateWithoutGameInput, chat_messagesUncheckedCreateWithoutGameInput> | chat_messagesCreateWithoutGameInput[] | chat_messagesUncheckedCreateWithoutGameInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutGameInput | chat_messagesCreateOrConnectWithoutGameInput[]
    upsert?: chat_messagesUpsertWithWhereUniqueWithoutGameInput | chat_messagesUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: chat_messagesCreateManyGameInputEnvelope
    set?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    disconnect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    delete?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    update?: chat_messagesUpdateWithWhereUniqueWithoutGameInput | chat_messagesUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: chat_messagesUpdateManyWithWhereWithoutGameInput | chat_messagesUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
  }

  export type game_movesUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<game_movesCreateWithoutGameInput, game_movesUncheckedCreateWithoutGameInput> | game_movesCreateWithoutGameInput[] | game_movesUncheckedCreateWithoutGameInput[]
    connectOrCreate?: game_movesCreateOrConnectWithoutGameInput | game_movesCreateOrConnectWithoutGameInput[]
    upsert?: game_movesUpsertWithWhereUniqueWithoutGameInput | game_movesUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: game_movesCreateManyGameInputEnvelope
    set?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    disconnect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    delete?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    connect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    update?: game_movesUpdateWithWhereUniqueWithoutGameInput | game_movesUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: game_movesUpdateManyWithWhereWithoutGameInput | game_movesUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: game_movesScalarWhereInput | game_movesScalarWhereInput[]
  }

  export type websocket_connectionsUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<websocket_connectionsCreateWithoutGameInput, websocket_connectionsUncheckedCreateWithoutGameInput> | websocket_connectionsCreateWithoutGameInput[] | websocket_connectionsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: websocket_connectionsCreateOrConnectWithoutGameInput | websocket_connectionsCreateOrConnectWithoutGameInput[]
    upsert?: websocket_connectionsUpsertWithWhereUniqueWithoutGameInput | websocket_connectionsUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: websocket_connectionsCreateManyGameInputEnvelope
    set?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    disconnect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    delete?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    connect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    update?: websocket_connectionsUpdateWithWhereUniqueWithoutGameInput | websocket_connectionsUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: websocket_connectionsUpdateManyWithWhereWithoutGameInput | websocket_connectionsUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: websocket_connectionsScalarWhereInput | websocket_connectionsScalarWhereInput[]
  }

  export type matchesUncheckedUpdateOneWithoutGameNestedInput = {
    create?: XOR<matchesCreateWithoutGameInput, matchesUncheckedCreateWithoutGameInput>
    connectOrCreate?: matchesCreateOrConnectWithoutGameInput
    upsert?: matchesUpsertWithoutGameInput
    disconnect?: matchesWhereInput | boolean
    delete?: matchesWhereInput | boolean
    connect?: matchesWhereUniqueInput
    update?: XOR<XOR<matchesUpdateToOneWithWhereWithoutGameInput, matchesUpdateWithoutGameInput>, matchesUncheckedUpdateWithoutGameInput>
  }

  export type tournament_matchesUncheckedUpdateOneWithoutGameNestedInput = {
    create?: XOR<tournament_matchesCreateWithoutGameInput, tournament_matchesUncheckedCreateWithoutGameInput>
    connectOrCreate?: tournament_matchesCreateOrConnectWithoutGameInput
    upsert?: tournament_matchesUpsertWithoutGameInput
    disconnect?: tournament_matchesWhereInput | boolean
    delete?: tournament_matchesWhereInput | boolean
    connect?: tournament_matchesWhereUniqueInput
    update?: XOR<XOR<tournament_matchesUpdateToOneWithWhereWithoutGameInput, tournament_matchesUpdateWithoutGameInput>, tournament_matchesUncheckedUpdateWithoutGameInput>
  }

  export type GameSessionUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput> | GameSessionCreateWithoutGameInput[] | GameSessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutGameInput | GameSessionCreateOrConnectWithoutGameInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutGameInput | GameSessionUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameSessionCreateManyGameInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutGameInput | GameSessionUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutGameInput | GameSessionUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type GameEventUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameEventCreateWithoutGameInput, GameEventUncheckedCreateWithoutGameInput> | GameEventCreateWithoutGameInput[] | GameEventUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutGameInput | GameEventCreateOrConnectWithoutGameInput[]
    upsert?: GameEventUpsertWithWhereUniqueWithoutGameInput | GameEventUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameEventCreateManyGameInputEnvelope
    set?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    disconnect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    delete?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    update?: GameEventUpdateWithWhereUniqueWithoutGameInput | GameEventUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameEventUpdateManyWithWhereWithoutGameInput | GameEventUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameEventScalarWhereInput | GameEventScalarWhereInput[]
  }

  export type gamesCreateNestedOneWithoutSessionsInput = {
    create?: XOR<gamesCreateWithoutSessionsInput, gamesUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: gamesCreateOrConnectWithoutSessionsInput
    connect?: gamesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutGameSessionsInput = {
    create?: XOR<usersCreateWithoutGameSessionsInput, usersUncheckedCreateWithoutGameSessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutGameSessionsInput
    connect?: usersWhereUniqueInput
  }

  export type gamesUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<gamesCreateWithoutSessionsInput, gamesUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: gamesCreateOrConnectWithoutSessionsInput
    upsert?: gamesUpsertWithoutSessionsInput
    connect?: gamesWhereUniqueInput
    update?: XOR<XOR<gamesUpdateToOneWithWhereWithoutSessionsInput, gamesUpdateWithoutSessionsInput>, gamesUncheckedUpdateWithoutSessionsInput>
  }

  export type usersUpdateOneRequiredWithoutGameSessionsNestedInput = {
    create?: XOR<usersCreateWithoutGameSessionsInput, usersUncheckedCreateWithoutGameSessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutGameSessionsInput
    upsert?: usersUpsertWithoutGameSessionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutGameSessionsInput, usersUpdateWithoutGameSessionsInput>, usersUncheckedUpdateWithoutGameSessionsInput>
  }

  export type gamesCreateNestedOneWithoutEventsInput = {
    create?: XOR<gamesCreateWithoutEventsInput, gamesUncheckedCreateWithoutEventsInput>
    connectOrCreate?: gamesCreateOrConnectWithoutEventsInput
    connect?: gamesWhereUniqueInput
  }

  export type gamesUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<gamesCreateWithoutEventsInput, gamesUncheckedCreateWithoutEventsInput>
    connectOrCreate?: gamesCreateOrConnectWithoutEventsInput
    upsert?: gamesUpsertWithoutEventsInput
    connect?: gamesWhereUniqueInput
    update?: XOR<XOR<gamesUpdateToOneWithWhereWithoutEventsInput, gamesUpdateWithoutEventsInput>, gamesUncheckedUpdateWithoutEventsInput>
  }

  export type gamesCreateNestedOneWithoutMatchInput = {
    create?: XOR<gamesCreateWithoutMatchInput, gamesUncheckedCreateWithoutMatchInput>
    connectOrCreate?: gamesCreateOrConnectWithoutMatchInput
    connect?: gamesWhereUniqueInput
  }

  export type EnumMatchStateFieldUpdateOperationsInput = {
    set?: $Enums.MatchState
  }

  export type gamesUpdateOneRequiredWithoutMatchNestedInput = {
    create?: XOR<gamesCreateWithoutMatchInput, gamesUncheckedCreateWithoutMatchInput>
    connectOrCreate?: gamesCreateOrConnectWithoutMatchInput
    upsert?: gamesUpsertWithoutMatchInput
    connect?: gamesWhereUniqueInput
    update?: XOR<XOR<gamesUpdateToOneWithWhereWithoutMatchInput, gamesUpdateWithoutMatchInput>, gamesUncheckedUpdateWithoutMatchInput>
  }

  export type analysesCreateNestedManyWithoutUserInput = {
    create?: XOR<analysesCreateWithoutUserInput, analysesUncheckedCreateWithoutUserInput> | analysesCreateWithoutUserInput[] | analysesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: analysesCreateOrConnectWithoutUserInput | analysesCreateOrConnectWithoutUserInput[]
    createMany?: analysesCreateManyUserInputEnvelope
    connect?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
  }

  export type AnalysisQuotaCreateNestedManyWithoutUserInput = {
    create?: XOR<AnalysisQuotaCreateWithoutUserInput, AnalysisQuotaUncheckedCreateWithoutUserInput> | AnalysisQuotaCreateWithoutUserInput[] | AnalysisQuotaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalysisQuotaCreateOrConnectWithoutUserInput | AnalysisQuotaCreateOrConnectWithoutUserInput[]
    createMany?: AnalysisQuotaCreateManyUserInputEnvelope
    connect?: AnalysisQuotaWhereUniqueInput | AnalysisQuotaWhereUniqueInput[]
  }

  export type IAQuotaCreateNestedOneWithoutUserInput = {
    create?: XOR<IAQuotaCreateWithoutUserInput, IAQuotaUncheckedCreateWithoutUserInput>
    connectOrCreate?: IAQuotaCreateOrConnectWithoutUserInput
    connect?: IAQuotaWhereUniqueInput
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type chat_messagesCreateNestedManyWithoutUserInput = {
    create?: XOR<chat_messagesCreateWithoutUserInput, chat_messagesUncheckedCreateWithoutUserInput> | chat_messagesCreateWithoutUserInput[] | chat_messagesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutUserInput | chat_messagesCreateOrConnectWithoutUserInput[]
    createMany?: chat_messagesCreateManyUserInputEnvelope
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
  }

  export type game_movesCreateNestedManyWithoutUserInput = {
    create?: XOR<game_movesCreateWithoutUserInput, game_movesUncheckedCreateWithoutUserInput> | game_movesCreateWithoutUserInput[] | game_movesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: game_movesCreateOrConnectWithoutUserInput | game_movesCreateOrConnectWithoutUserInput[]
    createMany?: game_movesCreateManyUserInputEnvelope
    connect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
  }

  export type user_analyticsCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_analyticsCreateWithoutUsersInput, user_analyticsUncheckedCreateWithoutUsersInput> | user_analyticsCreateWithoutUsersInput[] | user_analyticsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_analyticsCreateOrConnectWithoutUsersInput | user_analyticsCreateOrConnectWithoutUsersInput[]
    createMany?: user_analyticsCreateManyUsersInputEnvelope
    connect?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
  }

  export type game_analysesCreateNestedManyWithoutUsersInput = {
    create?: XOR<game_analysesCreateWithoutUsersInput, game_analysesUncheckedCreateWithoutUsersInput> | game_analysesCreateWithoutUsersInput[] | game_analysesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: game_analysesCreateOrConnectWithoutUsersInput | game_analysesCreateOrConnectWithoutUsersInput[]
    createMany?: game_analysesCreateManyUsersInputEnvelope
    connect?: game_analysesWhereUniqueInput | game_analysesWhereUniqueInput[]
  }

  export type subscriptionsCreateNestedOneWithoutUsersInput = {
    create?: XOR<subscriptionsCreateWithoutUsersInput, subscriptionsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: subscriptionsCreateOrConnectWithoutUsersInput
    connect?: subscriptionsWhereUniqueInput
  }

  export type tournament_participantsCreateNestedManyWithoutUsersInput = {
    create?: XOR<tournament_participantsCreateWithoutUsersInput, tournament_participantsUncheckedCreateWithoutUsersInput> | tournament_participantsCreateWithoutUsersInput[] | tournament_participantsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutUsersInput | tournament_participantsCreateOrConnectWithoutUsersInput[]
    createMany?: tournament_participantsCreateManyUsersInputEnvelope
    connect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
  }

  export type tournamentsCreateNestedManyWithoutCreatorInput = {
    create?: XOR<tournamentsCreateWithoutCreatorInput, tournamentsUncheckedCreateWithoutCreatorInput> | tournamentsCreateWithoutCreatorInput[] | tournamentsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: tournamentsCreateOrConnectWithoutCreatorInput | tournamentsCreateOrConnectWithoutCreatorInput[]
    createMany?: tournamentsCreateManyCreatorInputEnvelope
    connect?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
  }

  export type websocket_connectionsCreateNestedManyWithoutUserInput = {
    create?: XOR<websocket_connectionsCreateWithoutUserInput, websocket_connectionsUncheckedCreateWithoutUserInput> | websocket_connectionsCreateWithoutUserInput[] | websocket_connectionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: websocket_connectionsCreateOrConnectWithoutUserInput | websocket_connectionsCreateOrConnectWithoutUserInput[]
    createMany?: websocket_connectionsCreateManyUserInputEnvelope
    connect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
  }

  export type gamesCreateNestedManyWithoutWhitePlayerInput = {
    create?: XOR<gamesCreateWithoutWhitePlayerInput, gamesUncheckedCreateWithoutWhitePlayerInput> | gamesCreateWithoutWhitePlayerInput[] | gamesUncheckedCreateWithoutWhitePlayerInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutWhitePlayerInput | gamesCreateOrConnectWithoutWhitePlayerInput[]
    createMany?: gamesCreateManyWhitePlayerInputEnvelope
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
  }

  export type gamesCreateNestedManyWithoutBlackPlayerInput = {
    create?: XOR<gamesCreateWithoutBlackPlayerInput, gamesUncheckedCreateWithoutBlackPlayerInput> | gamesCreateWithoutBlackPlayerInput[] | gamesUncheckedCreateWithoutBlackPlayerInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutBlackPlayerInput | gamesCreateOrConnectWithoutBlackPlayerInput[]
    createMany?: gamesCreateManyBlackPlayerInputEnvelope
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
  }

  export type GameSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<GameSessionCreateWithoutUserInput, GameSessionUncheckedCreateWithoutUserInput> | GameSessionCreateWithoutUserInput[] | GameSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutUserInput | GameSessionCreateOrConnectWithoutUserInput[]
    createMany?: GameSessionCreateManyUserInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type user_season_statsCreateNestedManyWithoutUserInput = {
    create?: XOR<user_season_statsCreateWithoutUserInput, user_season_statsUncheckedCreateWithoutUserInput> | user_season_statsCreateWithoutUserInput[] | user_season_statsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_season_statsCreateOrConnectWithoutUserInput | user_season_statsCreateOrConnectWithoutUserInput[]
    createMany?: user_season_statsCreateManyUserInputEnvelope
    connect?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
  }

  export type season_leaderboardCreateNestedManyWithoutUserInput = {
    create?: XOR<season_leaderboardCreateWithoutUserInput, season_leaderboardUncheckedCreateWithoutUserInput> | season_leaderboardCreateWithoutUserInput[] | season_leaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: season_leaderboardCreateOrConnectWithoutUserInput | season_leaderboardCreateOrConnectWithoutUserInput[]
    createMany?: season_leaderboardCreateManyUserInputEnvelope
    connect?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
  }

  export type user_quota_historyCreateNestedManyWithoutUserInput = {
    create?: XOR<user_quota_historyCreateWithoutUserInput, user_quota_historyUncheckedCreateWithoutUserInput> | user_quota_historyCreateWithoutUserInput[] | user_quota_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_quota_historyCreateOrConnectWithoutUserInput | user_quota_historyCreateOrConnectWithoutUserInput[]
    createMany?: user_quota_historyCreateManyUserInputEnvelope
    connect?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
  }

  export type analysesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<analysesCreateWithoutUserInput, analysesUncheckedCreateWithoutUserInput> | analysesCreateWithoutUserInput[] | analysesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: analysesCreateOrConnectWithoutUserInput | analysesCreateOrConnectWithoutUserInput[]
    createMany?: analysesCreateManyUserInputEnvelope
    connect?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
  }

  export type AnalysisQuotaUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AnalysisQuotaCreateWithoutUserInput, AnalysisQuotaUncheckedCreateWithoutUserInput> | AnalysisQuotaCreateWithoutUserInput[] | AnalysisQuotaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalysisQuotaCreateOrConnectWithoutUserInput | AnalysisQuotaCreateOrConnectWithoutUserInput[]
    createMany?: AnalysisQuotaCreateManyUserInputEnvelope
    connect?: AnalysisQuotaWhereUniqueInput | AnalysisQuotaWhereUniqueInput[]
  }

  export type IAQuotaUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<IAQuotaCreateWithoutUserInput, IAQuotaUncheckedCreateWithoutUserInput>
    connectOrCreate?: IAQuotaCreateOrConnectWithoutUserInput
    connect?: IAQuotaWhereUniqueInput
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type chat_messagesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<chat_messagesCreateWithoutUserInput, chat_messagesUncheckedCreateWithoutUserInput> | chat_messagesCreateWithoutUserInput[] | chat_messagesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutUserInput | chat_messagesCreateOrConnectWithoutUserInput[]
    createMany?: chat_messagesCreateManyUserInputEnvelope
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
  }

  export type game_movesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<game_movesCreateWithoutUserInput, game_movesUncheckedCreateWithoutUserInput> | game_movesCreateWithoutUserInput[] | game_movesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: game_movesCreateOrConnectWithoutUserInput | game_movesCreateOrConnectWithoutUserInput[]
    createMany?: game_movesCreateManyUserInputEnvelope
    connect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
  }

  export type user_analyticsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_analyticsCreateWithoutUsersInput, user_analyticsUncheckedCreateWithoutUsersInput> | user_analyticsCreateWithoutUsersInput[] | user_analyticsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_analyticsCreateOrConnectWithoutUsersInput | user_analyticsCreateOrConnectWithoutUsersInput[]
    createMany?: user_analyticsCreateManyUsersInputEnvelope
    connect?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
  }

  export type game_analysesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<game_analysesCreateWithoutUsersInput, game_analysesUncheckedCreateWithoutUsersInput> | game_analysesCreateWithoutUsersInput[] | game_analysesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: game_analysesCreateOrConnectWithoutUsersInput | game_analysesCreateOrConnectWithoutUsersInput[]
    createMany?: game_analysesCreateManyUsersInputEnvelope
    connect?: game_analysesWhereUniqueInput | game_analysesWhereUniqueInput[]
  }

  export type subscriptionsUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<subscriptionsCreateWithoutUsersInput, subscriptionsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: subscriptionsCreateOrConnectWithoutUsersInput
    connect?: subscriptionsWhereUniqueInput
  }

  export type tournament_participantsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<tournament_participantsCreateWithoutUsersInput, tournament_participantsUncheckedCreateWithoutUsersInput> | tournament_participantsCreateWithoutUsersInput[] | tournament_participantsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutUsersInput | tournament_participantsCreateOrConnectWithoutUsersInput[]
    createMany?: tournament_participantsCreateManyUsersInputEnvelope
    connect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
  }

  export type tournamentsUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<tournamentsCreateWithoutCreatorInput, tournamentsUncheckedCreateWithoutCreatorInput> | tournamentsCreateWithoutCreatorInput[] | tournamentsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: tournamentsCreateOrConnectWithoutCreatorInput | tournamentsCreateOrConnectWithoutCreatorInput[]
    createMany?: tournamentsCreateManyCreatorInputEnvelope
    connect?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
  }

  export type websocket_connectionsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<websocket_connectionsCreateWithoutUserInput, websocket_connectionsUncheckedCreateWithoutUserInput> | websocket_connectionsCreateWithoutUserInput[] | websocket_connectionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: websocket_connectionsCreateOrConnectWithoutUserInput | websocket_connectionsCreateOrConnectWithoutUserInput[]
    createMany?: websocket_connectionsCreateManyUserInputEnvelope
    connect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
  }

  export type gamesUncheckedCreateNestedManyWithoutWhitePlayerInput = {
    create?: XOR<gamesCreateWithoutWhitePlayerInput, gamesUncheckedCreateWithoutWhitePlayerInput> | gamesCreateWithoutWhitePlayerInput[] | gamesUncheckedCreateWithoutWhitePlayerInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutWhitePlayerInput | gamesCreateOrConnectWithoutWhitePlayerInput[]
    createMany?: gamesCreateManyWhitePlayerInputEnvelope
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
  }

  export type gamesUncheckedCreateNestedManyWithoutBlackPlayerInput = {
    create?: XOR<gamesCreateWithoutBlackPlayerInput, gamesUncheckedCreateWithoutBlackPlayerInput> | gamesCreateWithoutBlackPlayerInput[] | gamesUncheckedCreateWithoutBlackPlayerInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutBlackPlayerInput | gamesCreateOrConnectWithoutBlackPlayerInput[]
    createMany?: gamesCreateManyBlackPlayerInputEnvelope
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
  }

  export type GameSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GameSessionCreateWithoutUserInput, GameSessionUncheckedCreateWithoutUserInput> | GameSessionCreateWithoutUserInput[] | GameSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutUserInput | GameSessionCreateOrConnectWithoutUserInput[]
    createMany?: GameSessionCreateManyUserInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type user_season_statsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<user_season_statsCreateWithoutUserInput, user_season_statsUncheckedCreateWithoutUserInput> | user_season_statsCreateWithoutUserInput[] | user_season_statsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_season_statsCreateOrConnectWithoutUserInput | user_season_statsCreateOrConnectWithoutUserInput[]
    createMany?: user_season_statsCreateManyUserInputEnvelope
    connect?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
  }

  export type season_leaderboardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<season_leaderboardCreateWithoutUserInput, season_leaderboardUncheckedCreateWithoutUserInput> | season_leaderboardCreateWithoutUserInput[] | season_leaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: season_leaderboardCreateOrConnectWithoutUserInput | season_leaderboardCreateOrConnectWithoutUserInput[]
    createMany?: season_leaderboardCreateManyUserInputEnvelope
    connect?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
  }

  export type user_quota_historyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<user_quota_historyCreateWithoutUserInput, user_quota_historyUncheckedCreateWithoutUserInput> | user_quota_historyCreateWithoutUserInput[] | user_quota_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_quota_historyCreateOrConnectWithoutUserInput | user_quota_historyCreateOrConnectWithoutUserInput[]
    createMany?: user_quota_historyCreateManyUserInputEnvelope
    connect?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
  }

  export type EnumSubscriptionTypeFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionType
  }

  export type analysesUpdateManyWithoutUserNestedInput = {
    create?: XOR<analysesCreateWithoutUserInput, analysesUncheckedCreateWithoutUserInput> | analysesCreateWithoutUserInput[] | analysesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: analysesCreateOrConnectWithoutUserInput | analysesCreateOrConnectWithoutUserInput[]
    upsert?: analysesUpsertWithWhereUniqueWithoutUserInput | analysesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: analysesCreateManyUserInputEnvelope
    set?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
    disconnect?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
    delete?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
    connect?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
    update?: analysesUpdateWithWhereUniqueWithoutUserInput | analysesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: analysesUpdateManyWithWhereWithoutUserInput | analysesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: analysesScalarWhereInput | analysesScalarWhereInput[]
  }

  export type AnalysisQuotaUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnalysisQuotaCreateWithoutUserInput, AnalysisQuotaUncheckedCreateWithoutUserInput> | AnalysisQuotaCreateWithoutUserInput[] | AnalysisQuotaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalysisQuotaCreateOrConnectWithoutUserInput | AnalysisQuotaCreateOrConnectWithoutUserInput[]
    upsert?: AnalysisQuotaUpsertWithWhereUniqueWithoutUserInput | AnalysisQuotaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnalysisQuotaCreateManyUserInputEnvelope
    set?: AnalysisQuotaWhereUniqueInput | AnalysisQuotaWhereUniqueInput[]
    disconnect?: AnalysisQuotaWhereUniqueInput | AnalysisQuotaWhereUniqueInput[]
    delete?: AnalysisQuotaWhereUniqueInput | AnalysisQuotaWhereUniqueInput[]
    connect?: AnalysisQuotaWhereUniqueInput | AnalysisQuotaWhereUniqueInput[]
    update?: AnalysisQuotaUpdateWithWhereUniqueWithoutUserInput | AnalysisQuotaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnalysisQuotaUpdateManyWithWhereWithoutUserInput | AnalysisQuotaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnalysisQuotaScalarWhereInput | AnalysisQuotaScalarWhereInput[]
  }

  export type IAQuotaUpdateOneWithoutUserNestedInput = {
    create?: XOR<IAQuotaCreateWithoutUserInput, IAQuotaUncheckedCreateWithoutUserInput>
    connectOrCreate?: IAQuotaCreateOrConnectWithoutUserInput
    upsert?: IAQuotaUpsertWithoutUserInput
    disconnect?: IAQuotaWhereInput | boolean
    delete?: IAQuotaWhereInput | boolean
    connect?: IAQuotaWhereUniqueInput
    update?: XOR<XOR<IAQuotaUpdateToOneWithWhereWithoutUserInput, IAQuotaUpdateWithoutUserInput>, IAQuotaUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type chat_messagesUpdateManyWithoutUserNestedInput = {
    create?: XOR<chat_messagesCreateWithoutUserInput, chat_messagesUncheckedCreateWithoutUserInput> | chat_messagesCreateWithoutUserInput[] | chat_messagesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutUserInput | chat_messagesCreateOrConnectWithoutUserInput[]
    upsert?: chat_messagesUpsertWithWhereUniqueWithoutUserInput | chat_messagesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: chat_messagesCreateManyUserInputEnvelope
    set?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    disconnect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    delete?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    update?: chat_messagesUpdateWithWhereUniqueWithoutUserInput | chat_messagesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: chat_messagesUpdateManyWithWhereWithoutUserInput | chat_messagesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
  }

  export type game_movesUpdateManyWithoutUserNestedInput = {
    create?: XOR<game_movesCreateWithoutUserInput, game_movesUncheckedCreateWithoutUserInput> | game_movesCreateWithoutUserInput[] | game_movesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: game_movesCreateOrConnectWithoutUserInput | game_movesCreateOrConnectWithoutUserInput[]
    upsert?: game_movesUpsertWithWhereUniqueWithoutUserInput | game_movesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: game_movesCreateManyUserInputEnvelope
    set?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    disconnect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    delete?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    connect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    update?: game_movesUpdateWithWhereUniqueWithoutUserInput | game_movesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: game_movesUpdateManyWithWhereWithoutUserInput | game_movesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: game_movesScalarWhereInput | game_movesScalarWhereInput[]
  }

  export type user_analyticsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_analyticsCreateWithoutUsersInput, user_analyticsUncheckedCreateWithoutUsersInput> | user_analyticsCreateWithoutUsersInput[] | user_analyticsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_analyticsCreateOrConnectWithoutUsersInput | user_analyticsCreateOrConnectWithoutUsersInput[]
    upsert?: user_analyticsUpsertWithWhereUniqueWithoutUsersInput | user_analyticsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_analyticsCreateManyUsersInputEnvelope
    set?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
    disconnect?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
    delete?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
    connect?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
    update?: user_analyticsUpdateWithWhereUniqueWithoutUsersInput | user_analyticsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_analyticsUpdateManyWithWhereWithoutUsersInput | user_analyticsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_analyticsScalarWhereInput | user_analyticsScalarWhereInput[]
  }

  export type game_analysesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<game_analysesCreateWithoutUsersInput, game_analysesUncheckedCreateWithoutUsersInput> | game_analysesCreateWithoutUsersInput[] | game_analysesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: game_analysesCreateOrConnectWithoutUsersInput | game_analysesCreateOrConnectWithoutUsersInput[]
    upsert?: game_analysesUpsertWithWhereUniqueWithoutUsersInput | game_analysesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: game_analysesCreateManyUsersInputEnvelope
    set?: game_analysesWhereUniqueInput | game_analysesWhereUniqueInput[]
    disconnect?: game_analysesWhereUniqueInput | game_analysesWhereUniqueInput[]
    delete?: game_analysesWhereUniqueInput | game_analysesWhereUniqueInput[]
    connect?: game_analysesWhereUniqueInput | game_analysesWhereUniqueInput[]
    update?: game_analysesUpdateWithWhereUniqueWithoutUsersInput | game_analysesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: game_analysesUpdateManyWithWhereWithoutUsersInput | game_analysesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: game_analysesScalarWhereInput | game_analysesScalarWhereInput[]
  }

  export type subscriptionsUpdateOneWithoutUsersNestedInput = {
    create?: XOR<subscriptionsCreateWithoutUsersInput, subscriptionsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: subscriptionsCreateOrConnectWithoutUsersInput
    upsert?: subscriptionsUpsertWithoutUsersInput
    disconnect?: subscriptionsWhereInput | boolean
    delete?: subscriptionsWhereInput | boolean
    connect?: subscriptionsWhereUniqueInput
    update?: XOR<XOR<subscriptionsUpdateToOneWithWhereWithoutUsersInput, subscriptionsUpdateWithoutUsersInput>, subscriptionsUncheckedUpdateWithoutUsersInput>
  }

  export type tournament_participantsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<tournament_participantsCreateWithoutUsersInput, tournament_participantsUncheckedCreateWithoutUsersInput> | tournament_participantsCreateWithoutUsersInput[] | tournament_participantsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutUsersInput | tournament_participantsCreateOrConnectWithoutUsersInput[]
    upsert?: tournament_participantsUpsertWithWhereUniqueWithoutUsersInput | tournament_participantsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: tournament_participantsCreateManyUsersInputEnvelope
    set?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    disconnect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    delete?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    connect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    update?: tournament_participantsUpdateWithWhereUniqueWithoutUsersInput | tournament_participantsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: tournament_participantsUpdateManyWithWhereWithoutUsersInput | tournament_participantsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: tournament_participantsScalarWhereInput | tournament_participantsScalarWhereInput[]
  }

  export type tournamentsUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<tournamentsCreateWithoutCreatorInput, tournamentsUncheckedCreateWithoutCreatorInput> | tournamentsCreateWithoutCreatorInput[] | tournamentsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: tournamentsCreateOrConnectWithoutCreatorInput | tournamentsCreateOrConnectWithoutCreatorInput[]
    upsert?: tournamentsUpsertWithWhereUniqueWithoutCreatorInput | tournamentsUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: tournamentsCreateManyCreatorInputEnvelope
    set?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
    disconnect?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
    delete?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
    connect?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
    update?: tournamentsUpdateWithWhereUniqueWithoutCreatorInput | tournamentsUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: tournamentsUpdateManyWithWhereWithoutCreatorInput | tournamentsUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: tournamentsScalarWhereInput | tournamentsScalarWhereInput[]
  }

  export type websocket_connectionsUpdateManyWithoutUserNestedInput = {
    create?: XOR<websocket_connectionsCreateWithoutUserInput, websocket_connectionsUncheckedCreateWithoutUserInput> | websocket_connectionsCreateWithoutUserInput[] | websocket_connectionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: websocket_connectionsCreateOrConnectWithoutUserInput | websocket_connectionsCreateOrConnectWithoutUserInput[]
    upsert?: websocket_connectionsUpsertWithWhereUniqueWithoutUserInput | websocket_connectionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: websocket_connectionsCreateManyUserInputEnvelope
    set?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    disconnect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    delete?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    connect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    update?: websocket_connectionsUpdateWithWhereUniqueWithoutUserInput | websocket_connectionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: websocket_connectionsUpdateManyWithWhereWithoutUserInput | websocket_connectionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: websocket_connectionsScalarWhereInput | websocket_connectionsScalarWhereInput[]
  }

  export type gamesUpdateManyWithoutWhitePlayerNestedInput = {
    create?: XOR<gamesCreateWithoutWhitePlayerInput, gamesUncheckedCreateWithoutWhitePlayerInput> | gamesCreateWithoutWhitePlayerInput[] | gamesUncheckedCreateWithoutWhitePlayerInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutWhitePlayerInput | gamesCreateOrConnectWithoutWhitePlayerInput[]
    upsert?: gamesUpsertWithWhereUniqueWithoutWhitePlayerInput | gamesUpsertWithWhereUniqueWithoutWhitePlayerInput[]
    createMany?: gamesCreateManyWhitePlayerInputEnvelope
    set?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    disconnect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    delete?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    update?: gamesUpdateWithWhereUniqueWithoutWhitePlayerInput | gamesUpdateWithWhereUniqueWithoutWhitePlayerInput[]
    updateMany?: gamesUpdateManyWithWhereWithoutWhitePlayerInput | gamesUpdateManyWithWhereWithoutWhitePlayerInput[]
    deleteMany?: gamesScalarWhereInput | gamesScalarWhereInput[]
  }

  export type gamesUpdateManyWithoutBlackPlayerNestedInput = {
    create?: XOR<gamesCreateWithoutBlackPlayerInput, gamesUncheckedCreateWithoutBlackPlayerInput> | gamesCreateWithoutBlackPlayerInput[] | gamesUncheckedCreateWithoutBlackPlayerInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutBlackPlayerInput | gamesCreateOrConnectWithoutBlackPlayerInput[]
    upsert?: gamesUpsertWithWhereUniqueWithoutBlackPlayerInput | gamesUpsertWithWhereUniqueWithoutBlackPlayerInput[]
    createMany?: gamesCreateManyBlackPlayerInputEnvelope
    set?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    disconnect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    delete?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    update?: gamesUpdateWithWhereUniqueWithoutBlackPlayerInput | gamesUpdateWithWhereUniqueWithoutBlackPlayerInput[]
    updateMany?: gamesUpdateManyWithWhereWithoutBlackPlayerInput | gamesUpdateManyWithWhereWithoutBlackPlayerInput[]
    deleteMany?: gamesScalarWhereInput | gamesScalarWhereInput[]
  }

  export type GameSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameSessionCreateWithoutUserInput, GameSessionUncheckedCreateWithoutUserInput> | GameSessionCreateWithoutUserInput[] | GameSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutUserInput | GameSessionCreateOrConnectWithoutUserInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutUserInput | GameSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameSessionCreateManyUserInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutUserInput | GameSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutUserInput | GameSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type user_season_statsUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_season_statsCreateWithoutUserInput, user_season_statsUncheckedCreateWithoutUserInput> | user_season_statsCreateWithoutUserInput[] | user_season_statsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_season_statsCreateOrConnectWithoutUserInput | user_season_statsCreateOrConnectWithoutUserInput[]
    upsert?: user_season_statsUpsertWithWhereUniqueWithoutUserInput | user_season_statsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_season_statsCreateManyUserInputEnvelope
    set?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
    disconnect?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
    delete?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
    connect?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
    update?: user_season_statsUpdateWithWhereUniqueWithoutUserInput | user_season_statsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_season_statsUpdateManyWithWhereWithoutUserInput | user_season_statsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_season_statsScalarWhereInput | user_season_statsScalarWhereInput[]
  }

  export type season_leaderboardUpdateManyWithoutUserNestedInput = {
    create?: XOR<season_leaderboardCreateWithoutUserInput, season_leaderboardUncheckedCreateWithoutUserInput> | season_leaderboardCreateWithoutUserInput[] | season_leaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: season_leaderboardCreateOrConnectWithoutUserInput | season_leaderboardCreateOrConnectWithoutUserInput[]
    upsert?: season_leaderboardUpsertWithWhereUniqueWithoutUserInput | season_leaderboardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: season_leaderboardCreateManyUserInputEnvelope
    set?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
    disconnect?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
    delete?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
    connect?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
    update?: season_leaderboardUpdateWithWhereUniqueWithoutUserInput | season_leaderboardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: season_leaderboardUpdateManyWithWhereWithoutUserInput | season_leaderboardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: season_leaderboardScalarWhereInput | season_leaderboardScalarWhereInput[]
  }

  export type user_quota_historyUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_quota_historyCreateWithoutUserInput, user_quota_historyUncheckedCreateWithoutUserInput> | user_quota_historyCreateWithoutUserInput[] | user_quota_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_quota_historyCreateOrConnectWithoutUserInput | user_quota_historyCreateOrConnectWithoutUserInput[]
    upsert?: user_quota_historyUpsertWithWhereUniqueWithoutUserInput | user_quota_historyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_quota_historyCreateManyUserInputEnvelope
    set?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
    disconnect?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
    delete?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
    connect?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
    update?: user_quota_historyUpdateWithWhereUniqueWithoutUserInput | user_quota_historyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_quota_historyUpdateManyWithWhereWithoutUserInput | user_quota_historyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_quota_historyScalarWhereInput | user_quota_historyScalarWhereInput[]
  }

  export type analysesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<analysesCreateWithoutUserInput, analysesUncheckedCreateWithoutUserInput> | analysesCreateWithoutUserInput[] | analysesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: analysesCreateOrConnectWithoutUserInput | analysesCreateOrConnectWithoutUserInput[]
    upsert?: analysesUpsertWithWhereUniqueWithoutUserInput | analysesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: analysesCreateManyUserInputEnvelope
    set?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
    disconnect?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
    delete?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
    connect?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
    update?: analysesUpdateWithWhereUniqueWithoutUserInput | analysesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: analysesUpdateManyWithWhereWithoutUserInput | analysesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: analysesScalarWhereInput | analysesScalarWhereInput[]
  }

  export type AnalysisQuotaUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnalysisQuotaCreateWithoutUserInput, AnalysisQuotaUncheckedCreateWithoutUserInput> | AnalysisQuotaCreateWithoutUserInput[] | AnalysisQuotaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalysisQuotaCreateOrConnectWithoutUserInput | AnalysisQuotaCreateOrConnectWithoutUserInput[]
    upsert?: AnalysisQuotaUpsertWithWhereUniqueWithoutUserInput | AnalysisQuotaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnalysisQuotaCreateManyUserInputEnvelope
    set?: AnalysisQuotaWhereUniqueInput | AnalysisQuotaWhereUniqueInput[]
    disconnect?: AnalysisQuotaWhereUniqueInput | AnalysisQuotaWhereUniqueInput[]
    delete?: AnalysisQuotaWhereUniqueInput | AnalysisQuotaWhereUniqueInput[]
    connect?: AnalysisQuotaWhereUniqueInput | AnalysisQuotaWhereUniqueInput[]
    update?: AnalysisQuotaUpdateWithWhereUniqueWithoutUserInput | AnalysisQuotaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnalysisQuotaUpdateManyWithWhereWithoutUserInput | AnalysisQuotaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnalysisQuotaScalarWhereInput | AnalysisQuotaScalarWhereInput[]
  }

  export type IAQuotaUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<IAQuotaCreateWithoutUserInput, IAQuotaUncheckedCreateWithoutUserInput>
    connectOrCreate?: IAQuotaCreateOrConnectWithoutUserInput
    upsert?: IAQuotaUpsertWithoutUserInput
    disconnect?: IAQuotaWhereInput | boolean
    delete?: IAQuotaWhereInput | boolean
    connect?: IAQuotaWhereUniqueInput
    update?: XOR<XOR<IAQuotaUpdateToOneWithWhereWithoutUserInput, IAQuotaUpdateWithoutUserInput>, IAQuotaUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type chat_messagesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<chat_messagesCreateWithoutUserInput, chat_messagesUncheckedCreateWithoutUserInput> | chat_messagesCreateWithoutUserInput[] | chat_messagesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutUserInput | chat_messagesCreateOrConnectWithoutUserInput[]
    upsert?: chat_messagesUpsertWithWhereUniqueWithoutUserInput | chat_messagesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: chat_messagesCreateManyUserInputEnvelope
    set?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    disconnect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    delete?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    update?: chat_messagesUpdateWithWhereUniqueWithoutUserInput | chat_messagesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: chat_messagesUpdateManyWithWhereWithoutUserInput | chat_messagesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
  }

  export type game_movesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<game_movesCreateWithoutUserInput, game_movesUncheckedCreateWithoutUserInput> | game_movesCreateWithoutUserInput[] | game_movesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: game_movesCreateOrConnectWithoutUserInput | game_movesCreateOrConnectWithoutUserInput[]
    upsert?: game_movesUpsertWithWhereUniqueWithoutUserInput | game_movesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: game_movesCreateManyUserInputEnvelope
    set?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    disconnect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    delete?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    connect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    update?: game_movesUpdateWithWhereUniqueWithoutUserInput | game_movesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: game_movesUpdateManyWithWhereWithoutUserInput | game_movesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: game_movesScalarWhereInput | game_movesScalarWhereInput[]
  }

  export type user_analyticsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_analyticsCreateWithoutUsersInput, user_analyticsUncheckedCreateWithoutUsersInput> | user_analyticsCreateWithoutUsersInput[] | user_analyticsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_analyticsCreateOrConnectWithoutUsersInput | user_analyticsCreateOrConnectWithoutUsersInput[]
    upsert?: user_analyticsUpsertWithWhereUniqueWithoutUsersInput | user_analyticsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_analyticsCreateManyUsersInputEnvelope
    set?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
    disconnect?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
    delete?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
    connect?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
    update?: user_analyticsUpdateWithWhereUniqueWithoutUsersInput | user_analyticsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_analyticsUpdateManyWithWhereWithoutUsersInput | user_analyticsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_analyticsScalarWhereInput | user_analyticsScalarWhereInput[]
  }

  export type game_analysesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<game_analysesCreateWithoutUsersInput, game_analysesUncheckedCreateWithoutUsersInput> | game_analysesCreateWithoutUsersInput[] | game_analysesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: game_analysesCreateOrConnectWithoutUsersInput | game_analysesCreateOrConnectWithoutUsersInput[]
    upsert?: game_analysesUpsertWithWhereUniqueWithoutUsersInput | game_analysesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: game_analysesCreateManyUsersInputEnvelope
    set?: game_analysesWhereUniqueInput | game_analysesWhereUniqueInput[]
    disconnect?: game_analysesWhereUniqueInput | game_analysesWhereUniqueInput[]
    delete?: game_analysesWhereUniqueInput | game_analysesWhereUniqueInput[]
    connect?: game_analysesWhereUniqueInput | game_analysesWhereUniqueInput[]
    update?: game_analysesUpdateWithWhereUniqueWithoutUsersInput | game_analysesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: game_analysesUpdateManyWithWhereWithoutUsersInput | game_analysesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: game_analysesScalarWhereInput | game_analysesScalarWhereInput[]
  }

  export type subscriptionsUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<subscriptionsCreateWithoutUsersInput, subscriptionsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: subscriptionsCreateOrConnectWithoutUsersInput
    upsert?: subscriptionsUpsertWithoutUsersInput
    disconnect?: subscriptionsWhereInput | boolean
    delete?: subscriptionsWhereInput | boolean
    connect?: subscriptionsWhereUniqueInput
    update?: XOR<XOR<subscriptionsUpdateToOneWithWhereWithoutUsersInput, subscriptionsUpdateWithoutUsersInput>, subscriptionsUncheckedUpdateWithoutUsersInput>
  }

  export type tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<tournament_participantsCreateWithoutUsersInput, tournament_participantsUncheckedCreateWithoutUsersInput> | tournament_participantsCreateWithoutUsersInput[] | tournament_participantsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutUsersInput | tournament_participantsCreateOrConnectWithoutUsersInput[]
    upsert?: tournament_participantsUpsertWithWhereUniqueWithoutUsersInput | tournament_participantsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: tournament_participantsCreateManyUsersInputEnvelope
    set?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    disconnect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    delete?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    connect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    update?: tournament_participantsUpdateWithWhereUniqueWithoutUsersInput | tournament_participantsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: tournament_participantsUpdateManyWithWhereWithoutUsersInput | tournament_participantsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: tournament_participantsScalarWhereInput | tournament_participantsScalarWhereInput[]
  }

  export type tournamentsUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<tournamentsCreateWithoutCreatorInput, tournamentsUncheckedCreateWithoutCreatorInput> | tournamentsCreateWithoutCreatorInput[] | tournamentsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: tournamentsCreateOrConnectWithoutCreatorInput | tournamentsCreateOrConnectWithoutCreatorInput[]
    upsert?: tournamentsUpsertWithWhereUniqueWithoutCreatorInput | tournamentsUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: tournamentsCreateManyCreatorInputEnvelope
    set?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
    disconnect?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
    delete?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
    connect?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
    update?: tournamentsUpdateWithWhereUniqueWithoutCreatorInput | tournamentsUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: tournamentsUpdateManyWithWhereWithoutCreatorInput | tournamentsUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: tournamentsScalarWhereInput | tournamentsScalarWhereInput[]
  }

  export type websocket_connectionsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<websocket_connectionsCreateWithoutUserInput, websocket_connectionsUncheckedCreateWithoutUserInput> | websocket_connectionsCreateWithoutUserInput[] | websocket_connectionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: websocket_connectionsCreateOrConnectWithoutUserInput | websocket_connectionsCreateOrConnectWithoutUserInput[]
    upsert?: websocket_connectionsUpsertWithWhereUniqueWithoutUserInput | websocket_connectionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: websocket_connectionsCreateManyUserInputEnvelope
    set?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    disconnect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    delete?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    connect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    update?: websocket_connectionsUpdateWithWhereUniqueWithoutUserInput | websocket_connectionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: websocket_connectionsUpdateManyWithWhereWithoutUserInput | websocket_connectionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: websocket_connectionsScalarWhereInput | websocket_connectionsScalarWhereInput[]
  }

  export type gamesUncheckedUpdateManyWithoutWhitePlayerNestedInput = {
    create?: XOR<gamesCreateWithoutWhitePlayerInput, gamesUncheckedCreateWithoutWhitePlayerInput> | gamesCreateWithoutWhitePlayerInput[] | gamesUncheckedCreateWithoutWhitePlayerInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutWhitePlayerInput | gamesCreateOrConnectWithoutWhitePlayerInput[]
    upsert?: gamesUpsertWithWhereUniqueWithoutWhitePlayerInput | gamesUpsertWithWhereUniqueWithoutWhitePlayerInput[]
    createMany?: gamesCreateManyWhitePlayerInputEnvelope
    set?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    disconnect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    delete?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    update?: gamesUpdateWithWhereUniqueWithoutWhitePlayerInput | gamesUpdateWithWhereUniqueWithoutWhitePlayerInput[]
    updateMany?: gamesUpdateManyWithWhereWithoutWhitePlayerInput | gamesUpdateManyWithWhereWithoutWhitePlayerInput[]
    deleteMany?: gamesScalarWhereInput | gamesScalarWhereInput[]
  }

  export type gamesUncheckedUpdateManyWithoutBlackPlayerNestedInput = {
    create?: XOR<gamesCreateWithoutBlackPlayerInput, gamesUncheckedCreateWithoutBlackPlayerInput> | gamesCreateWithoutBlackPlayerInput[] | gamesUncheckedCreateWithoutBlackPlayerInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutBlackPlayerInput | gamesCreateOrConnectWithoutBlackPlayerInput[]
    upsert?: gamesUpsertWithWhereUniqueWithoutBlackPlayerInput | gamesUpsertWithWhereUniqueWithoutBlackPlayerInput[]
    createMany?: gamesCreateManyBlackPlayerInputEnvelope
    set?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    disconnect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    delete?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    update?: gamesUpdateWithWhereUniqueWithoutBlackPlayerInput | gamesUpdateWithWhereUniqueWithoutBlackPlayerInput[]
    updateMany?: gamesUpdateManyWithWhereWithoutBlackPlayerInput | gamesUpdateManyWithWhereWithoutBlackPlayerInput[]
    deleteMany?: gamesScalarWhereInput | gamesScalarWhereInput[]
  }

  export type GameSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameSessionCreateWithoutUserInput, GameSessionUncheckedCreateWithoutUserInput> | GameSessionCreateWithoutUserInput[] | GameSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutUserInput | GameSessionCreateOrConnectWithoutUserInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutUserInput | GameSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameSessionCreateManyUserInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutUserInput | GameSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutUserInput | GameSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type user_season_statsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_season_statsCreateWithoutUserInput, user_season_statsUncheckedCreateWithoutUserInput> | user_season_statsCreateWithoutUserInput[] | user_season_statsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_season_statsCreateOrConnectWithoutUserInput | user_season_statsCreateOrConnectWithoutUserInput[]
    upsert?: user_season_statsUpsertWithWhereUniqueWithoutUserInput | user_season_statsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_season_statsCreateManyUserInputEnvelope
    set?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
    disconnect?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
    delete?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
    connect?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
    update?: user_season_statsUpdateWithWhereUniqueWithoutUserInput | user_season_statsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_season_statsUpdateManyWithWhereWithoutUserInput | user_season_statsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_season_statsScalarWhereInput | user_season_statsScalarWhereInput[]
  }

  export type season_leaderboardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<season_leaderboardCreateWithoutUserInput, season_leaderboardUncheckedCreateWithoutUserInput> | season_leaderboardCreateWithoutUserInput[] | season_leaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: season_leaderboardCreateOrConnectWithoutUserInput | season_leaderboardCreateOrConnectWithoutUserInput[]
    upsert?: season_leaderboardUpsertWithWhereUniqueWithoutUserInput | season_leaderboardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: season_leaderboardCreateManyUserInputEnvelope
    set?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
    disconnect?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
    delete?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
    connect?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
    update?: season_leaderboardUpdateWithWhereUniqueWithoutUserInput | season_leaderboardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: season_leaderboardUpdateManyWithWhereWithoutUserInput | season_leaderboardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: season_leaderboardScalarWhereInput | season_leaderboardScalarWhereInput[]
  }

  export type user_quota_historyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_quota_historyCreateWithoutUserInput, user_quota_historyUncheckedCreateWithoutUserInput> | user_quota_historyCreateWithoutUserInput[] | user_quota_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_quota_historyCreateOrConnectWithoutUserInput | user_quota_historyCreateOrConnectWithoutUserInput[]
    upsert?: user_quota_historyUpsertWithWhereUniqueWithoutUserInput | user_quota_historyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_quota_historyCreateManyUserInputEnvelope
    set?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
    disconnect?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
    delete?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
    connect?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
    update?: user_quota_historyUpdateWithWhereUniqueWithoutUserInput | user_quota_historyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_quota_historyUpdateManyWithWhereWithoutUserInput | user_quota_historyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_quota_historyScalarWhereInput | user_quota_historyScalarWhereInput[]
  }

  export type user_season_statsCreateNestedManyWithoutSeasonInput = {
    create?: XOR<user_season_statsCreateWithoutSeasonInput, user_season_statsUncheckedCreateWithoutSeasonInput> | user_season_statsCreateWithoutSeasonInput[] | user_season_statsUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: user_season_statsCreateOrConnectWithoutSeasonInput | user_season_statsCreateOrConnectWithoutSeasonInput[]
    createMany?: user_season_statsCreateManySeasonInputEnvelope
    connect?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
  }

  export type season_leaderboardCreateNestedManyWithoutSeasonInput = {
    create?: XOR<season_leaderboardCreateWithoutSeasonInput, season_leaderboardUncheckedCreateWithoutSeasonInput> | season_leaderboardCreateWithoutSeasonInput[] | season_leaderboardUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: season_leaderboardCreateOrConnectWithoutSeasonInput | season_leaderboardCreateOrConnectWithoutSeasonInput[]
    createMany?: season_leaderboardCreateManySeasonInputEnvelope
    connect?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
  }

  export type user_quota_historyCreateNestedManyWithoutSeasonInput = {
    create?: XOR<user_quota_historyCreateWithoutSeasonInput, user_quota_historyUncheckedCreateWithoutSeasonInput> | user_quota_historyCreateWithoutSeasonInput[] | user_quota_historyUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: user_quota_historyCreateOrConnectWithoutSeasonInput | user_quota_historyCreateOrConnectWithoutSeasonInput[]
    createMany?: user_quota_historyCreateManySeasonInputEnvelope
    connect?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
  }

  export type user_season_statsUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<user_season_statsCreateWithoutSeasonInput, user_season_statsUncheckedCreateWithoutSeasonInput> | user_season_statsCreateWithoutSeasonInput[] | user_season_statsUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: user_season_statsCreateOrConnectWithoutSeasonInput | user_season_statsCreateOrConnectWithoutSeasonInput[]
    createMany?: user_season_statsCreateManySeasonInputEnvelope
    connect?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
  }

  export type season_leaderboardUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<season_leaderboardCreateWithoutSeasonInput, season_leaderboardUncheckedCreateWithoutSeasonInput> | season_leaderboardCreateWithoutSeasonInput[] | season_leaderboardUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: season_leaderboardCreateOrConnectWithoutSeasonInput | season_leaderboardCreateOrConnectWithoutSeasonInput[]
    createMany?: season_leaderboardCreateManySeasonInputEnvelope
    connect?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
  }

  export type user_quota_historyUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<user_quota_historyCreateWithoutSeasonInput, user_quota_historyUncheckedCreateWithoutSeasonInput> | user_quota_historyCreateWithoutSeasonInput[] | user_quota_historyUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: user_quota_historyCreateOrConnectWithoutSeasonInput | user_quota_historyCreateOrConnectWithoutSeasonInput[]
    createMany?: user_quota_historyCreateManySeasonInputEnvelope
    connect?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
  }

  export type user_season_statsUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<user_season_statsCreateWithoutSeasonInput, user_season_statsUncheckedCreateWithoutSeasonInput> | user_season_statsCreateWithoutSeasonInput[] | user_season_statsUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: user_season_statsCreateOrConnectWithoutSeasonInput | user_season_statsCreateOrConnectWithoutSeasonInput[]
    upsert?: user_season_statsUpsertWithWhereUniqueWithoutSeasonInput | user_season_statsUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: user_season_statsCreateManySeasonInputEnvelope
    set?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
    disconnect?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
    delete?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
    connect?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
    update?: user_season_statsUpdateWithWhereUniqueWithoutSeasonInput | user_season_statsUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: user_season_statsUpdateManyWithWhereWithoutSeasonInput | user_season_statsUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: user_season_statsScalarWhereInput | user_season_statsScalarWhereInput[]
  }

  export type season_leaderboardUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<season_leaderboardCreateWithoutSeasonInput, season_leaderboardUncheckedCreateWithoutSeasonInput> | season_leaderboardCreateWithoutSeasonInput[] | season_leaderboardUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: season_leaderboardCreateOrConnectWithoutSeasonInput | season_leaderboardCreateOrConnectWithoutSeasonInput[]
    upsert?: season_leaderboardUpsertWithWhereUniqueWithoutSeasonInput | season_leaderboardUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: season_leaderboardCreateManySeasonInputEnvelope
    set?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
    disconnect?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
    delete?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
    connect?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
    update?: season_leaderboardUpdateWithWhereUniqueWithoutSeasonInput | season_leaderboardUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: season_leaderboardUpdateManyWithWhereWithoutSeasonInput | season_leaderboardUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: season_leaderboardScalarWhereInput | season_leaderboardScalarWhereInput[]
  }

  export type user_quota_historyUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<user_quota_historyCreateWithoutSeasonInput, user_quota_historyUncheckedCreateWithoutSeasonInput> | user_quota_historyCreateWithoutSeasonInput[] | user_quota_historyUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: user_quota_historyCreateOrConnectWithoutSeasonInput | user_quota_historyCreateOrConnectWithoutSeasonInput[]
    upsert?: user_quota_historyUpsertWithWhereUniqueWithoutSeasonInput | user_quota_historyUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: user_quota_historyCreateManySeasonInputEnvelope
    set?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
    disconnect?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
    delete?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
    connect?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
    update?: user_quota_historyUpdateWithWhereUniqueWithoutSeasonInput | user_quota_historyUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: user_quota_historyUpdateManyWithWhereWithoutSeasonInput | user_quota_historyUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: user_quota_historyScalarWhereInput | user_quota_historyScalarWhereInput[]
  }

  export type user_season_statsUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<user_season_statsCreateWithoutSeasonInput, user_season_statsUncheckedCreateWithoutSeasonInput> | user_season_statsCreateWithoutSeasonInput[] | user_season_statsUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: user_season_statsCreateOrConnectWithoutSeasonInput | user_season_statsCreateOrConnectWithoutSeasonInput[]
    upsert?: user_season_statsUpsertWithWhereUniqueWithoutSeasonInput | user_season_statsUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: user_season_statsCreateManySeasonInputEnvelope
    set?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
    disconnect?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
    delete?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
    connect?: user_season_statsWhereUniqueInput | user_season_statsWhereUniqueInput[]
    update?: user_season_statsUpdateWithWhereUniqueWithoutSeasonInput | user_season_statsUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: user_season_statsUpdateManyWithWhereWithoutSeasonInput | user_season_statsUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: user_season_statsScalarWhereInput | user_season_statsScalarWhereInput[]
  }

  export type season_leaderboardUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<season_leaderboardCreateWithoutSeasonInput, season_leaderboardUncheckedCreateWithoutSeasonInput> | season_leaderboardCreateWithoutSeasonInput[] | season_leaderboardUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: season_leaderboardCreateOrConnectWithoutSeasonInput | season_leaderboardCreateOrConnectWithoutSeasonInput[]
    upsert?: season_leaderboardUpsertWithWhereUniqueWithoutSeasonInput | season_leaderboardUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: season_leaderboardCreateManySeasonInputEnvelope
    set?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
    disconnect?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
    delete?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
    connect?: season_leaderboardWhereUniqueInput | season_leaderboardWhereUniqueInput[]
    update?: season_leaderboardUpdateWithWhereUniqueWithoutSeasonInput | season_leaderboardUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: season_leaderboardUpdateManyWithWhereWithoutSeasonInput | season_leaderboardUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: season_leaderboardScalarWhereInput | season_leaderboardScalarWhereInput[]
  }

  export type user_quota_historyUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<user_quota_historyCreateWithoutSeasonInput, user_quota_historyUncheckedCreateWithoutSeasonInput> | user_quota_historyCreateWithoutSeasonInput[] | user_quota_historyUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: user_quota_historyCreateOrConnectWithoutSeasonInput | user_quota_historyCreateOrConnectWithoutSeasonInput[]
    upsert?: user_quota_historyUpsertWithWhereUniqueWithoutSeasonInput | user_quota_historyUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: user_quota_historyCreateManySeasonInputEnvelope
    set?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
    disconnect?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
    delete?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
    connect?: user_quota_historyWhereUniqueInput | user_quota_historyWhereUniqueInput[]
    update?: user_quota_historyUpdateWithWhereUniqueWithoutSeasonInput | user_quota_historyUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: user_quota_historyUpdateManyWithWhereWithoutSeasonInput | user_quota_historyUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: user_quota_historyScalarWhereInput | user_quota_historyScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutSeasonStatsInput = {
    create?: XOR<usersCreateWithoutSeasonStatsInput, usersUncheckedCreateWithoutSeasonStatsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSeasonStatsInput
    connect?: usersWhereUniqueInput
  }

  export type seasonsCreateNestedOneWithoutSeasonStatsInput = {
    create?: XOR<seasonsCreateWithoutSeasonStatsInput, seasonsUncheckedCreateWithoutSeasonStatsInput>
    connectOrCreate?: seasonsCreateOrConnectWithoutSeasonStatsInput
    connect?: seasonsWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutSeasonStatsNestedInput = {
    create?: XOR<usersCreateWithoutSeasonStatsInput, usersUncheckedCreateWithoutSeasonStatsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSeasonStatsInput
    upsert?: usersUpsertWithoutSeasonStatsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSeasonStatsInput, usersUpdateWithoutSeasonStatsInput>, usersUncheckedUpdateWithoutSeasonStatsInput>
  }

  export type seasonsUpdateOneRequiredWithoutSeasonStatsNestedInput = {
    create?: XOR<seasonsCreateWithoutSeasonStatsInput, seasonsUncheckedCreateWithoutSeasonStatsInput>
    connectOrCreate?: seasonsCreateOrConnectWithoutSeasonStatsInput
    upsert?: seasonsUpsertWithoutSeasonStatsInput
    connect?: seasonsWhereUniqueInput
    update?: XOR<XOR<seasonsUpdateToOneWithWhereWithoutSeasonStatsInput, seasonsUpdateWithoutSeasonStatsInput>, seasonsUncheckedUpdateWithoutSeasonStatsInput>
  }

  export type usersCreateNestedOneWithoutSeasonLeaderboardsInput = {
    create?: XOR<usersCreateWithoutSeasonLeaderboardsInput, usersUncheckedCreateWithoutSeasonLeaderboardsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSeasonLeaderboardsInput
    connect?: usersWhereUniqueInput
  }

  export type seasonsCreateNestedOneWithoutLeaderboardsInput = {
    create?: XOR<seasonsCreateWithoutLeaderboardsInput, seasonsUncheckedCreateWithoutLeaderboardsInput>
    connectOrCreate?: seasonsCreateOrConnectWithoutLeaderboardsInput
    connect?: seasonsWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutSeasonLeaderboardsNestedInput = {
    create?: XOR<usersCreateWithoutSeasonLeaderboardsInput, usersUncheckedCreateWithoutSeasonLeaderboardsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSeasonLeaderboardsInput
    upsert?: usersUpsertWithoutSeasonLeaderboardsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSeasonLeaderboardsInput, usersUpdateWithoutSeasonLeaderboardsInput>, usersUncheckedUpdateWithoutSeasonLeaderboardsInput>
  }

  export type seasonsUpdateOneRequiredWithoutLeaderboardsNestedInput = {
    create?: XOR<seasonsCreateWithoutLeaderboardsInput, seasonsUncheckedCreateWithoutLeaderboardsInput>
    connectOrCreate?: seasonsCreateOrConnectWithoutLeaderboardsInput
    upsert?: seasonsUpsertWithoutLeaderboardsInput
    connect?: seasonsWhereUniqueInput
    update?: XOR<XOR<seasonsUpdateToOneWithWhereWithoutLeaderboardsInput, seasonsUpdateWithoutLeaderboardsInput>, seasonsUncheckedUpdateWithoutLeaderboardsInput>
  }

  export type usersCreateNestedOneWithoutQuotaHistoryInput = {
    create?: XOR<usersCreateWithoutQuotaHistoryInput, usersUncheckedCreateWithoutQuotaHistoryInput>
    connectOrCreate?: usersCreateOrConnectWithoutQuotaHistoryInput
    connect?: usersWhereUniqueInput
  }

  export type seasonsCreateNestedOneWithoutQuotaHistoryInput = {
    create?: XOR<seasonsCreateWithoutQuotaHistoryInput, seasonsUncheckedCreateWithoutQuotaHistoryInput>
    connectOrCreate?: seasonsCreateOrConnectWithoutQuotaHistoryInput
    connect?: seasonsWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutQuotaHistoryNestedInput = {
    create?: XOR<usersCreateWithoutQuotaHistoryInput, usersUncheckedCreateWithoutQuotaHistoryInput>
    connectOrCreate?: usersCreateOrConnectWithoutQuotaHistoryInput
    upsert?: usersUpsertWithoutQuotaHistoryInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutQuotaHistoryInput, usersUpdateWithoutQuotaHistoryInput>, usersUncheckedUpdateWithoutQuotaHistoryInput>
  }

  export type seasonsUpdateOneRequiredWithoutQuotaHistoryNestedInput = {
    create?: XOR<seasonsCreateWithoutQuotaHistoryInput, seasonsUncheckedCreateWithoutQuotaHistoryInput>
    connectOrCreate?: seasonsCreateOrConnectWithoutQuotaHistoryInput
    upsert?: seasonsUpsertWithoutQuotaHistoryInput
    connect?: seasonsWhereUniqueInput
    update?: XOR<XOR<seasonsUpdateToOneWithWhereWithoutQuotaHistoryInput, seasonsUpdateWithoutQuotaHistoryInput>, seasonsUncheckedUpdateWithoutQuotaHistoryInput>
  }

  export type gamesCreateNestedOneWithoutWebsocketConnectionsInput = {
    create?: XOR<gamesCreateWithoutWebsocketConnectionsInput, gamesUncheckedCreateWithoutWebsocketConnectionsInput>
    connectOrCreate?: gamesCreateOrConnectWithoutWebsocketConnectionsInput
    connect?: gamesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutWebsocketConnectionsInput = {
    create?: XOR<usersCreateWithoutWebsocketConnectionsInput, usersUncheckedCreateWithoutWebsocketConnectionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutWebsocketConnectionsInput
    connect?: usersWhereUniqueInput
  }

  export type gamesUpdateOneWithoutWebsocketConnectionsNestedInput = {
    create?: XOR<gamesCreateWithoutWebsocketConnectionsInput, gamesUncheckedCreateWithoutWebsocketConnectionsInput>
    connectOrCreate?: gamesCreateOrConnectWithoutWebsocketConnectionsInput
    upsert?: gamesUpsertWithoutWebsocketConnectionsInput
    disconnect?: gamesWhereInput | boolean
    delete?: gamesWhereInput | boolean
    connect?: gamesWhereUniqueInput
    update?: XOR<XOR<gamesUpdateToOneWithWhereWithoutWebsocketConnectionsInput, gamesUpdateWithoutWebsocketConnectionsInput>, gamesUncheckedUpdateWithoutWebsocketConnectionsInput>
  }

  export type usersUpdateOneRequiredWithoutWebsocketConnectionsNestedInput = {
    create?: XOR<usersCreateWithoutWebsocketConnectionsInput, usersUncheckedCreateWithoutWebsocketConnectionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutWebsocketConnectionsInput
    upsert?: usersUpsertWithoutWebsocketConnectionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutWebsocketConnectionsInput, usersUpdateWithoutWebsocketConnectionsInput>, usersUncheckedUpdateWithoutWebsocketConnectionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumAnalysisTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisTypeFilter<$PrismaModel> | $Enums.AnalysisType
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAnalysisTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisTypeWithAggregatesFilter<$PrismaModel> | $Enums.AnalysisType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnalysisTypeFilter<$PrismaModel>
    _max?: NestedEnumAnalysisTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type NestedEnumPlayerFilter<$PrismaModel = never> = {
    equals?: $Enums.Player | EnumPlayerFieldRefInput<$PrismaModel>
    in?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel>
    notIn?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerFilter<$PrismaModel> | $Enums.Player
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPlayerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Player | EnumPlayerFieldRefInput<$PrismaModel>
    in?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel>
    notIn?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerWithAggregatesFilter<$PrismaModel> | $Enums.Player
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlayerFilter<$PrismaModel>
    _max?: NestedEnumPlayerFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTournamentMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentMatchStatus | EnumTournamentMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentMatchStatus[] | ListEnumTournamentMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentMatchStatus[] | ListEnumTournamentMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentMatchStatusFilter<$PrismaModel> | $Enums.TournamentMatchStatus
  }

  export type NestedEnumTournamentMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentMatchStatus | EnumTournamentMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentMatchStatus[] | ListEnumTournamentMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentMatchStatus[] | ListEnumTournamentMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.TournamentMatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTournamentMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumTournamentMatchStatusFilter<$PrismaModel>
  }

  export type NestedEnumTournamentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusFilter<$PrismaModel> | $Enums.TournamentStatus
  }

  export type NestedEnumTournamentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusWithAggregatesFilter<$PrismaModel> | $Enums.TournamentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTournamentStatusFilter<$PrismaModel>
    _max?: NestedEnumTournamentStatusFilter<$PrismaModel>
  }

  export type NestedEnumGameModeFilter<$PrismaModel = never> = {
    equals?: $Enums.GameMode | EnumGameModeFieldRefInput<$PrismaModel>
    in?: $Enums.GameMode[] | ListEnumGameModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameMode[] | ListEnumGameModeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameModeFilter<$PrismaModel> | $Enums.GameMode
  }

  export type NestedEnumGameStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusFilter<$PrismaModel> | $Enums.GameStatus
  }

  export type NestedEnumPlayerNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Player | EnumPlayerFieldRefInput<$PrismaModel> | null
    in?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlayerNullableFilter<$PrismaModel> | $Enums.Player | null
  }

  export type NestedEnumTimeControlPresetNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeControlPreset | EnumTimeControlPresetFieldRefInput<$PrismaModel> | null
    in?: $Enums.TimeControlPreset[] | ListEnumTimeControlPresetFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TimeControlPreset[] | ListEnumTimeControlPresetFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTimeControlPresetNullableFilter<$PrismaModel> | $Enums.TimeControlPreset | null
  }

  export type NestedEnumResignationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ResignationType | EnumResignationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResignationType[] | ListEnumResignationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResignationType[] | ListEnumResignationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResignationTypeNullableFilter<$PrismaModel> | $Enums.ResignationType | null
  }

  export type NestedEnumGameModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameMode | EnumGameModeFieldRefInput<$PrismaModel>
    in?: $Enums.GameMode[] | ListEnumGameModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameMode[] | ListEnumGameModeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameModeWithAggregatesFilter<$PrismaModel> | $Enums.GameMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameModeFilter<$PrismaModel>
    _max?: NestedEnumGameModeFilter<$PrismaModel>
  }

  export type NestedEnumGameStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusWithAggregatesFilter<$PrismaModel> | $Enums.GameStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameStatusFilter<$PrismaModel>
    _max?: NestedEnumGameStatusFilter<$PrismaModel>
  }

  export type NestedEnumPlayerNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Player | EnumPlayerFieldRefInput<$PrismaModel> | null
    in?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlayerNullableWithAggregatesFilter<$PrismaModel> | $Enums.Player | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlayerNullableFilter<$PrismaModel>
    _max?: NestedEnumPlayerNullableFilter<$PrismaModel>
  }

  export type NestedEnumTimeControlPresetNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeControlPreset | EnumTimeControlPresetFieldRefInput<$PrismaModel> | null
    in?: $Enums.TimeControlPreset[] | ListEnumTimeControlPresetFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TimeControlPreset[] | ListEnumTimeControlPresetFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTimeControlPresetNullableWithAggregatesFilter<$PrismaModel> | $Enums.TimeControlPreset | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTimeControlPresetNullableFilter<$PrismaModel>
    _max?: NestedEnumTimeControlPresetNullableFilter<$PrismaModel>
  }

  export type NestedEnumResignationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResignationType | EnumResignationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResignationType[] | ListEnumResignationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResignationType[] | ListEnumResignationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResignationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ResignationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumResignationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumResignationTypeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMatchStateFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchState | EnumMatchStateFieldRefInput<$PrismaModel>
    in?: $Enums.MatchState[] | ListEnumMatchStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchState[] | ListEnumMatchStateFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStateFilter<$PrismaModel> | $Enums.MatchState
  }

  export type NestedEnumMatchStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchState | EnumMatchStateFieldRefInput<$PrismaModel>
    in?: $Enums.MatchState[] | ListEnumMatchStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchState[] | ListEnumMatchStateFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStateWithAggregatesFilter<$PrismaModel> | $Enums.MatchState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStateFilter<$PrismaModel>
    _max?: NestedEnumMatchStateFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeFilter<$PrismaModel> | $Enums.SubscriptionType
  }

  export type NestedEnumSubscriptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
  }

  export type usersCreateWithoutAnalysesInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analysisQuotas?: AnalysisQuotaCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesCreateNestedManyWithoutUserInput
    gameMoves?: game_movesCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutUserInput
    whiteGames?: gamesCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutAnalysesInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analysisQuotas?: AnalysisQuotaUncheckedCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutUserInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesUncheckedCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutUserInput
    whiteGames?: gamesUncheckedCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesUncheckedCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutAnalysesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAnalysesInput, usersUncheckedCreateWithoutAnalysesInput>
  }

  export type usersUpsertWithoutAnalysesInput = {
    update: XOR<usersUpdateWithoutAnalysesInput, usersUncheckedUpdateWithoutAnalysesInput>
    create: XOR<usersCreateWithoutAnalysesInput, usersUncheckedCreateWithoutAnalysesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAnalysesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAnalysesInput, usersUncheckedUpdateWithoutAnalysesInput>
  }

  export type usersUpdateWithoutAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analysisQuotas?: AnalysisQuotaUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analysisQuotas?: AnalysisQuotaUncheckedUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUncheckedUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUncheckedUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUncheckedUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUncheckedUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutAnalysisQuotasInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesCreateNestedManyWithoutUserInput
    gameMoves?: game_movesCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutUserInput
    whiteGames?: gamesCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutAnalysisQuotasInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutUserInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesUncheckedCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutUserInput
    whiteGames?: gamesUncheckedCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesUncheckedCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutAnalysisQuotasInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAnalysisQuotasInput, usersUncheckedCreateWithoutAnalysisQuotasInput>
  }

  export type usersUpsertWithoutAnalysisQuotasInput = {
    update: XOR<usersUpdateWithoutAnalysisQuotasInput, usersUncheckedUpdateWithoutAnalysisQuotasInput>
    create: XOR<usersCreateWithoutAnalysisQuotasInput, usersUncheckedCreateWithoutAnalysisQuotasInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAnalysisQuotasInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAnalysisQuotasInput, usersUncheckedUpdateWithoutAnalysisQuotasInput>
  }

  export type usersUpdateWithoutAnalysisQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutAnalysisQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUncheckedUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUncheckedUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUncheckedUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUncheckedUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutIaQuotaInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesCreateNestedManyWithoutUserInput
    gameMoves?: game_movesCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutUserInput
    whiteGames?: gamesCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutIaQuotaInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutUserInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesUncheckedCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutUserInput
    whiteGames?: gamesUncheckedCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesUncheckedCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutIaQuotaInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutIaQuotaInput, usersUncheckedCreateWithoutIaQuotaInput>
  }

  export type usersUpsertWithoutIaQuotaInput = {
    update: XOR<usersUpdateWithoutIaQuotaInput, usersUncheckedUpdateWithoutIaQuotaInput>
    create: XOR<usersCreateWithoutIaQuotaInput, usersUncheckedCreateWithoutIaQuotaInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutIaQuotaInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutIaQuotaInput, usersUncheckedUpdateWithoutIaQuotaInput>
  }

  export type usersUpdateWithoutIaQuotaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutIaQuotaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUncheckedUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUncheckedUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUncheckedUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUncheckedUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutSessionsInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaCreateNestedOneWithoutUserInput
    chatMessages?: chat_messagesCreateNestedManyWithoutUserInput
    gameMoves?: game_movesCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutUserInput
    whiteGames?: gamesCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutSessionsInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaUncheckedCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaUncheckedCreateNestedOneWithoutUserInput
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutUserInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesUncheckedCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutUserInput
    whiteGames?: gamesUncheckedCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesUncheckedCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutSessionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
  }

  export type usersUpsertWithoutSessionsInput = {
    update: XOR<usersUpdateWithoutSessionsInput, usersUncheckedUpdateWithoutSessionsInput>
    create: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSessionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSessionsInput, usersUncheckedUpdateWithoutSessionsInput>
  }

  export type usersUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUpdateOneWithoutUserNestedInput
    chatMessages?: chat_messagesUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUncheckedUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUncheckedUpdateOneWithoutUserNestedInput
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUncheckedUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUncheckedUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUncheckedUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUncheckedUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type gamesCreateWithoutChatMessagesInput = {
    id: string
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    gameMoves?: game_movesCreateNestedManyWithoutGameInput
    tournament?: tournamentsCreateNestedOneWithoutGamesInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutGameInput
    whitePlayer: usersCreateNestedOneWithoutWhiteGamesInput
    blackPlayer?: usersCreateNestedOneWithoutBlackGamesInput
    match?: matchesCreateNestedOneWithoutGameInput
    tournamentMatch?: tournament_matchesCreateNestedOneWithoutGameInput
    sessions?: GameSessionCreateNestedManyWithoutGameInput
    events?: GameEventCreateNestedManyWithoutGameInput
  }

  export type gamesUncheckedCreateWithoutChatMessagesInput = {
    id: string
    whitePlayerId: string
    blackPlayerId?: string | null
    tournamentId?: string | null
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutGameInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutGameInput
    match?: matchesUncheckedCreateNestedOneWithoutGameInput
    tournamentMatch?: tournament_matchesUncheckedCreateNestedOneWithoutGameInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    events?: GameEventUncheckedCreateNestedManyWithoutGameInput
  }

  export type gamesCreateOrConnectWithoutChatMessagesInput = {
    where: gamesWhereUniqueInput
    create: XOR<gamesCreateWithoutChatMessagesInput, gamesUncheckedCreateWithoutChatMessagesInput>
  }

  export type usersCreateWithoutChatMessagesInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    gameMoves?: game_movesCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutUserInput
    whiteGames?: gamesCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutChatMessagesInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaUncheckedCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesUncheckedCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutUserInput
    whiteGames?: gamesUncheckedCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesUncheckedCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutChatMessagesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutChatMessagesInput, usersUncheckedCreateWithoutChatMessagesInput>
  }

  export type gamesUpsertWithoutChatMessagesInput = {
    update: XOR<gamesUpdateWithoutChatMessagesInput, gamesUncheckedUpdateWithoutChatMessagesInput>
    create: XOR<gamesCreateWithoutChatMessagesInput, gamesUncheckedCreateWithoutChatMessagesInput>
    where?: gamesWhereInput
  }

  export type gamesUpdateToOneWithWhereWithoutChatMessagesInput = {
    where?: gamesWhereInput
    data: XOR<gamesUpdateWithoutChatMessagesInput, gamesUncheckedUpdateWithoutChatMessagesInput>
  }

  export type gamesUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    gameMoves?: game_movesUpdateManyWithoutGameNestedInput
    tournament?: tournamentsUpdateOneWithoutGamesNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutGameNestedInput
    whitePlayer?: usersUpdateOneRequiredWithoutWhiteGamesNestedInput
    blackPlayer?: usersUpdateOneWithoutBlackGamesNestedInput
    match?: matchesUpdateOneWithoutGameNestedInput
    tournamentMatch?: tournament_matchesUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUpdateManyWithoutGameNestedInput
    events?: GameEventUpdateManyWithoutGameNestedInput
  }

  export type gamesUncheckedUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    whitePlayerId?: StringFieldUpdateOperationsInput | string
    blackPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    gameMoves?: game_movesUncheckedUpdateManyWithoutGameNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutGameNestedInput
    match?: matchesUncheckedUpdateOneWithoutGameNestedInput
    tournamentMatch?: tournament_matchesUncheckedUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    events?: GameEventUncheckedUpdateManyWithoutGameNestedInput
  }

  export type usersUpsertWithoutChatMessagesInput = {
    update: XOR<usersUpdateWithoutChatMessagesInput, usersUncheckedUpdateWithoutChatMessagesInput>
    create: XOR<usersCreateWithoutChatMessagesInput, usersUncheckedCreateWithoutChatMessagesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutChatMessagesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutChatMessagesInput, usersUncheckedUpdateWithoutChatMessagesInput>
  }

  export type usersUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUncheckedUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUncheckedUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUncheckedUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUncheckedUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUncheckedUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type gamesCreateWithoutGameMovesInput = {
    id: string
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesCreateNestedManyWithoutGameInput
    tournament?: tournamentsCreateNestedOneWithoutGamesInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutGameInput
    whitePlayer: usersCreateNestedOneWithoutWhiteGamesInput
    blackPlayer?: usersCreateNestedOneWithoutBlackGamesInput
    match?: matchesCreateNestedOneWithoutGameInput
    tournamentMatch?: tournament_matchesCreateNestedOneWithoutGameInput
    sessions?: GameSessionCreateNestedManyWithoutGameInput
    events?: GameEventCreateNestedManyWithoutGameInput
  }

  export type gamesUncheckedCreateWithoutGameMovesInput = {
    id: string
    whitePlayerId: string
    blackPlayerId?: string | null
    tournamentId?: string | null
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutGameInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutGameInput
    match?: matchesUncheckedCreateNestedOneWithoutGameInput
    tournamentMatch?: tournament_matchesUncheckedCreateNestedOneWithoutGameInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    events?: GameEventUncheckedCreateNestedManyWithoutGameInput
  }

  export type gamesCreateOrConnectWithoutGameMovesInput = {
    where: gamesWhereUniqueInput
    create: XOR<gamesCreateWithoutGameMovesInput, gamesUncheckedCreateWithoutGameMovesInput>
  }

  export type usersCreateWithoutGameMovesInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutUserInput
    whiteGames?: gamesCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutGameMovesInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaUncheckedCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesUncheckedCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutUserInput
    whiteGames?: gamesUncheckedCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesUncheckedCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutGameMovesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutGameMovesInput, usersUncheckedCreateWithoutGameMovesInput>
  }

  export type gamesUpsertWithoutGameMovesInput = {
    update: XOR<gamesUpdateWithoutGameMovesInput, gamesUncheckedUpdateWithoutGameMovesInput>
    create: XOR<gamesCreateWithoutGameMovesInput, gamesUncheckedCreateWithoutGameMovesInput>
    where?: gamesWhereInput
  }

  export type gamesUpdateToOneWithWhereWithoutGameMovesInput = {
    where?: gamesWhereInput
    data: XOR<gamesUpdateWithoutGameMovesInput, gamesUncheckedUpdateWithoutGameMovesInput>
  }

  export type gamesUpdateWithoutGameMovesInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUpdateManyWithoutGameNestedInput
    tournament?: tournamentsUpdateOneWithoutGamesNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutGameNestedInput
    whitePlayer?: usersUpdateOneRequiredWithoutWhiteGamesNestedInput
    blackPlayer?: usersUpdateOneWithoutBlackGamesNestedInput
    match?: matchesUpdateOneWithoutGameNestedInput
    tournamentMatch?: tournament_matchesUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUpdateManyWithoutGameNestedInput
    events?: GameEventUpdateManyWithoutGameNestedInput
  }

  export type gamesUncheckedUpdateWithoutGameMovesInput = {
    id?: StringFieldUpdateOperationsInput | string
    whitePlayerId?: StringFieldUpdateOperationsInput | string
    blackPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutGameNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutGameNestedInput
    match?: matchesUncheckedUpdateOneWithoutGameNestedInput
    tournamentMatch?: tournament_matchesUncheckedUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    events?: GameEventUncheckedUpdateManyWithoutGameNestedInput
  }

  export type usersUpsertWithoutGameMovesInput = {
    update: XOR<usersUpdateWithoutGameMovesInput, usersUncheckedUpdateWithoutGameMovesInput>
    create: XOR<usersCreateWithoutGameMovesInput, usersUncheckedCreateWithoutGameMovesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutGameMovesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutGameMovesInput, usersUncheckedUpdateWithoutGameMovesInput>
  }

  export type usersUpdateWithoutGameMovesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutGameMovesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUncheckedUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUncheckedUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUncheckedUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUncheckedUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUncheckedUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutSubscriptionInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesCreateNestedManyWithoutUserInput
    gameMoves?: game_movesCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesCreateNestedManyWithoutUsersInput
    tournamentParticipants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutUserInput
    whiteGames?: gamesCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutSubscriptionInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaUncheckedCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutUserInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesUncheckedCreateNestedManyWithoutUsersInput
    tournamentParticipants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutUserInput
    whiteGames?: gamesUncheckedCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesUncheckedCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutSubscriptionInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSubscriptionInput, usersUncheckedCreateWithoutSubscriptionInput>
  }

  export type usersUpsertWithoutSubscriptionInput = {
    update: XOR<usersUpdateWithoutSubscriptionInput, usersUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<usersCreateWithoutSubscriptionInput, usersUncheckedCreateWithoutSubscriptionInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSubscriptionInput, usersUncheckedUpdateWithoutSubscriptionInput>
  }

  export type usersUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUpdateManyWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUncheckedUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUncheckedUpdateManyWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUncheckedUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUncheckedUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUncheckedUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type tournamentsCreateWithoutParticipantsInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    games?: gamesCreateNestedManyWithoutTournamentInput
    matches?: tournament_matchesCreateNestedManyWithoutTournamentInput
    creator: usersCreateNestedOneWithoutTournamentsInput
  }

  export type tournamentsUncheckedCreateWithoutParticipantsInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    games?: gamesUncheckedCreateNestedManyWithoutTournamentInput
    matches?: tournament_matchesUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type tournamentsCreateOrConnectWithoutParticipantsInput = {
    where: tournamentsWhereUniqueInput
    create: XOR<tournamentsCreateWithoutParticipantsInput, tournamentsUncheckedCreateWithoutParticipantsInput>
  }

  export type usersCreateWithoutTournamentParticipantsInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesCreateNestedManyWithoutUserInput
    gameMoves?: game_movesCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsCreateNestedOneWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutUserInput
    whiteGames?: gamesCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutTournamentParticipantsInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaUncheckedCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutUserInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesUncheckedCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutUserInput
    whiteGames?: gamesUncheckedCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesUncheckedCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutTournamentParticipantsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTournamentParticipantsInput, usersUncheckedCreateWithoutTournamentParticipantsInput>
  }

  export type tournament_matchesCreateWithoutWhiteInput = {
    id?: string
    round: number
    matchNumber: number
    status?: $Enums.TournamentMatchStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournament: tournamentsCreateNestedOneWithoutMatchesInput
    black?: tournament_participantsCreateNestedOneWithoutBlackMatchesInput
    winner?: tournament_participantsCreateNestedOneWithoutWonMatchesInput
    game?: gamesCreateNestedOneWithoutTournamentMatchInput
  }

  export type tournament_matchesUncheckedCreateWithoutWhiteInput = {
    id?: string
    tournamentId: string
    round: number
    matchNumber: number
    blackParticipantId?: string | null
    winnerParticipantId?: string | null
    status?: $Enums.TournamentMatchStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    gameId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tournament_matchesCreateOrConnectWithoutWhiteInput = {
    where: tournament_matchesWhereUniqueInput
    create: XOR<tournament_matchesCreateWithoutWhiteInput, tournament_matchesUncheckedCreateWithoutWhiteInput>
  }

  export type tournament_matchesCreateManyWhiteInputEnvelope = {
    data: tournament_matchesCreateManyWhiteInput | tournament_matchesCreateManyWhiteInput[]
    skipDuplicates?: boolean
  }

  export type tournament_matchesCreateWithoutBlackInput = {
    id?: string
    round: number
    matchNumber: number
    status?: $Enums.TournamentMatchStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournament: tournamentsCreateNestedOneWithoutMatchesInput
    white?: tournament_participantsCreateNestedOneWithoutWhiteMatchesInput
    winner?: tournament_participantsCreateNestedOneWithoutWonMatchesInput
    game?: gamesCreateNestedOneWithoutTournamentMatchInput
  }

  export type tournament_matchesUncheckedCreateWithoutBlackInput = {
    id?: string
    tournamentId: string
    round: number
    matchNumber: number
    whiteParticipantId?: string | null
    winnerParticipantId?: string | null
    status?: $Enums.TournamentMatchStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    gameId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tournament_matchesCreateOrConnectWithoutBlackInput = {
    where: tournament_matchesWhereUniqueInput
    create: XOR<tournament_matchesCreateWithoutBlackInput, tournament_matchesUncheckedCreateWithoutBlackInput>
  }

  export type tournament_matchesCreateManyBlackInputEnvelope = {
    data: tournament_matchesCreateManyBlackInput | tournament_matchesCreateManyBlackInput[]
    skipDuplicates?: boolean
  }

  export type tournament_matchesCreateWithoutWinnerInput = {
    id?: string
    round: number
    matchNumber: number
    status?: $Enums.TournamentMatchStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournament: tournamentsCreateNestedOneWithoutMatchesInput
    white?: tournament_participantsCreateNestedOneWithoutWhiteMatchesInput
    black?: tournament_participantsCreateNestedOneWithoutBlackMatchesInput
    game?: gamesCreateNestedOneWithoutTournamentMatchInput
  }

  export type tournament_matchesUncheckedCreateWithoutWinnerInput = {
    id?: string
    tournamentId: string
    round: number
    matchNumber: number
    whiteParticipantId?: string | null
    blackParticipantId?: string | null
    status?: $Enums.TournamentMatchStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    gameId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tournament_matchesCreateOrConnectWithoutWinnerInput = {
    where: tournament_matchesWhereUniqueInput
    create: XOR<tournament_matchesCreateWithoutWinnerInput, tournament_matchesUncheckedCreateWithoutWinnerInput>
  }

  export type tournament_matchesCreateManyWinnerInputEnvelope = {
    data: tournament_matchesCreateManyWinnerInput | tournament_matchesCreateManyWinnerInput[]
    skipDuplicates?: boolean
  }

  export type tournamentsUpsertWithoutParticipantsInput = {
    update: XOR<tournamentsUpdateWithoutParticipantsInput, tournamentsUncheckedUpdateWithoutParticipantsInput>
    create: XOR<tournamentsCreateWithoutParticipantsInput, tournamentsUncheckedCreateWithoutParticipantsInput>
    where?: tournamentsWhereInput
  }

  export type tournamentsUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: tournamentsWhereInput
    data: XOR<tournamentsUpdateWithoutParticipantsInput, tournamentsUncheckedUpdateWithoutParticipantsInput>
  }

  export type tournamentsUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: gamesUpdateManyWithoutTournamentNestedInput
    matches?: tournament_matchesUpdateManyWithoutTournamentNestedInput
    creator?: usersUpdateOneRequiredWithoutTournamentsNestedInput
  }

  export type tournamentsUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: gamesUncheckedUpdateManyWithoutTournamentNestedInput
    matches?: tournament_matchesUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type usersUpsertWithoutTournamentParticipantsInput = {
    update: XOR<usersUpdateWithoutTournamentParticipantsInput, usersUncheckedUpdateWithoutTournamentParticipantsInput>
    create: XOR<usersCreateWithoutTournamentParticipantsInput, usersUncheckedCreateWithoutTournamentParticipantsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTournamentParticipantsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTournamentParticipantsInput, usersUncheckedUpdateWithoutTournamentParticipantsInput>
  }

  export type usersUpdateWithoutTournamentParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutTournamentParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUncheckedUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUncheckedUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUncheckedUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUncheckedUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUncheckedUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type tournament_matchesUpsertWithWhereUniqueWithoutWhiteInput = {
    where: tournament_matchesWhereUniqueInput
    update: XOR<tournament_matchesUpdateWithoutWhiteInput, tournament_matchesUncheckedUpdateWithoutWhiteInput>
    create: XOR<tournament_matchesCreateWithoutWhiteInput, tournament_matchesUncheckedCreateWithoutWhiteInput>
  }

  export type tournament_matchesUpdateWithWhereUniqueWithoutWhiteInput = {
    where: tournament_matchesWhereUniqueInput
    data: XOR<tournament_matchesUpdateWithoutWhiteInput, tournament_matchesUncheckedUpdateWithoutWhiteInput>
  }

  export type tournament_matchesUpdateManyWithWhereWithoutWhiteInput = {
    where: tournament_matchesScalarWhereInput
    data: XOR<tournament_matchesUpdateManyMutationInput, tournament_matchesUncheckedUpdateManyWithoutWhiteInput>
  }

  export type tournament_matchesScalarWhereInput = {
    AND?: tournament_matchesScalarWhereInput | tournament_matchesScalarWhereInput[]
    OR?: tournament_matchesScalarWhereInput[]
    NOT?: tournament_matchesScalarWhereInput | tournament_matchesScalarWhereInput[]
    id?: StringFilter<"tournament_matches"> | string
    tournamentId?: StringFilter<"tournament_matches"> | string
    round?: IntFilter<"tournament_matches"> | number
    matchNumber?: IntFilter<"tournament_matches"> | number
    whiteParticipantId?: StringNullableFilter<"tournament_matches"> | string | null
    blackParticipantId?: StringNullableFilter<"tournament_matches"> | string | null
    winnerParticipantId?: StringNullableFilter<"tournament_matches"> | string | null
    status?: EnumTournamentMatchStatusFilter<"tournament_matches"> | $Enums.TournamentMatchStatus
    scheduledAt?: DateTimeNullableFilter<"tournament_matches"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"tournament_matches"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"tournament_matches"> | Date | string | null
    gameId?: StringNullableFilter<"tournament_matches"> | string | null
    createdAt?: DateTimeFilter<"tournament_matches"> | Date | string
    updatedAt?: DateTimeFilter<"tournament_matches"> | Date | string
  }

  export type tournament_matchesUpsertWithWhereUniqueWithoutBlackInput = {
    where: tournament_matchesWhereUniqueInput
    update: XOR<tournament_matchesUpdateWithoutBlackInput, tournament_matchesUncheckedUpdateWithoutBlackInput>
    create: XOR<tournament_matchesCreateWithoutBlackInput, tournament_matchesUncheckedCreateWithoutBlackInput>
  }

  export type tournament_matchesUpdateWithWhereUniqueWithoutBlackInput = {
    where: tournament_matchesWhereUniqueInput
    data: XOR<tournament_matchesUpdateWithoutBlackInput, tournament_matchesUncheckedUpdateWithoutBlackInput>
  }

  export type tournament_matchesUpdateManyWithWhereWithoutBlackInput = {
    where: tournament_matchesScalarWhereInput
    data: XOR<tournament_matchesUpdateManyMutationInput, tournament_matchesUncheckedUpdateManyWithoutBlackInput>
  }

  export type tournament_matchesUpsertWithWhereUniqueWithoutWinnerInput = {
    where: tournament_matchesWhereUniqueInput
    update: XOR<tournament_matchesUpdateWithoutWinnerInput, tournament_matchesUncheckedUpdateWithoutWinnerInput>
    create: XOR<tournament_matchesCreateWithoutWinnerInput, tournament_matchesUncheckedCreateWithoutWinnerInput>
  }

  export type tournament_matchesUpdateWithWhereUniqueWithoutWinnerInput = {
    where: tournament_matchesWhereUniqueInput
    data: XOR<tournament_matchesUpdateWithoutWinnerInput, tournament_matchesUncheckedUpdateWithoutWinnerInput>
  }

  export type tournament_matchesUpdateManyWithWhereWithoutWinnerInput = {
    where: tournament_matchesScalarWhereInput
    data: XOR<tournament_matchesUpdateManyMutationInput, tournament_matchesUncheckedUpdateManyWithoutWinnerInput>
  }

  export type tournamentsCreateWithoutMatchesInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    games?: gamesCreateNestedManyWithoutTournamentInput
    participants?: tournament_participantsCreateNestedManyWithoutTournamentsInput
    creator: usersCreateNestedOneWithoutTournamentsInput
  }

  export type tournamentsUncheckedCreateWithoutMatchesInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    games?: gamesUncheckedCreateNestedManyWithoutTournamentInput
    participants?: tournament_participantsUncheckedCreateNestedManyWithoutTournamentsInput
  }

  export type tournamentsCreateOrConnectWithoutMatchesInput = {
    where: tournamentsWhereUniqueInput
    create: XOR<tournamentsCreateWithoutMatchesInput, tournamentsUncheckedCreateWithoutMatchesInput>
  }

  export type tournament_participantsCreateWithoutWhiteMatchesInput = {
    id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
    tournaments: tournamentsCreateNestedOneWithoutParticipantsInput
    users: usersCreateNestedOneWithoutTournamentParticipantsInput
    blackMatches?: tournament_matchesCreateNestedManyWithoutBlackInput
    wonMatches?: tournament_matchesCreateNestedManyWithoutWinnerInput
  }

  export type tournament_participantsUncheckedCreateWithoutWhiteMatchesInput = {
    id: string
    tournament_id: string
    user_id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
    blackMatches?: tournament_matchesUncheckedCreateNestedManyWithoutBlackInput
    wonMatches?: tournament_matchesUncheckedCreateNestedManyWithoutWinnerInput
  }

  export type tournament_participantsCreateOrConnectWithoutWhiteMatchesInput = {
    where: tournament_participantsWhereUniqueInput
    create: XOR<tournament_participantsCreateWithoutWhiteMatchesInput, tournament_participantsUncheckedCreateWithoutWhiteMatchesInput>
  }

  export type tournament_participantsCreateWithoutBlackMatchesInput = {
    id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
    tournaments: tournamentsCreateNestedOneWithoutParticipantsInput
    users: usersCreateNestedOneWithoutTournamentParticipantsInput
    whiteMatches?: tournament_matchesCreateNestedManyWithoutWhiteInput
    wonMatches?: tournament_matchesCreateNestedManyWithoutWinnerInput
  }

  export type tournament_participantsUncheckedCreateWithoutBlackMatchesInput = {
    id: string
    tournament_id: string
    user_id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
    whiteMatches?: tournament_matchesUncheckedCreateNestedManyWithoutWhiteInput
    wonMatches?: tournament_matchesUncheckedCreateNestedManyWithoutWinnerInput
  }

  export type tournament_participantsCreateOrConnectWithoutBlackMatchesInput = {
    where: tournament_participantsWhereUniqueInput
    create: XOR<tournament_participantsCreateWithoutBlackMatchesInput, tournament_participantsUncheckedCreateWithoutBlackMatchesInput>
  }

  export type tournament_participantsCreateWithoutWonMatchesInput = {
    id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
    tournaments: tournamentsCreateNestedOneWithoutParticipantsInput
    users: usersCreateNestedOneWithoutTournamentParticipantsInput
    whiteMatches?: tournament_matchesCreateNestedManyWithoutWhiteInput
    blackMatches?: tournament_matchesCreateNestedManyWithoutBlackInput
  }

  export type tournament_participantsUncheckedCreateWithoutWonMatchesInput = {
    id: string
    tournament_id: string
    user_id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
    whiteMatches?: tournament_matchesUncheckedCreateNestedManyWithoutWhiteInput
    blackMatches?: tournament_matchesUncheckedCreateNestedManyWithoutBlackInput
  }

  export type tournament_participantsCreateOrConnectWithoutWonMatchesInput = {
    where: tournament_participantsWhereUniqueInput
    create: XOR<tournament_participantsCreateWithoutWonMatchesInput, tournament_participantsUncheckedCreateWithoutWonMatchesInput>
  }

  export type gamesCreateWithoutTournamentMatchInput = {
    id: string
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesCreateNestedManyWithoutGameInput
    gameMoves?: game_movesCreateNestedManyWithoutGameInput
    tournament?: tournamentsCreateNestedOneWithoutGamesInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutGameInput
    whitePlayer: usersCreateNestedOneWithoutWhiteGamesInput
    blackPlayer?: usersCreateNestedOneWithoutBlackGamesInput
    match?: matchesCreateNestedOneWithoutGameInput
    sessions?: GameSessionCreateNestedManyWithoutGameInput
    events?: GameEventCreateNestedManyWithoutGameInput
  }

  export type gamesUncheckedCreateWithoutTournamentMatchInput = {
    id: string
    whitePlayerId: string
    blackPlayerId?: string | null
    tournamentId?: string | null
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutGameInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutGameInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutGameInput
    match?: matchesUncheckedCreateNestedOneWithoutGameInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    events?: GameEventUncheckedCreateNestedManyWithoutGameInput
  }

  export type gamesCreateOrConnectWithoutTournamentMatchInput = {
    where: gamesWhereUniqueInput
    create: XOR<gamesCreateWithoutTournamentMatchInput, gamesUncheckedCreateWithoutTournamentMatchInput>
  }

  export type tournamentsUpsertWithoutMatchesInput = {
    update: XOR<tournamentsUpdateWithoutMatchesInput, tournamentsUncheckedUpdateWithoutMatchesInput>
    create: XOR<tournamentsCreateWithoutMatchesInput, tournamentsUncheckedCreateWithoutMatchesInput>
    where?: tournamentsWhereInput
  }

  export type tournamentsUpdateToOneWithWhereWithoutMatchesInput = {
    where?: tournamentsWhereInput
    data: XOR<tournamentsUpdateWithoutMatchesInput, tournamentsUncheckedUpdateWithoutMatchesInput>
  }

  export type tournamentsUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: gamesUpdateManyWithoutTournamentNestedInput
    participants?: tournament_participantsUpdateManyWithoutTournamentsNestedInput
    creator?: usersUpdateOneRequiredWithoutTournamentsNestedInput
  }

  export type tournamentsUncheckedUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: gamesUncheckedUpdateManyWithoutTournamentNestedInput
    participants?: tournament_participantsUncheckedUpdateManyWithoutTournamentsNestedInput
  }

  export type tournament_participantsUpsertWithoutWhiteMatchesInput = {
    update: XOR<tournament_participantsUpdateWithoutWhiteMatchesInput, tournament_participantsUncheckedUpdateWithoutWhiteMatchesInput>
    create: XOR<tournament_participantsCreateWithoutWhiteMatchesInput, tournament_participantsUncheckedCreateWithoutWhiteMatchesInput>
    where?: tournament_participantsWhereInput
  }

  export type tournament_participantsUpdateToOneWithWhereWithoutWhiteMatchesInput = {
    where?: tournament_participantsWhereInput
    data: XOR<tournament_participantsUpdateWithoutWhiteMatchesInput, tournament_participantsUncheckedUpdateWithoutWhiteMatchesInput>
  }

  export type tournament_participantsUpdateWithoutWhiteMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tournaments?: tournamentsUpdateOneRequiredWithoutParticipantsNestedInput
    users?: usersUpdateOneRequiredWithoutTournamentParticipantsNestedInput
    blackMatches?: tournament_matchesUpdateManyWithoutBlackNestedInput
    wonMatches?: tournament_matchesUpdateManyWithoutWinnerNestedInput
  }

  export type tournament_participantsUncheckedUpdateWithoutWhiteMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournament_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blackMatches?: tournament_matchesUncheckedUpdateManyWithoutBlackNestedInput
    wonMatches?: tournament_matchesUncheckedUpdateManyWithoutWinnerNestedInput
  }

  export type tournament_participantsUpsertWithoutBlackMatchesInput = {
    update: XOR<tournament_participantsUpdateWithoutBlackMatchesInput, tournament_participantsUncheckedUpdateWithoutBlackMatchesInput>
    create: XOR<tournament_participantsCreateWithoutBlackMatchesInput, tournament_participantsUncheckedCreateWithoutBlackMatchesInput>
    where?: tournament_participantsWhereInput
  }

  export type tournament_participantsUpdateToOneWithWhereWithoutBlackMatchesInput = {
    where?: tournament_participantsWhereInput
    data: XOR<tournament_participantsUpdateWithoutBlackMatchesInput, tournament_participantsUncheckedUpdateWithoutBlackMatchesInput>
  }

  export type tournament_participantsUpdateWithoutBlackMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tournaments?: tournamentsUpdateOneRequiredWithoutParticipantsNestedInput
    users?: usersUpdateOneRequiredWithoutTournamentParticipantsNestedInput
    whiteMatches?: tournament_matchesUpdateManyWithoutWhiteNestedInput
    wonMatches?: tournament_matchesUpdateManyWithoutWinnerNestedInput
  }

  export type tournament_participantsUncheckedUpdateWithoutBlackMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournament_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whiteMatches?: tournament_matchesUncheckedUpdateManyWithoutWhiteNestedInput
    wonMatches?: tournament_matchesUncheckedUpdateManyWithoutWinnerNestedInput
  }

  export type tournament_participantsUpsertWithoutWonMatchesInput = {
    update: XOR<tournament_participantsUpdateWithoutWonMatchesInput, tournament_participantsUncheckedUpdateWithoutWonMatchesInput>
    create: XOR<tournament_participantsCreateWithoutWonMatchesInput, tournament_participantsUncheckedCreateWithoutWonMatchesInput>
    where?: tournament_participantsWhereInput
  }

  export type tournament_participantsUpdateToOneWithWhereWithoutWonMatchesInput = {
    where?: tournament_participantsWhereInput
    data: XOR<tournament_participantsUpdateWithoutWonMatchesInput, tournament_participantsUncheckedUpdateWithoutWonMatchesInput>
  }

  export type tournament_participantsUpdateWithoutWonMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tournaments?: tournamentsUpdateOneRequiredWithoutParticipantsNestedInput
    users?: usersUpdateOneRequiredWithoutTournamentParticipantsNestedInput
    whiteMatches?: tournament_matchesUpdateManyWithoutWhiteNestedInput
    blackMatches?: tournament_matchesUpdateManyWithoutBlackNestedInput
  }

  export type tournament_participantsUncheckedUpdateWithoutWonMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournament_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whiteMatches?: tournament_matchesUncheckedUpdateManyWithoutWhiteNestedInput
    blackMatches?: tournament_matchesUncheckedUpdateManyWithoutBlackNestedInput
  }

  export type gamesUpsertWithoutTournamentMatchInput = {
    update: XOR<gamesUpdateWithoutTournamentMatchInput, gamesUncheckedUpdateWithoutTournamentMatchInput>
    create: XOR<gamesCreateWithoutTournamentMatchInput, gamesUncheckedCreateWithoutTournamentMatchInput>
    where?: gamesWhereInput
  }

  export type gamesUpdateToOneWithWhereWithoutTournamentMatchInput = {
    where?: gamesWhereInput
    data: XOR<gamesUpdateWithoutTournamentMatchInput, gamesUncheckedUpdateWithoutTournamentMatchInput>
  }

  export type gamesUpdateWithoutTournamentMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUpdateManyWithoutGameNestedInput
    gameMoves?: game_movesUpdateManyWithoutGameNestedInput
    tournament?: tournamentsUpdateOneWithoutGamesNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutGameNestedInput
    whitePlayer?: usersUpdateOneRequiredWithoutWhiteGamesNestedInput
    blackPlayer?: usersUpdateOneWithoutBlackGamesNestedInput
    match?: matchesUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUpdateManyWithoutGameNestedInput
    events?: GameEventUpdateManyWithoutGameNestedInput
  }

  export type gamesUncheckedUpdateWithoutTournamentMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    whitePlayerId?: StringFieldUpdateOperationsInput | string
    blackPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutGameNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutGameNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutGameNestedInput
    match?: matchesUncheckedUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    events?: GameEventUncheckedUpdateManyWithoutGameNestedInput
  }

  export type gamesCreateWithoutTournamentInput = {
    id: string
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesCreateNestedManyWithoutGameInput
    gameMoves?: game_movesCreateNestedManyWithoutGameInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutGameInput
    whitePlayer: usersCreateNestedOneWithoutWhiteGamesInput
    blackPlayer?: usersCreateNestedOneWithoutBlackGamesInput
    match?: matchesCreateNestedOneWithoutGameInput
    tournamentMatch?: tournament_matchesCreateNestedOneWithoutGameInput
    sessions?: GameSessionCreateNestedManyWithoutGameInput
    events?: GameEventCreateNestedManyWithoutGameInput
  }

  export type gamesUncheckedCreateWithoutTournamentInput = {
    id: string
    whitePlayerId: string
    blackPlayerId?: string | null
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutGameInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutGameInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutGameInput
    match?: matchesUncheckedCreateNestedOneWithoutGameInput
    tournamentMatch?: tournament_matchesUncheckedCreateNestedOneWithoutGameInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    events?: GameEventUncheckedCreateNestedManyWithoutGameInput
  }

  export type gamesCreateOrConnectWithoutTournamentInput = {
    where: gamesWhereUniqueInput
    create: XOR<gamesCreateWithoutTournamentInput, gamesUncheckedCreateWithoutTournamentInput>
  }

  export type gamesCreateManyTournamentInputEnvelope = {
    data: gamesCreateManyTournamentInput | gamesCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type tournament_participantsCreateWithoutTournamentsInput = {
    id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
    users: usersCreateNestedOneWithoutTournamentParticipantsInput
    whiteMatches?: tournament_matchesCreateNestedManyWithoutWhiteInput
    blackMatches?: tournament_matchesCreateNestedManyWithoutBlackInput
    wonMatches?: tournament_matchesCreateNestedManyWithoutWinnerInput
  }

  export type tournament_participantsUncheckedCreateWithoutTournamentsInput = {
    id: string
    user_id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
    whiteMatches?: tournament_matchesUncheckedCreateNestedManyWithoutWhiteInput
    blackMatches?: tournament_matchesUncheckedCreateNestedManyWithoutBlackInput
    wonMatches?: tournament_matchesUncheckedCreateNestedManyWithoutWinnerInput
  }

  export type tournament_participantsCreateOrConnectWithoutTournamentsInput = {
    where: tournament_participantsWhereUniqueInput
    create: XOR<tournament_participantsCreateWithoutTournamentsInput, tournament_participantsUncheckedCreateWithoutTournamentsInput>
  }

  export type tournament_participantsCreateManyTournamentsInputEnvelope = {
    data: tournament_participantsCreateManyTournamentsInput | tournament_participantsCreateManyTournamentsInput[]
    skipDuplicates?: boolean
  }

  export type tournament_matchesCreateWithoutTournamentInput = {
    id?: string
    round: number
    matchNumber: number
    status?: $Enums.TournamentMatchStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    white?: tournament_participantsCreateNestedOneWithoutWhiteMatchesInput
    black?: tournament_participantsCreateNestedOneWithoutBlackMatchesInput
    winner?: tournament_participantsCreateNestedOneWithoutWonMatchesInput
    game?: gamesCreateNestedOneWithoutTournamentMatchInput
  }

  export type tournament_matchesUncheckedCreateWithoutTournamentInput = {
    id?: string
    round: number
    matchNumber: number
    whiteParticipantId?: string | null
    blackParticipantId?: string | null
    winnerParticipantId?: string | null
    status?: $Enums.TournamentMatchStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    gameId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tournament_matchesCreateOrConnectWithoutTournamentInput = {
    where: tournament_matchesWhereUniqueInput
    create: XOR<tournament_matchesCreateWithoutTournamentInput, tournament_matchesUncheckedCreateWithoutTournamentInput>
  }

  export type tournament_matchesCreateManyTournamentInputEnvelope = {
    data: tournament_matchesCreateManyTournamentInput | tournament_matchesCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutTournamentsInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesCreateNestedManyWithoutUserInput
    gameMoves?: game_movesCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsCreateNestedManyWithoutUsersInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutUserInput
    whiteGames?: gamesCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutTournamentsInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaUncheckedCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutUserInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesUncheckedCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutUserInput
    whiteGames?: gamesUncheckedCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesUncheckedCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutTournamentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTournamentsInput, usersUncheckedCreateWithoutTournamentsInput>
  }

  export type gamesUpsertWithWhereUniqueWithoutTournamentInput = {
    where: gamesWhereUniqueInput
    update: XOR<gamesUpdateWithoutTournamentInput, gamesUncheckedUpdateWithoutTournamentInput>
    create: XOR<gamesCreateWithoutTournamentInput, gamesUncheckedCreateWithoutTournamentInput>
  }

  export type gamesUpdateWithWhereUniqueWithoutTournamentInput = {
    where: gamesWhereUniqueInput
    data: XOR<gamesUpdateWithoutTournamentInput, gamesUncheckedUpdateWithoutTournamentInput>
  }

  export type gamesUpdateManyWithWhereWithoutTournamentInput = {
    where: gamesScalarWhereInput
    data: XOR<gamesUpdateManyMutationInput, gamesUncheckedUpdateManyWithoutTournamentInput>
  }

  export type gamesScalarWhereInput = {
    AND?: gamesScalarWhereInput | gamesScalarWhereInput[]
    OR?: gamesScalarWhereInput[]
    NOT?: gamesScalarWhereInput | gamesScalarWhereInput[]
    id?: StringFilter<"games"> | string
    whitePlayerId?: StringFilter<"games"> | string
    blackPlayerId?: StringNullableFilter<"games"> | string | null
    tournamentId?: StringNullableFilter<"games"> | string | null
    gameMode?: EnumGameModeFilter<"games"> | $Enums.GameMode
    status?: EnumGameStatusFilter<"games"> | $Enums.GameStatus
    stake?: IntFilter<"games"> | number
    winner?: EnumPlayerNullableFilter<"games"> | $Enums.Player | null
    drawOfferedBy?: EnumPlayerNullableFilter<"games"> | $Enums.Player | null
    whiteScore?: IntFilter<"games"> | number
    blackScore?: IntFilter<"games"> | number
    boardState?: JsonFilter<"games">
    currentPlayer?: EnumPlayerFilter<"games"> | $Enums.Player
    dice?: IntNullableListFilter<"games">
    cubeLevel?: IntFilter<"games"> | number
    cubeOwner?: EnumPlayerNullableFilter<"games"> | $Enums.Player | null
    matchLength?: IntNullableFilter<"games"> | number | null
    doubleOfferedBy?: StringNullableFilter<"games"> | string | null
    doublePending?: BoolFilter<"games"> | boolean
    cubeHistory?: JsonFilter<"games">
    timeControlPreset?: EnumTimeControlPresetNullableFilter<"games"> | $Enums.TimeControlPreset | null
    timeControlTotalMs?: IntNullableFilter<"games"> | number | null
    timeControlIncrementMs?: IntNullableFilter<"games"> | number | null
    timeControlDelayMs?: IntNullableFilter<"games"> | number | null
    whiteTimeRemainingMs?: IntNullableFilter<"games"> | number | null
    blackTimeRemainingMs?: IntNullableFilter<"games"> | number | null
    activeTimer?: EnumPlayerNullableFilter<"games"> | $Enums.Player | null
    timerUpdatedAt?: DateTimeNullableFilter<"games"> | Date | string | null
    createdAt?: DateTimeFilter<"games"> | Date | string
    finishedAt?: DateTimeNullableFilter<"games"> | Date | string | null
    updatedAt?: DateTimeFilter<"games"> | Date | string
    resignationType?: EnumResignationTypeNullableFilter<"games"> | $Enums.ResignationType | null
  }

  export type tournament_participantsUpsertWithWhereUniqueWithoutTournamentsInput = {
    where: tournament_participantsWhereUniqueInput
    update: XOR<tournament_participantsUpdateWithoutTournamentsInput, tournament_participantsUncheckedUpdateWithoutTournamentsInput>
    create: XOR<tournament_participantsCreateWithoutTournamentsInput, tournament_participantsUncheckedCreateWithoutTournamentsInput>
  }

  export type tournament_participantsUpdateWithWhereUniqueWithoutTournamentsInput = {
    where: tournament_participantsWhereUniqueInput
    data: XOR<tournament_participantsUpdateWithoutTournamentsInput, tournament_participantsUncheckedUpdateWithoutTournamentsInput>
  }

  export type tournament_participantsUpdateManyWithWhereWithoutTournamentsInput = {
    where: tournament_participantsScalarWhereInput
    data: XOR<tournament_participantsUpdateManyMutationInput, tournament_participantsUncheckedUpdateManyWithoutTournamentsInput>
  }

  export type tournament_participantsScalarWhereInput = {
    AND?: tournament_participantsScalarWhereInput | tournament_participantsScalarWhereInput[]
    OR?: tournament_participantsScalarWhereInput[]
    NOT?: tournament_participantsScalarWhereInput | tournament_participantsScalarWhereInput[]
    id?: StringFilter<"tournament_participants"> | string
    tournament_id?: StringFilter<"tournament_participants"> | string
    user_id?: StringFilter<"tournament_participants"> | string
    registered_at?: DateTimeFilter<"tournament_participants"> | Date | string
    current_position?: IntNullableFilter<"tournament_participants"> | number | null
    eliminated_at?: DateTimeNullableFilter<"tournament_participants"> | Date | string | null
  }

  export type tournament_matchesUpsertWithWhereUniqueWithoutTournamentInput = {
    where: tournament_matchesWhereUniqueInput
    update: XOR<tournament_matchesUpdateWithoutTournamentInput, tournament_matchesUncheckedUpdateWithoutTournamentInput>
    create: XOR<tournament_matchesCreateWithoutTournamentInput, tournament_matchesUncheckedCreateWithoutTournamentInput>
  }

  export type tournament_matchesUpdateWithWhereUniqueWithoutTournamentInput = {
    where: tournament_matchesWhereUniqueInput
    data: XOR<tournament_matchesUpdateWithoutTournamentInput, tournament_matchesUncheckedUpdateWithoutTournamentInput>
  }

  export type tournament_matchesUpdateManyWithWhereWithoutTournamentInput = {
    where: tournament_matchesScalarWhereInput
    data: XOR<tournament_matchesUpdateManyMutationInput, tournament_matchesUncheckedUpdateManyWithoutTournamentInput>
  }

  export type usersUpsertWithoutTournamentsInput = {
    update: XOR<usersUpdateWithoutTournamentsInput, usersUncheckedUpdateWithoutTournamentsInput>
    create: XOR<usersCreateWithoutTournamentsInput, usersUncheckedCreateWithoutTournamentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTournamentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTournamentsInput, usersUncheckedUpdateWithoutTournamentsInput>
  }

  export type usersUpdateWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUncheckedUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUncheckedUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUncheckedUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUncheckedUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUncheckedUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutUserAnalyticsInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesCreateNestedManyWithoutUserInput
    gameMoves?: game_movesCreateNestedManyWithoutUserInput
    gameAnalyses?: game_analysesCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutUserInput
    whiteGames?: gamesCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutUserAnalyticsInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaUncheckedCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutUserInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutUserInput
    gameAnalyses?: game_analysesUncheckedCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutUserInput
    whiteGames?: gamesUncheckedCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesUncheckedCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutUserAnalyticsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUserAnalyticsInput, usersUncheckedCreateWithoutUserAnalyticsInput>
  }

  export type usersUpsertWithoutUserAnalyticsInput = {
    update: XOR<usersUpdateWithoutUserAnalyticsInput, usersUncheckedUpdateWithoutUserAnalyticsInput>
    create: XOR<usersCreateWithoutUserAnalyticsInput, usersUncheckedCreateWithoutUserAnalyticsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUserAnalyticsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUserAnalyticsInput, usersUncheckedUpdateWithoutUserAnalyticsInput>
  }

  export type usersUpdateWithoutUserAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUpdateManyWithoutUserNestedInput
    gameAnalyses?: game_analysesUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutUserAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUncheckedUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutUserNestedInput
    gameAnalyses?: game_analysesUncheckedUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUncheckedUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUncheckedUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUncheckedUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutGameAnalysesInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesCreateNestedManyWithoutUserInput
    gameMoves?: game_movesCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutUserInput
    whiteGames?: gamesCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutGameAnalysesInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaUncheckedCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutUserInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutUserInput
    whiteGames?: gamesUncheckedCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesUncheckedCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutGameAnalysesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutGameAnalysesInput, usersUncheckedCreateWithoutGameAnalysesInput>
  }

  export type usersUpsertWithoutGameAnalysesInput = {
    update: XOR<usersUpdateWithoutGameAnalysesInput, usersUncheckedUpdateWithoutGameAnalysesInput>
    create: XOR<usersCreateWithoutGameAnalysesInput, usersUncheckedCreateWithoutGameAnalysesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutGameAnalysesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutGameAnalysesInput, usersUncheckedUpdateWithoutGameAnalysesInput>
  }

  export type usersUpdateWithoutGameAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutGameAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUncheckedUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUncheckedUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUncheckedUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUncheckedUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type chat_messagesCreateWithoutGameInput = {
    id: string
    message: string
    messageType?: $Enums.MessageType
    createdAt?: Date | string
    user?: usersCreateNestedOneWithoutChatMessagesInput
  }

  export type chat_messagesUncheckedCreateWithoutGameInput = {
    id: string
    userId?: string | null
    message: string
    messageType?: $Enums.MessageType
    createdAt?: Date | string
  }

  export type chat_messagesCreateOrConnectWithoutGameInput = {
    where: chat_messagesWhereUniqueInput
    create: XOR<chat_messagesCreateWithoutGameInput, chat_messagesUncheckedCreateWithoutGameInput>
  }

  export type chat_messagesCreateManyGameInputEnvelope = {
    data: chat_messagesCreateManyGameInput | chat_messagesCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type game_movesCreateWithoutGameInput = {
    id: string
    player: $Enums.Player
    dice?: game_movesCreatediceInput | number[]
    move: string
    fromPoint?: number | null
    toPoint?: number | null
    equity?: number | null
    pr?: number | null
    thinkingTime?: number | null
    createdAt?: Date | string
    user?: usersCreateNestedOneWithoutGameMovesInput
  }

  export type game_movesUncheckedCreateWithoutGameInput = {
    id: string
    userId?: string | null
    player: $Enums.Player
    dice?: game_movesCreatediceInput | number[]
    move: string
    fromPoint?: number | null
    toPoint?: number | null
    equity?: number | null
    pr?: number | null
    thinkingTime?: number | null
    createdAt?: Date | string
  }

  export type game_movesCreateOrConnectWithoutGameInput = {
    where: game_movesWhereUniqueInput
    create: XOR<game_movesCreateWithoutGameInput, game_movesUncheckedCreateWithoutGameInput>
  }

  export type game_movesCreateManyGameInputEnvelope = {
    data: game_movesCreateManyGameInput | game_movesCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type tournamentsCreateWithoutGamesInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    participants?: tournament_participantsCreateNestedManyWithoutTournamentsInput
    matches?: tournament_matchesCreateNestedManyWithoutTournamentInput
    creator: usersCreateNestedOneWithoutTournamentsInput
  }

  export type tournamentsUncheckedCreateWithoutGamesInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    participants?: tournament_participantsUncheckedCreateNestedManyWithoutTournamentsInput
    matches?: tournament_matchesUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type tournamentsCreateOrConnectWithoutGamesInput = {
    where: tournamentsWhereUniqueInput
    create: XOR<tournamentsCreateWithoutGamesInput, tournamentsUncheckedCreateWithoutGamesInput>
  }

  export type websocket_connectionsCreateWithoutGameInput = {
    id: string
    connectionId: string
    connectedAt?: Date | string
    lastPing?: Date | string
    isActive?: boolean
    user: usersCreateNestedOneWithoutWebsocketConnectionsInput
  }

  export type websocket_connectionsUncheckedCreateWithoutGameInput = {
    id: string
    connectionId: string
    userId: string
    connectedAt?: Date | string
    lastPing?: Date | string
    isActive?: boolean
  }

  export type websocket_connectionsCreateOrConnectWithoutGameInput = {
    where: websocket_connectionsWhereUniqueInput
    create: XOR<websocket_connectionsCreateWithoutGameInput, websocket_connectionsUncheckedCreateWithoutGameInput>
  }

  export type websocket_connectionsCreateManyGameInputEnvelope = {
    data: websocket_connectionsCreateManyGameInput | websocket_connectionsCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutWhiteGamesInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesCreateNestedManyWithoutUserInput
    gameMoves?: game_movesCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutUserInput
    blackGames?: gamesCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutWhiteGamesInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaUncheckedCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutUserInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesUncheckedCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutUserInput
    blackGames?: gamesUncheckedCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutWhiteGamesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutWhiteGamesInput, usersUncheckedCreateWithoutWhiteGamesInput>
  }

  export type usersCreateWithoutBlackGamesInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesCreateNestedManyWithoutUserInput
    gameMoves?: game_movesCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutUserInput
    whiteGames?: gamesCreateNestedManyWithoutWhitePlayerInput
    gameSessions?: GameSessionCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutBlackGamesInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaUncheckedCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutUserInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesUncheckedCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutUserInput
    whiteGames?: gamesUncheckedCreateNestedManyWithoutWhitePlayerInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutBlackGamesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutBlackGamesInput, usersUncheckedCreateWithoutBlackGamesInput>
  }

  export type matchesCreateWithoutGameInput = {
    id?: string
    length: number
    rules?: JsonNullValueInput | InputJsonValue
    state?: $Enums.MatchState
    crawfordUsed?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type matchesUncheckedCreateWithoutGameInput = {
    id?: string
    length: number
    rules?: JsonNullValueInput | InputJsonValue
    state?: $Enums.MatchState
    crawfordUsed?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type matchesCreateOrConnectWithoutGameInput = {
    where: matchesWhereUniqueInput
    create: XOR<matchesCreateWithoutGameInput, matchesUncheckedCreateWithoutGameInput>
  }

  export type tournament_matchesCreateWithoutGameInput = {
    id?: string
    round: number
    matchNumber: number
    status?: $Enums.TournamentMatchStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournament: tournamentsCreateNestedOneWithoutMatchesInput
    white?: tournament_participantsCreateNestedOneWithoutWhiteMatchesInput
    black?: tournament_participantsCreateNestedOneWithoutBlackMatchesInput
    winner?: tournament_participantsCreateNestedOneWithoutWonMatchesInput
  }

  export type tournament_matchesUncheckedCreateWithoutGameInput = {
    id?: string
    tournamentId: string
    round: number
    matchNumber: number
    whiteParticipantId?: string | null
    blackParticipantId?: string | null
    winnerParticipantId?: string | null
    status?: $Enums.TournamentMatchStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tournament_matchesCreateOrConnectWithoutGameInput = {
    where: tournament_matchesWhereUniqueInput
    create: XOR<tournament_matchesCreateWithoutGameInput, tournament_matchesUncheckedCreateWithoutGameInput>
  }

  export type GameSessionCreateWithoutGameInput = {
    id?: string
    resumeTokenHash: string
    lastAckSequence?: number
    lastHeartbeatAt?: Date | string | null
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: usersCreateNestedOneWithoutGameSessionsInput
  }

  export type GameSessionUncheckedCreateWithoutGameInput = {
    id?: string
    userId: string
    resumeTokenHash: string
    lastAckSequence?: number
    lastHeartbeatAt?: Date | string | null
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GameSessionCreateOrConnectWithoutGameInput = {
    where: GameSessionWhereUniqueInput
    create: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput>
  }

  export type GameSessionCreateManyGameInputEnvelope = {
    data: GameSessionCreateManyGameInput | GameSessionCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type GameEventCreateWithoutGameInput = {
    id?: string
    sequence: number
    type: string
    payload: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GameEventUncheckedCreateWithoutGameInput = {
    id?: string
    sequence: number
    type: string
    payload: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GameEventCreateOrConnectWithoutGameInput = {
    where: GameEventWhereUniqueInput
    create: XOR<GameEventCreateWithoutGameInput, GameEventUncheckedCreateWithoutGameInput>
  }

  export type GameEventCreateManyGameInputEnvelope = {
    data: GameEventCreateManyGameInput | GameEventCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type chat_messagesUpsertWithWhereUniqueWithoutGameInput = {
    where: chat_messagesWhereUniqueInput
    update: XOR<chat_messagesUpdateWithoutGameInput, chat_messagesUncheckedUpdateWithoutGameInput>
    create: XOR<chat_messagesCreateWithoutGameInput, chat_messagesUncheckedCreateWithoutGameInput>
  }

  export type chat_messagesUpdateWithWhereUniqueWithoutGameInput = {
    where: chat_messagesWhereUniqueInput
    data: XOR<chat_messagesUpdateWithoutGameInput, chat_messagesUncheckedUpdateWithoutGameInput>
  }

  export type chat_messagesUpdateManyWithWhereWithoutGameInput = {
    where: chat_messagesScalarWhereInput
    data: XOR<chat_messagesUpdateManyMutationInput, chat_messagesUncheckedUpdateManyWithoutGameInput>
  }

  export type chat_messagesScalarWhereInput = {
    AND?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
    OR?: chat_messagesScalarWhereInput[]
    NOT?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
    id?: StringFilter<"chat_messages"> | string
    gameId?: StringFilter<"chat_messages"> | string
    userId?: StringNullableFilter<"chat_messages"> | string | null
    message?: StringFilter<"chat_messages"> | string
    messageType?: EnumMessageTypeFilter<"chat_messages"> | $Enums.MessageType
    createdAt?: DateTimeFilter<"chat_messages"> | Date | string
  }

  export type game_movesUpsertWithWhereUniqueWithoutGameInput = {
    where: game_movesWhereUniqueInput
    update: XOR<game_movesUpdateWithoutGameInput, game_movesUncheckedUpdateWithoutGameInput>
    create: XOR<game_movesCreateWithoutGameInput, game_movesUncheckedCreateWithoutGameInput>
  }

  export type game_movesUpdateWithWhereUniqueWithoutGameInput = {
    where: game_movesWhereUniqueInput
    data: XOR<game_movesUpdateWithoutGameInput, game_movesUncheckedUpdateWithoutGameInput>
  }

  export type game_movesUpdateManyWithWhereWithoutGameInput = {
    where: game_movesScalarWhereInput
    data: XOR<game_movesUpdateManyMutationInput, game_movesUncheckedUpdateManyWithoutGameInput>
  }

  export type game_movesScalarWhereInput = {
    AND?: game_movesScalarWhereInput | game_movesScalarWhereInput[]
    OR?: game_movesScalarWhereInput[]
    NOT?: game_movesScalarWhereInput | game_movesScalarWhereInput[]
    id?: StringFilter<"game_moves"> | string
    gameId?: StringFilter<"game_moves"> | string
    userId?: StringNullableFilter<"game_moves"> | string | null
    player?: EnumPlayerFilter<"game_moves"> | $Enums.Player
    dice?: IntNullableListFilter<"game_moves">
    move?: StringFilter<"game_moves"> | string
    fromPoint?: IntNullableFilter<"game_moves"> | number | null
    toPoint?: IntNullableFilter<"game_moves"> | number | null
    equity?: FloatNullableFilter<"game_moves"> | number | null
    pr?: FloatNullableFilter<"game_moves"> | number | null
    thinkingTime?: IntNullableFilter<"game_moves"> | number | null
    createdAt?: DateTimeFilter<"game_moves"> | Date | string
  }

  export type tournamentsUpsertWithoutGamesInput = {
    update: XOR<tournamentsUpdateWithoutGamesInput, tournamentsUncheckedUpdateWithoutGamesInput>
    create: XOR<tournamentsCreateWithoutGamesInput, tournamentsUncheckedCreateWithoutGamesInput>
    where?: tournamentsWhereInput
  }

  export type tournamentsUpdateToOneWithWhereWithoutGamesInput = {
    where?: tournamentsWhereInput
    data: XOR<tournamentsUpdateWithoutGamesInput, tournamentsUncheckedUpdateWithoutGamesInput>
  }

  export type tournamentsUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: tournament_participantsUpdateManyWithoutTournamentsNestedInput
    matches?: tournament_matchesUpdateManyWithoutTournamentNestedInput
    creator?: usersUpdateOneRequiredWithoutTournamentsNestedInput
  }

  export type tournamentsUncheckedUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: tournament_participantsUncheckedUpdateManyWithoutTournamentsNestedInput
    matches?: tournament_matchesUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type websocket_connectionsUpsertWithWhereUniqueWithoutGameInput = {
    where: websocket_connectionsWhereUniqueInput
    update: XOR<websocket_connectionsUpdateWithoutGameInput, websocket_connectionsUncheckedUpdateWithoutGameInput>
    create: XOR<websocket_connectionsCreateWithoutGameInput, websocket_connectionsUncheckedCreateWithoutGameInput>
  }

  export type websocket_connectionsUpdateWithWhereUniqueWithoutGameInput = {
    where: websocket_connectionsWhereUniqueInput
    data: XOR<websocket_connectionsUpdateWithoutGameInput, websocket_connectionsUncheckedUpdateWithoutGameInput>
  }

  export type websocket_connectionsUpdateManyWithWhereWithoutGameInput = {
    where: websocket_connectionsScalarWhereInput
    data: XOR<websocket_connectionsUpdateManyMutationInput, websocket_connectionsUncheckedUpdateManyWithoutGameInput>
  }

  export type websocket_connectionsScalarWhereInput = {
    AND?: websocket_connectionsScalarWhereInput | websocket_connectionsScalarWhereInput[]
    OR?: websocket_connectionsScalarWhereInput[]
    NOT?: websocket_connectionsScalarWhereInput | websocket_connectionsScalarWhereInput[]
    id?: StringFilter<"websocket_connections"> | string
    connectionId?: StringFilter<"websocket_connections"> | string
    userId?: StringFilter<"websocket_connections"> | string
    gameId?: StringNullableFilter<"websocket_connections"> | string | null
    connectedAt?: DateTimeFilter<"websocket_connections"> | Date | string
    lastPing?: DateTimeFilter<"websocket_connections"> | Date | string
    isActive?: BoolFilter<"websocket_connections"> | boolean
  }

  export type usersUpsertWithoutWhiteGamesInput = {
    update: XOR<usersUpdateWithoutWhiteGamesInput, usersUncheckedUpdateWithoutWhiteGamesInput>
    create: XOR<usersCreateWithoutWhiteGamesInput, usersUncheckedCreateWithoutWhiteGamesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutWhiteGamesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutWhiteGamesInput, usersUncheckedUpdateWithoutWhiteGamesInput>
  }

  export type usersUpdateWithoutWhiteGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutUserNestedInput
    blackGames?: gamesUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutWhiteGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUncheckedUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUncheckedUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutUserNestedInput
    blackGames?: gamesUncheckedUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUncheckedUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersUpsertWithoutBlackGamesInput = {
    update: XOR<usersUpdateWithoutBlackGamesInput, usersUncheckedUpdateWithoutBlackGamesInput>
    create: XOR<usersCreateWithoutBlackGamesInput, usersUncheckedCreateWithoutBlackGamesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutBlackGamesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutBlackGamesInput, usersUncheckedUpdateWithoutBlackGamesInput>
  }

  export type usersUpdateWithoutBlackGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUpdateManyWithoutWhitePlayerNestedInput
    gameSessions?: GameSessionUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutBlackGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUncheckedUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUncheckedUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUncheckedUpdateManyWithoutWhitePlayerNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUncheckedUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type matchesUpsertWithoutGameInput = {
    update: XOR<matchesUpdateWithoutGameInput, matchesUncheckedUpdateWithoutGameInput>
    create: XOR<matchesCreateWithoutGameInput, matchesUncheckedCreateWithoutGameInput>
    where?: matchesWhereInput
  }

  export type matchesUpdateToOneWithWhereWithoutGameInput = {
    where?: matchesWhereInput
    data: XOR<matchesUpdateWithoutGameInput, matchesUncheckedUpdateWithoutGameInput>
  }

  export type matchesUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    rules?: JsonNullValueInput | InputJsonValue
    state?: EnumMatchStateFieldUpdateOperationsInput | $Enums.MatchState
    crawfordUsed?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type matchesUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    rules?: JsonNullValueInput | InputJsonValue
    state?: EnumMatchStateFieldUpdateOperationsInput | $Enums.MatchState
    crawfordUsed?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournament_matchesUpsertWithoutGameInput = {
    update: XOR<tournament_matchesUpdateWithoutGameInput, tournament_matchesUncheckedUpdateWithoutGameInput>
    create: XOR<tournament_matchesCreateWithoutGameInput, tournament_matchesUncheckedCreateWithoutGameInput>
    where?: tournament_matchesWhereInput
  }

  export type tournament_matchesUpdateToOneWithWhereWithoutGameInput = {
    where?: tournament_matchesWhereInput
    data: XOR<tournament_matchesUpdateWithoutGameInput, tournament_matchesUncheckedUpdateWithoutGameInput>
  }

  export type tournament_matchesUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumTournamentMatchStatusFieldUpdateOperationsInput | $Enums.TournamentMatchStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: tournamentsUpdateOneRequiredWithoutMatchesNestedInput
    white?: tournament_participantsUpdateOneWithoutWhiteMatchesNestedInput
    black?: tournament_participantsUpdateOneWithoutBlackMatchesNestedInput
    winner?: tournament_participantsUpdateOneWithoutWonMatchesNestedInput
  }

  export type tournament_matchesUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    whiteParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    blackParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTournamentMatchStatusFieldUpdateOperationsInput | $Enums.TournamentMatchStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionUpsertWithWhereUniqueWithoutGameInput = {
    where: GameSessionWhereUniqueInput
    update: XOR<GameSessionUpdateWithoutGameInput, GameSessionUncheckedUpdateWithoutGameInput>
    create: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput>
  }

  export type GameSessionUpdateWithWhereUniqueWithoutGameInput = {
    where: GameSessionWhereUniqueInput
    data: XOR<GameSessionUpdateWithoutGameInput, GameSessionUncheckedUpdateWithoutGameInput>
  }

  export type GameSessionUpdateManyWithWhereWithoutGameInput = {
    where: GameSessionScalarWhereInput
    data: XOR<GameSessionUpdateManyMutationInput, GameSessionUncheckedUpdateManyWithoutGameInput>
  }

  export type GameSessionScalarWhereInput = {
    AND?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
    OR?: GameSessionScalarWhereInput[]
    NOT?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
    id?: StringFilter<"GameSession"> | string
    gameId?: StringFilter<"GameSession"> | string
    userId?: StringFilter<"GameSession"> | string
    resumeTokenHash?: StringFilter<"GameSession"> | string
    lastAckSequence?: IntFilter<"GameSession"> | number
    lastHeartbeatAt?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    issuedAt?: DateTimeFilter<"GameSession"> | Date | string
    expiresAt?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    metadata?: JsonNullableFilter<"GameSession">
    createdAt?: DateTimeFilter<"GameSession"> | Date | string
  }

  export type GameEventUpsertWithWhereUniqueWithoutGameInput = {
    where: GameEventWhereUniqueInput
    update: XOR<GameEventUpdateWithoutGameInput, GameEventUncheckedUpdateWithoutGameInput>
    create: XOR<GameEventCreateWithoutGameInput, GameEventUncheckedCreateWithoutGameInput>
  }

  export type GameEventUpdateWithWhereUniqueWithoutGameInput = {
    where: GameEventWhereUniqueInput
    data: XOR<GameEventUpdateWithoutGameInput, GameEventUncheckedUpdateWithoutGameInput>
  }

  export type GameEventUpdateManyWithWhereWithoutGameInput = {
    where: GameEventScalarWhereInput
    data: XOR<GameEventUpdateManyMutationInput, GameEventUncheckedUpdateManyWithoutGameInput>
  }

  export type GameEventScalarWhereInput = {
    AND?: GameEventScalarWhereInput | GameEventScalarWhereInput[]
    OR?: GameEventScalarWhereInput[]
    NOT?: GameEventScalarWhereInput | GameEventScalarWhereInput[]
    id?: StringFilter<"GameEvent"> | string
    gameId?: StringFilter<"GameEvent"> | string
    sequence?: IntFilter<"GameEvent"> | number
    type?: StringFilter<"GameEvent"> | string
    payload?: JsonFilter<"GameEvent">
    createdAt?: DateTimeFilter<"GameEvent"> | Date | string
  }

  export type gamesCreateWithoutSessionsInput = {
    id: string
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesCreateNestedManyWithoutGameInput
    gameMoves?: game_movesCreateNestedManyWithoutGameInput
    tournament?: tournamentsCreateNestedOneWithoutGamesInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutGameInput
    whitePlayer: usersCreateNestedOneWithoutWhiteGamesInput
    blackPlayer?: usersCreateNestedOneWithoutBlackGamesInput
    match?: matchesCreateNestedOneWithoutGameInput
    tournamentMatch?: tournament_matchesCreateNestedOneWithoutGameInput
    events?: GameEventCreateNestedManyWithoutGameInput
  }

  export type gamesUncheckedCreateWithoutSessionsInput = {
    id: string
    whitePlayerId: string
    blackPlayerId?: string | null
    tournamentId?: string | null
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutGameInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutGameInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutGameInput
    match?: matchesUncheckedCreateNestedOneWithoutGameInput
    tournamentMatch?: tournament_matchesUncheckedCreateNestedOneWithoutGameInput
    events?: GameEventUncheckedCreateNestedManyWithoutGameInput
  }

  export type gamesCreateOrConnectWithoutSessionsInput = {
    where: gamesWhereUniqueInput
    create: XOR<gamesCreateWithoutSessionsInput, gamesUncheckedCreateWithoutSessionsInput>
  }

  export type usersCreateWithoutGameSessionsInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesCreateNestedManyWithoutUserInput
    gameMoves?: game_movesCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutUserInput
    whiteGames?: gamesCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesCreateNestedManyWithoutBlackPlayerInput
    seasonStats?: user_season_statsCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutGameSessionsInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaUncheckedCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutUserInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesUncheckedCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutUserInput
    whiteGames?: gamesUncheckedCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesUncheckedCreateNestedManyWithoutBlackPlayerInput
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutGameSessionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutGameSessionsInput, usersUncheckedCreateWithoutGameSessionsInput>
  }

  export type gamesUpsertWithoutSessionsInput = {
    update: XOR<gamesUpdateWithoutSessionsInput, gamesUncheckedUpdateWithoutSessionsInput>
    create: XOR<gamesCreateWithoutSessionsInput, gamesUncheckedCreateWithoutSessionsInput>
    where?: gamesWhereInput
  }

  export type gamesUpdateToOneWithWhereWithoutSessionsInput = {
    where?: gamesWhereInput
    data: XOR<gamesUpdateWithoutSessionsInput, gamesUncheckedUpdateWithoutSessionsInput>
  }

  export type gamesUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUpdateManyWithoutGameNestedInput
    gameMoves?: game_movesUpdateManyWithoutGameNestedInput
    tournament?: tournamentsUpdateOneWithoutGamesNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutGameNestedInput
    whitePlayer?: usersUpdateOneRequiredWithoutWhiteGamesNestedInput
    blackPlayer?: usersUpdateOneWithoutBlackGamesNestedInput
    match?: matchesUpdateOneWithoutGameNestedInput
    tournamentMatch?: tournament_matchesUpdateOneWithoutGameNestedInput
    events?: GameEventUpdateManyWithoutGameNestedInput
  }

  export type gamesUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    whitePlayerId?: StringFieldUpdateOperationsInput | string
    blackPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutGameNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutGameNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutGameNestedInput
    match?: matchesUncheckedUpdateOneWithoutGameNestedInput
    tournamentMatch?: tournament_matchesUncheckedUpdateOneWithoutGameNestedInput
    events?: GameEventUncheckedUpdateManyWithoutGameNestedInput
  }

  export type usersUpsertWithoutGameSessionsInput = {
    update: XOR<usersUpdateWithoutGameSessionsInput, usersUncheckedUpdateWithoutGameSessionsInput>
    create: XOR<usersCreateWithoutGameSessionsInput, usersUncheckedCreateWithoutGameSessionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutGameSessionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutGameSessionsInput, usersUncheckedUpdateWithoutGameSessionsInput>
  }

  export type usersUpdateWithoutGameSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUpdateManyWithoutBlackPlayerNestedInput
    seasonStats?: user_season_statsUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutGameSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUncheckedUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUncheckedUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUncheckedUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUncheckedUpdateManyWithoutBlackPlayerNestedInput
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUncheckedUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type gamesCreateWithoutEventsInput = {
    id: string
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesCreateNestedManyWithoutGameInput
    gameMoves?: game_movesCreateNestedManyWithoutGameInput
    tournament?: tournamentsCreateNestedOneWithoutGamesInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutGameInput
    whitePlayer: usersCreateNestedOneWithoutWhiteGamesInput
    blackPlayer?: usersCreateNestedOneWithoutBlackGamesInput
    match?: matchesCreateNestedOneWithoutGameInput
    tournamentMatch?: tournament_matchesCreateNestedOneWithoutGameInput
    sessions?: GameSessionCreateNestedManyWithoutGameInput
  }

  export type gamesUncheckedCreateWithoutEventsInput = {
    id: string
    whitePlayerId: string
    blackPlayerId?: string | null
    tournamentId?: string | null
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutGameInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutGameInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutGameInput
    match?: matchesUncheckedCreateNestedOneWithoutGameInput
    tournamentMatch?: tournament_matchesUncheckedCreateNestedOneWithoutGameInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
  }

  export type gamesCreateOrConnectWithoutEventsInput = {
    where: gamesWhereUniqueInput
    create: XOR<gamesCreateWithoutEventsInput, gamesUncheckedCreateWithoutEventsInput>
  }

  export type gamesUpsertWithoutEventsInput = {
    update: XOR<gamesUpdateWithoutEventsInput, gamesUncheckedUpdateWithoutEventsInput>
    create: XOR<gamesCreateWithoutEventsInput, gamesUncheckedCreateWithoutEventsInput>
    where?: gamesWhereInput
  }

  export type gamesUpdateToOneWithWhereWithoutEventsInput = {
    where?: gamesWhereInput
    data: XOR<gamesUpdateWithoutEventsInput, gamesUncheckedUpdateWithoutEventsInput>
  }

  export type gamesUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUpdateManyWithoutGameNestedInput
    gameMoves?: game_movesUpdateManyWithoutGameNestedInput
    tournament?: tournamentsUpdateOneWithoutGamesNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutGameNestedInput
    whitePlayer?: usersUpdateOneRequiredWithoutWhiteGamesNestedInput
    blackPlayer?: usersUpdateOneWithoutBlackGamesNestedInput
    match?: matchesUpdateOneWithoutGameNestedInput
    tournamentMatch?: tournament_matchesUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUpdateManyWithoutGameNestedInput
  }

  export type gamesUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    whitePlayerId?: StringFieldUpdateOperationsInput | string
    blackPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutGameNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutGameNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutGameNestedInput
    match?: matchesUncheckedUpdateOneWithoutGameNestedInput
    tournamentMatch?: tournament_matchesUncheckedUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
  }

  export type gamesCreateWithoutMatchInput = {
    id: string
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesCreateNestedManyWithoutGameInput
    gameMoves?: game_movesCreateNestedManyWithoutGameInput
    tournament?: tournamentsCreateNestedOneWithoutGamesInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutGameInput
    whitePlayer: usersCreateNestedOneWithoutWhiteGamesInput
    blackPlayer?: usersCreateNestedOneWithoutBlackGamesInput
    tournamentMatch?: tournament_matchesCreateNestedOneWithoutGameInput
    sessions?: GameSessionCreateNestedManyWithoutGameInput
    events?: GameEventCreateNestedManyWithoutGameInput
  }

  export type gamesUncheckedCreateWithoutMatchInput = {
    id: string
    whitePlayerId: string
    blackPlayerId?: string | null
    tournamentId?: string | null
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutGameInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutGameInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutGameInput
    tournamentMatch?: tournament_matchesUncheckedCreateNestedOneWithoutGameInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    events?: GameEventUncheckedCreateNestedManyWithoutGameInput
  }

  export type gamesCreateOrConnectWithoutMatchInput = {
    where: gamesWhereUniqueInput
    create: XOR<gamesCreateWithoutMatchInput, gamesUncheckedCreateWithoutMatchInput>
  }

  export type gamesUpsertWithoutMatchInput = {
    update: XOR<gamesUpdateWithoutMatchInput, gamesUncheckedUpdateWithoutMatchInput>
    create: XOR<gamesCreateWithoutMatchInput, gamesUncheckedCreateWithoutMatchInput>
    where?: gamesWhereInput
  }

  export type gamesUpdateToOneWithWhereWithoutMatchInput = {
    where?: gamesWhereInput
    data: XOR<gamesUpdateWithoutMatchInput, gamesUncheckedUpdateWithoutMatchInput>
  }

  export type gamesUpdateWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUpdateManyWithoutGameNestedInput
    gameMoves?: game_movesUpdateManyWithoutGameNestedInput
    tournament?: tournamentsUpdateOneWithoutGamesNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutGameNestedInput
    whitePlayer?: usersUpdateOneRequiredWithoutWhiteGamesNestedInput
    blackPlayer?: usersUpdateOneWithoutBlackGamesNestedInput
    tournamentMatch?: tournament_matchesUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUpdateManyWithoutGameNestedInput
    events?: GameEventUpdateManyWithoutGameNestedInput
  }

  export type gamesUncheckedUpdateWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    whitePlayerId?: StringFieldUpdateOperationsInput | string
    blackPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutGameNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutGameNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutGameNestedInput
    tournamentMatch?: tournament_matchesUncheckedUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    events?: GameEventUncheckedUpdateManyWithoutGameNestedInput
  }

  export type analysesCreateWithoutUserInput = {
    id: string
    boardState: string
    dice?: analysesCreatediceInput | number[]
    move: string
    bestMove: string
    equity: number
    pr: number
    explanation: string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysisType?: $Enums.AnalysisType
    createdAt?: Date | string
  }

  export type analysesUncheckedCreateWithoutUserInput = {
    id: string
    boardState: string
    dice?: analysesCreatediceInput | number[]
    move: string
    bestMove: string
    equity: number
    pr: number
    explanation: string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysisType?: $Enums.AnalysisType
    createdAt?: Date | string
  }

  export type analysesCreateOrConnectWithoutUserInput = {
    where: analysesWhereUniqueInput
    create: XOR<analysesCreateWithoutUserInput, analysesUncheckedCreateWithoutUserInput>
  }

  export type analysesCreateManyUserInputEnvelope = {
    data: analysesCreateManyUserInput | analysesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AnalysisQuotaCreateWithoutUserInput = {
    id?: string
    date: Date | string
    count: number
    extraQuota?: number
    initialFree?: boolean
  }

  export type AnalysisQuotaUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    count: number
    extraQuota?: number
    initialFree?: boolean
  }

  export type AnalysisQuotaCreateOrConnectWithoutUserInput = {
    where: AnalysisQuotaWhereUniqueInput
    create: XOR<AnalysisQuotaCreateWithoutUserInput, AnalysisQuotaUncheckedCreateWithoutUserInput>
  }

  export type AnalysisQuotaCreateManyUserInputEnvelope = {
    data: AnalysisQuotaCreateManyUserInput | AnalysisQuotaCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IAQuotaCreateWithoutUserInput = {
    id?: string
    dailyQuota?: number
    premiumQuota?: number
    extrasUsed?: number
    resetAt: Date | string
  }

  export type IAQuotaUncheckedCreateWithoutUserInput = {
    id?: string
    dailyQuota?: number
    premiumQuota?: number
    extrasUsed?: number
    resetAt: Date | string
  }

  export type IAQuotaCreateOrConnectWithoutUserInput = {
    where: IAQuotaWhereUniqueInput
    create: XOR<IAQuotaCreateWithoutUserInput, IAQuotaUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateWithoutUserInput = {
    id?: string
    tokenHash: string
    jti: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: string
    tokenHash: string
    jti: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type chat_messagesCreateWithoutUserInput = {
    id: string
    message: string
    messageType?: $Enums.MessageType
    createdAt?: Date | string
    game: gamesCreateNestedOneWithoutChatMessagesInput
  }

  export type chat_messagesUncheckedCreateWithoutUserInput = {
    id: string
    gameId: string
    message: string
    messageType?: $Enums.MessageType
    createdAt?: Date | string
  }

  export type chat_messagesCreateOrConnectWithoutUserInput = {
    where: chat_messagesWhereUniqueInput
    create: XOR<chat_messagesCreateWithoutUserInput, chat_messagesUncheckedCreateWithoutUserInput>
  }

  export type chat_messagesCreateManyUserInputEnvelope = {
    data: chat_messagesCreateManyUserInput | chat_messagesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type game_movesCreateWithoutUserInput = {
    id: string
    player: $Enums.Player
    dice?: game_movesCreatediceInput | number[]
    move: string
    fromPoint?: number | null
    toPoint?: number | null
    equity?: number | null
    pr?: number | null
    thinkingTime?: number | null
    createdAt?: Date | string
    game: gamesCreateNestedOneWithoutGameMovesInput
  }

  export type game_movesUncheckedCreateWithoutUserInput = {
    id: string
    gameId: string
    player: $Enums.Player
    dice?: game_movesCreatediceInput | number[]
    move: string
    fromPoint?: number | null
    toPoint?: number | null
    equity?: number | null
    pr?: number | null
    thinkingTime?: number | null
    createdAt?: Date | string
  }

  export type game_movesCreateOrConnectWithoutUserInput = {
    where: game_movesWhereUniqueInput
    create: XOR<game_movesCreateWithoutUserInput, game_movesUncheckedCreateWithoutUserInput>
  }

  export type game_movesCreateManyUserInputEnvelope = {
    data: game_movesCreateManyUserInput | game_movesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type user_analyticsCreateWithoutUsersInput = {
    id: string
    date?: Date | string
    games_played?: number
    games_won?: number
    analyses_completed?: number
    time_played?: number
    avg_equity?: number
    elo_change?: number
    claude_requests_today?: number
    claude_requests_this_month?: number
    claude_quota_remaining?: number
    chatgpt_requests_today?: number
    chatgpt_requests_this_month?: number
    gurubot_requests_today?: number
    gurubot_requests_this_month?: number
    gurubot_quota_remaining?: number
    easybot_requests_today?: number
    createdAt?: Date | string
  }

  export type user_analyticsUncheckedCreateWithoutUsersInput = {
    id: string
    date?: Date | string
    games_played?: number
    games_won?: number
    analyses_completed?: number
    time_played?: number
    avg_equity?: number
    elo_change?: number
    claude_requests_today?: number
    claude_requests_this_month?: number
    claude_quota_remaining?: number
    chatgpt_requests_today?: number
    chatgpt_requests_this_month?: number
    gurubot_requests_today?: number
    gurubot_requests_this_month?: number
    gurubot_quota_remaining?: number
    easybot_requests_today?: number
    createdAt?: Date | string
  }

  export type user_analyticsCreateOrConnectWithoutUsersInput = {
    where: user_analyticsWhereUniqueInput
    create: XOR<user_analyticsCreateWithoutUsersInput, user_analyticsUncheckedCreateWithoutUsersInput>
  }

  export type user_analyticsCreateManyUsersInputEnvelope = {
    data: user_analyticsCreateManyUsersInput | user_analyticsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type game_analysesCreateWithoutUsersInput = {
    id?: string
    game_id: string
    analysis_report: JsonNullValueInput | InputJsonValue
    ai_services_used?: game_analysesCreateai_services_usedInput | string[]
    created_at?: Date | string
  }

  export type game_analysesUncheckedCreateWithoutUsersInput = {
    id?: string
    game_id: string
    analysis_report: JsonNullValueInput | InputJsonValue
    ai_services_used?: game_analysesCreateai_services_usedInput | string[]
    created_at?: Date | string
  }

  export type game_analysesCreateOrConnectWithoutUsersInput = {
    where: game_analysesWhereUniqueInput
    create: XOR<game_analysesCreateWithoutUsersInput, game_analysesUncheckedCreateWithoutUsersInput>
  }

  export type game_analysesCreateManyUsersInputEnvelope = {
    data: game_analysesCreateManyUsersInput | game_analysesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type subscriptionsCreateWithoutUsersInput = {
    id: string
    stripe_subscription_id?: string | null
    stripe_customer_id?: string | null
    plan: $Enums.SubscriptionPlan
    status: $Enums.SubscriptionStatus
    current_period_start?: Date | string | null
    current_period_end?: Date | string | null
    cancel_at_period_end?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type subscriptionsUncheckedCreateWithoutUsersInput = {
    id: string
    stripe_subscription_id?: string | null
    stripe_customer_id?: string | null
    plan: $Enums.SubscriptionPlan
    status: $Enums.SubscriptionStatus
    current_period_start?: Date | string | null
    current_period_end?: Date | string | null
    cancel_at_period_end?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type subscriptionsCreateOrConnectWithoutUsersInput = {
    where: subscriptionsWhereUniqueInput
    create: XOR<subscriptionsCreateWithoutUsersInput, subscriptionsUncheckedCreateWithoutUsersInput>
  }

  export type tournament_participantsCreateWithoutUsersInput = {
    id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
    tournaments: tournamentsCreateNestedOneWithoutParticipantsInput
    whiteMatches?: tournament_matchesCreateNestedManyWithoutWhiteInput
    blackMatches?: tournament_matchesCreateNestedManyWithoutBlackInput
    wonMatches?: tournament_matchesCreateNestedManyWithoutWinnerInput
  }

  export type tournament_participantsUncheckedCreateWithoutUsersInput = {
    id: string
    tournament_id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
    whiteMatches?: tournament_matchesUncheckedCreateNestedManyWithoutWhiteInput
    blackMatches?: tournament_matchesUncheckedCreateNestedManyWithoutBlackInput
    wonMatches?: tournament_matchesUncheckedCreateNestedManyWithoutWinnerInput
  }

  export type tournament_participantsCreateOrConnectWithoutUsersInput = {
    where: tournament_participantsWhereUniqueInput
    create: XOR<tournament_participantsCreateWithoutUsersInput, tournament_participantsUncheckedCreateWithoutUsersInput>
  }

  export type tournament_participantsCreateManyUsersInputEnvelope = {
    data: tournament_participantsCreateManyUsersInput | tournament_participantsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type tournamentsCreateWithoutCreatorInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    games?: gamesCreateNestedManyWithoutTournamentInput
    participants?: tournament_participantsCreateNestedManyWithoutTournamentsInput
    matches?: tournament_matchesCreateNestedManyWithoutTournamentInput
  }

  export type tournamentsUncheckedCreateWithoutCreatorInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    games?: gamesUncheckedCreateNestedManyWithoutTournamentInput
    participants?: tournament_participantsUncheckedCreateNestedManyWithoutTournamentsInput
    matches?: tournament_matchesUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type tournamentsCreateOrConnectWithoutCreatorInput = {
    where: tournamentsWhereUniqueInput
    create: XOR<tournamentsCreateWithoutCreatorInput, tournamentsUncheckedCreateWithoutCreatorInput>
  }

  export type tournamentsCreateManyCreatorInputEnvelope = {
    data: tournamentsCreateManyCreatorInput | tournamentsCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type websocket_connectionsCreateWithoutUserInput = {
    id: string
    connectionId: string
    connectedAt?: Date | string
    lastPing?: Date | string
    isActive?: boolean
    game?: gamesCreateNestedOneWithoutWebsocketConnectionsInput
  }

  export type websocket_connectionsUncheckedCreateWithoutUserInput = {
    id: string
    connectionId: string
    gameId?: string | null
    connectedAt?: Date | string
    lastPing?: Date | string
    isActive?: boolean
  }

  export type websocket_connectionsCreateOrConnectWithoutUserInput = {
    where: websocket_connectionsWhereUniqueInput
    create: XOR<websocket_connectionsCreateWithoutUserInput, websocket_connectionsUncheckedCreateWithoutUserInput>
  }

  export type websocket_connectionsCreateManyUserInputEnvelope = {
    data: websocket_connectionsCreateManyUserInput | websocket_connectionsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type gamesCreateWithoutWhitePlayerInput = {
    id: string
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesCreateNestedManyWithoutGameInput
    gameMoves?: game_movesCreateNestedManyWithoutGameInput
    tournament?: tournamentsCreateNestedOneWithoutGamesInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutGameInput
    blackPlayer?: usersCreateNestedOneWithoutBlackGamesInput
    match?: matchesCreateNestedOneWithoutGameInput
    tournamentMatch?: tournament_matchesCreateNestedOneWithoutGameInput
    sessions?: GameSessionCreateNestedManyWithoutGameInput
    events?: GameEventCreateNestedManyWithoutGameInput
  }

  export type gamesUncheckedCreateWithoutWhitePlayerInput = {
    id: string
    blackPlayerId?: string | null
    tournamentId?: string | null
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutGameInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutGameInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutGameInput
    match?: matchesUncheckedCreateNestedOneWithoutGameInput
    tournamentMatch?: tournament_matchesUncheckedCreateNestedOneWithoutGameInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    events?: GameEventUncheckedCreateNestedManyWithoutGameInput
  }

  export type gamesCreateOrConnectWithoutWhitePlayerInput = {
    where: gamesWhereUniqueInput
    create: XOR<gamesCreateWithoutWhitePlayerInput, gamesUncheckedCreateWithoutWhitePlayerInput>
  }

  export type gamesCreateManyWhitePlayerInputEnvelope = {
    data: gamesCreateManyWhitePlayerInput | gamesCreateManyWhitePlayerInput[]
    skipDuplicates?: boolean
  }

  export type gamesCreateWithoutBlackPlayerInput = {
    id: string
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesCreateNestedManyWithoutGameInput
    gameMoves?: game_movesCreateNestedManyWithoutGameInput
    tournament?: tournamentsCreateNestedOneWithoutGamesInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutGameInput
    whitePlayer: usersCreateNestedOneWithoutWhiteGamesInput
    match?: matchesCreateNestedOneWithoutGameInput
    tournamentMatch?: tournament_matchesCreateNestedOneWithoutGameInput
    sessions?: GameSessionCreateNestedManyWithoutGameInput
    events?: GameEventCreateNestedManyWithoutGameInput
  }

  export type gamesUncheckedCreateWithoutBlackPlayerInput = {
    id: string
    whitePlayerId: string
    tournamentId?: string | null
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutGameInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutGameInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutGameInput
    match?: matchesUncheckedCreateNestedOneWithoutGameInput
    tournamentMatch?: tournament_matchesUncheckedCreateNestedOneWithoutGameInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    events?: GameEventUncheckedCreateNestedManyWithoutGameInput
  }

  export type gamesCreateOrConnectWithoutBlackPlayerInput = {
    where: gamesWhereUniqueInput
    create: XOR<gamesCreateWithoutBlackPlayerInput, gamesUncheckedCreateWithoutBlackPlayerInput>
  }

  export type gamesCreateManyBlackPlayerInputEnvelope = {
    data: gamesCreateManyBlackPlayerInput | gamesCreateManyBlackPlayerInput[]
    skipDuplicates?: boolean
  }

  export type GameSessionCreateWithoutUserInput = {
    id?: string
    resumeTokenHash: string
    lastAckSequence?: number
    lastHeartbeatAt?: Date | string | null
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    game: gamesCreateNestedOneWithoutSessionsInput
  }

  export type GameSessionUncheckedCreateWithoutUserInput = {
    id?: string
    gameId: string
    resumeTokenHash: string
    lastAckSequence?: number
    lastHeartbeatAt?: Date | string | null
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GameSessionCreateOrConnectWithoutUserInput = {
    where: GameSessionWhereUniqueInput
    create: XOR<GameSessionCreateWithoutUserInput, GameSessionUncheckedCreateWithoutUserInput>
  }

  export type GameSessionCreateManyUserInputEnvelope = {
    data: GameSessionCreateManyUserInput | GameSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type user_season_statsCreateWithoutUserInput = {
    id?: string
    elo: number
    winrate: number
    gamesPlayed: number
    createdAt?: Date | string
    updatedAt?: Date | string
    season: seasonsCreateNestedOneWithoutSeasonStatsInput
  }

  export type user_season_statsUncheckedCreateWithoutUserInput = {
    id?: string
    seasonId: string
    elo: number
    winrate: number
    gamesPlayed: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_season_statsCreateOrConnectWithoutUserInput = {
    where: user_season_statsWhereUniqueInput
    create: XOR<user_season_statsCreateWithoutUserInput, user_season_statsUncheckedCreateWithoutUserInput>
  }

  export type user_season_statsCreateManyUserInputEnvelope = {
    data: user_season_statsCreateManyUserInput | user_season_statsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type season_leaderboardCreateWithoutUserInput = {
    id?: string
    rankGlobal: number
    rankCountry: number
    createdAt?: Date | string
    updatedAt?: Date | string
    season: seasonsCreateNestedOneWithoutLeaderboardsInput
  }

  export type season_leaderboardUncheckedCreateWithoutUserInput = {
    id?: string
    seasonId: string
    rankGlobal: number
    rankCountry: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type season_leaderboardCreateOrConnectWithoutUserInput = {
    where: season_leaderboardWhereUniqueInput
    create: XOR<season_leaderboardCreateWithoutUserInput, season_leaderboardUncheckedCreateWithoutUserInput>
  }

  export type season_leaderboardCreateManyUserInputEnvelope = {
    data: season_leaderboardCreateManyUserInput | season_leaderboardCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type user_quota_historyCreateWithoutUserInput = {
    id?: string
    quotaUsed: number
    timestamp?: Date | string
    season: seasonsCreateNestedOneWithoutQuotaHistoryInput
  }

  export type user_quota_historyUncheckedCreateWithoutUserInput = {
    id?: string
    seasonId: string
    quotaUsed: number
    timestamp?: Date | string
  }

  export type user_quota_historyCreateOrConnectWithoutUserInput = {
    where: user_quota_historyWhereUniqueInput
    create: XOR<user_quota_historyCreateWithoutUserInput, user_quota_historyUncheckedCreateWithoutUserInput>
  }

  export type user_quota_historyCreateManyUserInputEnvelope = {
    data: user_quota_historyCreateManyUserInput | user_quota_historyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type analysesUpsertWithWhereUniqueWithoutUserInput = {
    where: analysesWhereUniqueInput
    update: XOR<analysesUpdateWithoutUserInput, analysesUncheckedUpdateWithoutUserInput>
    create: XOR<analysesCreateWithoutUserInput, analysesUncheckedCreateWithoutUserInput>
  }

  export type analysesUpdateWithWhereUniqueWithoutUserInput = {
    where: analysesWhereUniqueInput
    data: XOR<analysesUpdateWithoutUserInput, analysesUncheckedUpdateWithoutUserInput>
  }

  export type analysesUpdateManyWithWhereWithoutUserInput = {
    where: analysesScalarWhereInput
    data: XOR<analysesUpdateManyMutationInput, analysesUncheckedUpdateManyWithoutUserInput>
  }

  export type analysesScalarWhereInput = {
    AND?: analysesScalarWhereInput | analysesScalarWhereInput[]
    OR?: analysesScalarWhereInput[]
    NOT?: analysesScalarWhereInput | analysesScalarWhereInput[]
    id?: StringFilter<"analyses"> | string
    userId?: StringFilter<"analyses"> | string
    boardState?: StringFilter<"analyses"> | string
    dice?: IntNullableListFilter<"analyses">
    move?: StringFilter<"analyses"> | string
    bestMove?: StringFilter<"analyses"> | string
    equity?: FloatFilter<"analyses"> | number
    pr?: FloatFilter<"analyses"> | number
    explanation?: StringFilter<"analyses"> | string
    alternatives?: JsonFilter<"analyses">
    analysisType?: EnumAnalysisTypeFilter<"analyses"> | $Enums.AnalysisType
    createdAt?: DateTimeFilter<"analyses"> | Date | string
  }

  export type AnalysisQuotaUpsertWithWhereUniqueWithoutUserInput = {
    where: AnalysisQuotaWhereUniqueInput
    update: XOR<AnalysisQuotaUpdateWithoutUserInput, AnalysisQuotaUncheckedUpdateWithoutUserInput>
    create: XOR<AnalysisQuotaCreateWithoutUserInput, AnalysisQuotaUncheckedCreateWithoutUserInput>
  }

  export type AnalysisQuotaUpdateWithWhereUniqueWithoutUserInput = {
    where: AnalysisQuotaWhereUniqueInput
    data: XOR<AnalysisQuotaUpdateWithoutUserInput, AnalysisQuotaUncheckedUpdateWithoutUserInput>
  }

  export type AnalysisQuotaUpdateManyWithWhereWithoutUserInput = {
    where: AnalysisQuotaScalarWhereInput
    data: XOR<AnalysisQuotaUpdateManyMutationInput, AnalysisQuotaUncheckedUpdateManyWithoutUserInput>
  }

  export type AnalysisQuotaScalarWhereInput = {
    AND?: AnalysisQuotaScalarWhereInput | AnalysisQuotaScalarWhereInput[]
    OR?: AnalysisQuotaScalarWhereInput[]
    NOT?: AnalysisQuotaScalarWhereInput | AnalysisQuotaScalarWhereInput[]
    id?: StringFilter<"AnalysisQuota"> | string
    userId?: StringFilter<"AnalysisQuota"> | string
    date?: DateTimeFilter<"AnalysisQuota"> | Date | string
    count?: IntFilter<"AnalysisQuota"> | number
    extraQuota?: IntFilter<"AnalysisQuota"> | number
    initialFree?: BoolFilter<"AnalysisQuota"> | boolean
  }

  export type IAQuotaUpsertWithoutUserInput = {
    update: XOR<IAQuotaUpdateWithoutUserInput, IAQuotaUncheckedUpdateWithoutUserInput>
    create: XOR<IAQuotaCreateWithoutUserInput, IAQuotaUncheckedCreateWithoutUserInput>
    where?: IAQuotaWhereInput
  }

  export type IAQuotaUpdateToOneWithWhereWithoutUserInput = {
    where?: IAQuotaWhereInput
    data: XOR<IAQuotaUpdateWithoutUserInput, IAQuotaUncheckedUpdateWithoutUserInput>
  }

  export type IAQuotaUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dailyQuota?: IntFieldUpdateOperationsInput | number
    premiumQuota?: IntFieldUpdateOperationsInput | number
    extrasUsed?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IAQuotaUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dailyQuota?: IntFieldUpdateOperationsInput | number
    premiumQuota?: IntFieldUpdateOperationsInput | number
    extrasUsed?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    tokenHash?: StringFilter<"UserSession"> | string
    jti?: StringFilter<"UserSession"> | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
  }

  export type chat_messagesUpsertWithWhereUniqueWithoutUserInput = {
    where: chat_messagesWhereUniqueInput
    update: XOR<chat_messagesUpdateWithoutUserInput, chat_messagesUncheckedUpdateWithoutUserInput>
    create: XOR<chat_messagesCreateWithoutUserInput, chat_messagesUncheckedCreateWithoutUserInput>
  }

  export type chat_messagesUpdateWithWhereUniqueWithoutUserInput = {
    where: chat_messagesWhereUniqueInput
    data: XOR<chat_messagesUpdateWithoutUserInput, chat_messagesUncheckedUpdateWithoutUserInput>
  }

  export type chat_messagesUpdateManyWithWhereWithoutUserInput = {
    where: chat_messagesScalarWhereInput
    data: XOR<chat_messagesUpdateManyMutationInput, chat_messagesUncheckedUpdateManyWithoutUserInput>
  }

  export type game_movesUpsertWithWhereUniqueWithoutUserInput = {
    where: game_movesWhereUniqueInput
    update: XOR<game_movesUpdateWithoutUserInput, game_movesUncheckedUpdateWithoutUserInput>
    create: XOR<game_movesCreateWithoutUserInput, game_movesUncheckedCreateWithoutUserInput>
  }

  export type game_movesUpdateWithWhereUniqueWithoutUserInput = {
    where: game_movesWhereUniqueInput
    data: XOR<game_movesUpdateWithoutUserInput, game_movesUncheckedUpdateWithoutUserInput>
  }

  export type game_movesUpdateManyWithWhereWithoutUserInput = {
    where: game_movesScalarWhereInput
    data: XOR<game_movesUpdateManyMutationInput, game_movesUncheckedUpdateManyWithoutUserInput>
  }

  export type user_analyticsUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_analyticsWhereUniqueInput
    update: XOR<user_analyticsUpdateWithoutUsersInput, user_analyticsUncheckedUpdateWithoutUsersInput>
    create: XOR<user_analyticsCreateWithoutUsersInput, user_analyticsUncheckedCreateWithoutUsersInput>
  }

  export type user_analyticsUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_analyticsWhereUniqueInput
    data: XOR<user_analyticsUpdateWithoutUsersInput, user_analyticsUncheckedUpdateWithoutUsersInput>
  }

  export type user_analyticsUpdateManyWithWhereWithoutUsersInput = {
    where: user_analyticsScalarWhereInput
    data: XOR<user_analyticsUpdateManyMutationInput, user_analyticsUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_analyticsScalarWhereInput = {
    AND?: user_analyticsScalarWhereInput | user_analyticsScalarWhereInput[]
    OR?: user_analyticsScalarWhereInput[]
    NOT?: user_analyticsScalarWhereInput | user_analyticsScalarWhereInput[]
    id?: StringFilter<"user_analytics"> | string
    user_id?: StringFilter<"user_analytics"> | string
    date?: DateTimeFilter<"user_analytics"> | Date | string
    games_played?: IntFilter<"user_analytics"> | number
    games_won?: IntFilter<"user_analytics"> | number
    analyses_completed?: IntFilter<"user_analytics"> | number
    time_played?: IntFilter<"user_analytics"> | number
    avg_equity?: FloatFilter<"user_analytics"> | number
    elo_change?: IntFilter<"user_analytics"> | number
    claude_requests_today?: IntFilter<"user_analytics"> | number
    claude_requests_this_month?: IntFilter<"user_analytics"> | number
    claude_quota_remaining?: IntFilter<"user_analytics"> | number
    chatgpt_requests_today?: IntFilter<"user_analytics"> | number
    chatgpt_requests_this_month?: IntFilter<"user_analytics"> | number
    gurubot_requests_today?: IntFilter<"user_analytics"> | number
    gurubot_requests_this_month?: IntFilter<"user_analytics"> | number
    gurubot_quota_remaining?: IntFilter<"user_analytics"> | number
    easybot_requests_today?: IntFilter<"user_analytics"> | number
    createdAt?: DateTimeFilter<"user_analytics"> | Date | string
  }

  export type game_analysesUpsertWithWhereUniqueWithoutUsersInput = {
    where: game_analysesWhereUniqueInput
    update: XOR<game_analysesUpdateWithoutUsersInput, game_analysesUncheckedUpdateWithoutUsersInput>
    create: XOR<game_analysesCreateWithoutUsersInput, game_analysesUncheckedCreateWithoutUsersInput>
  }

  export type game_analysesUpdateWithWhereUniqueWithoutUsersInput = {
    where: game_analysesWhereUniqueInput
    data: XOR<game_analysesUpdateWithoutUsersInput, game_analysesUncheckedUpdateWithoutUsersInput>
  }

  export type game_analysesUpdateManyWithWhereWithoutUsersInput = {
    where: game_analysesScalarWhereInput
    data: XOR<game_analysesUpdateManyMutationInput, game_analysesUncheckedUpdateManyWithoutUsersInput>
  }

  export type game_analysesScalarWhereInput = {
    AND?: game_analysesScalarWhereInput | game_analysesScalarWhereInput[]
    OR?: game_analysesScalarWhereInput[]
    NOT?: game_analysesScalarWhereInput | game_analysesScalarWhereInput[]
    id?: StringFilter<"game_analyses"> | string
    user_id?: StringFilter<"game_analyses"> | string
    game_id?: StringFilter<"game_analyses"> | string
    analysis_report?: JsonFilter<"game_analyses">
    ai_services_used?: StringNullableListFilter<"game_analyses">
    created_at?: DateTimeFilter<"game_analyses"> | Date | string
  }

  export type subscriptionsUpsertWithoutUsersInput = {
    update: XOR<subscriptionsUpdateWithoutUsersInput, subscriptionsUncheckedUpdateWithoutUsersInput>
    create: XOR<subscriptionsCreateWithoutUsersInput, subscriptionsUncheckedCreateWithoutUsersInput>
    where?: subscriptionsWhereInput
  }

  export type subscriptionsUpdateToOneWithWhereWithoutUsersInput = {
    where?: subscriptionsWhereInput
    data: XOR<subscriptionsUpdateWithoutUsersInput, subscriptionsUncheckedUpdateWithoutUsersInput>
  }

  export type subscriptionsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    current_period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    current_period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournament_participantsUpsertWithWhereUniqueWithoutUsersInput = {
    where: tournament_participantsWhereUniqueInput
    update: XOR<tournament_participantsUpdateWithoutUsersInput, tournament_participantsUncheckedUpdateWithoutUsersInput>
    create: XOR<tournament_participantsCreateWithoutUsersInput, tournament_participantsUncheckedCreateWithoutUsersInput>
  }

  export type tournament_participantsUpdateWithWhereUniqueWithoutUsersInput = {
    where: tournament_participantsWhereUniqueInput
    data: XOR<tournament_participantsUpdateWithoutUsersInput, tournament_participantsUncheckedUpdateWithoutUsersInput>
  }

  export type tournament_participantsUpdateManyWithWhereWithoutUsersInput = {
    where: tournament_participantsScalarWhereInput
    data: XOR<tournament_participantsUpdateManyMutationInput, tournament_participantsUncheckedUpdateManyWithoutUsersInput>
  }

  export type tournamentsUpsertWithWhereUniqueWithoutCreatorInput = {
    where: tournamentsWhereUniqueInput
    update: XOR<tournamentsUpdateWithoutCreatorInput, tournamentsUncheckedUpdateWithoutCreatorInput>
    create: XOR<tournamentsCreateWithoutCreatorInput, tournamentsUncheckedCreateWithoutCreatorInput>
  }

  export type tournamentsUpdateWithWhereUniqueWithoutCreatorInput = {
    where: tournamentsWhereUniqueInput
    data: XOR<tournamentsUpdateWithoutCreatorInput, tournamentsUncheckedUpdateWithoutCreatorInput>
  }

  export type tournamentsUpdateManyWithWhereWithoutCreatorInput = {
    where: tournamentsScalarWhereInput
    data: XOR<tournamentsUpdateManyMutationInput, tournamentsUncheckedUpdateManyWithoutCreatorInput>
  }

  export type tournamentsScalarWhereInput = {
    AND?: tournamentsScalarWhereInput | tournamentsScalarWhereInput[]
    OR?: tournamentsScalarWhereInput[]
    NOT?: tournamentsScalarWhereInput | tournamentsScalarWhereInput[]
    id?: StringFilter<"tournaments"> | string
    name?: StringFilter<"tournaments"> | string
    description?: StringNullableFilter<"tournaments"> | string | null
    entryFee?: IntFilter<"tournaments"> | number
    prizePool?: IntFilter<"tournaments"> | number
    maxPlayers?: IntNullableFilter<"tournaments"> | number | null
    status?: EnumTournamentStatusFilter<"tournaments"> | $Enums.TournamentStatus
    startTime?: DateTimeNullableFilter<"tournaments"> | Date | string | null
    endTime?: DateTimeNullableFilter<"tournaments"> | Date | string | null
    createdBy?: StringFilter<"tournaments"> | string
    createdAt?: DateTimeFilter<"tournaments"> | Date | string
  }

  export type websocket_connectionsUpsertWithWhereUniqueWithoutUserInput = {
    where: websocket_connectionsWhereUniqueInput
    update: XOR<websocket_connectionsUpdateWithoutUserInput, websocket_connectionsUncheckedUpdateWithoutUserInput>
    create: XOR<websocket_connectionsCreateWithoutUserInput, websocket_connectionsUncheckedCreateWithoutUserInput>
  }

  export type websocket_connectionsUpdateWithWhereUniqueWithoutUserInput = {
    where: websocket_connectionsWhereUniqueInput
    data: XOR<websocket_connectionsUpdateWithoutUserInput, websocket_connectionsUncheckedUpdateWithoutUserInput>
  }

  export type websocket_connectionsUpdateManyWithWhereWithoutUserInput = {
    where: websocket_connectionsScalarWhereInput
    data: XOR<websocket_connectionsUpdateManyMutationInput, websocket_connectionsUncheckedUpdateManyWithoutUserInput>
  }

  export type gamesUpsertWithWhereUniqueWithoutWhitePlayerInput = {
    where: gamesWhereUniqueInput
    update: XOR<gamesUpdateWithoutWhitePlayerInput, gamesUncheckedUpdateWithoutWhitePlayerInput>
    create: XOR<gamesCreateWithoutWhitePlayerInput, gamesUncheckedCreateWithoutWhitePlayerInput>
  }

  export type gamesUpdateWithWhereUniqueWithoutWhitePlayerInput = {
    where: gamesWhereUniqueInput
    data: XOR<gamesUpdateWithoutWhitePlayerInput, gamesUncheckedUpdateWithoutWhitePlayerInput>
  }

  export type gamesUpdateManyWithWhereWithoutWhitePlayerInput = {
    where: gamesScalarWhereInput
    data: XOR<gamesUpdateManyMutationInput, gamesUncheckedUpdateManyWithoutWhitePlayerInput>
  }

  export type gamesUpsertWithWhereUniqueWithoutBlackPlayerInput = {
    where: gamesWhereUniqueInput
    update: XOR<gamesUpdateWithoutBlackPlayerInput, gamesUncheckedUpdateWithoutBlackPlayerInput>
    create: XOR<gamesCreateWithoutBlackPlayerInput, gamesUncheckedCreateWithoutBlackPlayerInput>
  }

  export type gamesUpdateWithWhereUniqueWithoutBlackPlayerInput = {
    where: gamesWhereUniqueInput
    data: XOR<gamesUpdateWithoutBlackPlayerInput, gamesUncheckedUpdateWithoutBlackPlayerInput>
  }

  export type gamesUpdateManyWithWhereWithoutBlackPlayerInput = {
    where: gamesScalarWhereInput
    data: XOR<gamesUpdateManyMutationInput, gamesUncheckedUpdateManyWithoutBlackPlayerInput>
  }

  export type GameSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: GameSessionWhereUniqueInput
    update: XOR<GameSessionUpdateWithoutUserInput, GameSessionUncheckedUpdateWithoutUserInput>
    create: XOR<GameSessionCreateWithoutUserInput, GameSessionUncheckedCreateWithoutUserInput>
  }

  export type GameSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: GameSessionWhereUniqueInput
    data: XOR<GameSessionUpdateWithoutUserInput, GameSessionUncheckedUpdateWithoutUserInput>
  }

  export type GameSessionUpdateManyWithWhereWithoutUserInput = {
    where: GameSessionScalarWhereInput
    data: XOR<GameSessionUpdateManyMutationInput, GameSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type user_season_statsUpsertWithWhereUniqueWithoutUserInput = {
    where: user_season_statsWhereUniqueInput
    update: XOR<user_season_statsUpdateWithoutUserInput, user_season_statsUncheckedUpdateWithoutUserInput>
    create: XOR<user_season_statsCreateWithoutUserInput, user_season_statsUncheckedCreateWithoutUserInput>
  }

  export type user_season_statsUpdateWithWhereUniqueWithoutUserInput = {
    where: user_season_statsWhereUniqueInput
    data: XOR<user_season_statsUpdateWithoutUserInput, user_season_statsUncheckedUpdateWithoutUserInput>
  }

  export type user_season_statsUpdateManyWithWhereWithoutUserInput = {
    where: user_season_statsScalarWhereInput
    data: XOR<user_season_statsUpdateManyMutationInput, user_season_statsUncheckedUpdateManyWithoutUserInput>
  }

  export type user_season_statsScalarWhereInput = {
    AND?: user_season_statsScalarWhereInput | user_season_statsScalarWhereInput[]
    OR?: user_season_statsScalarWhereInput[]
    NOT?: user_season_statsScalarWhereInput | user_season_statsScalarWhereInput[]
    id?: StringFilter<"user_season_stats"> | string
    userId?: StringFilter<"user_season_stats"> | string
    seasonId?: StringFilter<"user_season_stats"> | string
    elo?: IntFilter<"user_season_stats"> | number
    winrate?: FloatFilter<"user_season_stats"> | number
    gamesPlayed?: IntFilter<"user_season_stats"> | number
    createdAt?: DateTimeFilter<"user_season_stats"> | Date | string
    updatedAt?: DateTimeFilter<"user_season_stats"> | Date | string
  }

  export type season_leaderboardUpsertWithWhereUniqueWithoutUserInput = {
    where: season_leaderboardWhereUniqueInput
    update: XOR<season_leaderboardUpdateWithoutUserInput, season_leaderboardUncheckedUpdateWithoutUserInput>
    create: XOR<season_leaderboardCreateWithoutUserInput, season_leaderboardUncheckedCreateWithoutUserInput>
  }

  export type season_leaderboardUpdateWithWhereUniqueWithoutUserInput = {
    where: season_leaderboardWhereUniqueInput
    data: XOR<season_leaderboardUpdateWithoutUserInput, season_leaderboardUncheckedUpdateWithoutUserInput>
  }

  export type season_leaderboardUpdateManyWithWhereWithoutUserInput = {
    where: season_leaderboardScalarWhereInput
    data: XOR<season_leaderboardUpdateManyMutationInput, season_leaderboardUncheckedUpdateManyWithoutUserInput>
  }

  export type season_leaderboardScalarWhereInput = {
    AND?: season_leaderboardScalarWhereInput | season_leaderboardScalarWhereInput[]
    OR?: season_leaderboardScalarWhereInput[]
    NOT?: season_leaderboardScalarWhereInput | season_leaderboardScalarWhereInput[]
    id?: StringFilter<"season_leaderboard"> | string
    seasonId?: StringFilter<"season_leaderboard"> | string
    userId?: StringFilter<"season_leaderboard"> | string
    rankGlobal?: IntFilter<"season_leaderboard"> | number
    rankCountry?: IntFilter<"season_leaderboard"> | number
    createdAt?: DateTimeFilter<"season_leaderboard"> | Date | string
    updatedAt?: DateTimeFilter<"season_leaderboard"> | Date | string
  }

  export type user_quota_historyUpsertWithWhereUniqueWithoutUserInput = {
    where: user_quota_historyWhereUniqueInput
    update: XOR<user_quota_historyUpdateWithoutUserInput, user_quota_historyUncheckedUpdateWithoutUserInput>
    create: XOR<user_quota_historyCreateWithoutUserInput, user_quota_historyUncheckedCreateWithoutUserInput>
  }

  export type user_quota_historyUpdateWithWhereUniqueWithoutUserInput = {
    where: user_quota_historyWhereUniqueInput
    data: XOR<user_quota_historyUpdateWithoutUserInput, user_quota_historyUncheckedUpdateWithoutUserInput>
  }

  export type user_quota_historyUpdateManyWithWhereWithoutUserInput = {
    where: user_quota_historyScalarWhereInput
    data: XOR<user_quota_historyUpdateManyMutationInput, user_quota_historyUncheckedUpdateManyWithoutUserInput>
  }

  export type user_quota_historyScalarWhereInput = {
    AND?: user_quota_historyScalarWhereInput | user_quota_historyScalarWhereInput[]
    OR?: user_quota_historyScalarWhereInput[]
    NOT?: user_quota_historyScalarWhereInput | user_quota_historyScalarWhereInput[]
    id?: StringFilter<"user_quota_history"> | string
    userId?: StringFilter<"user_quota_history"> | string
    seasonId?: StringFilter<"user_quota_history"> | string
    quotaUsed?: IntFilter<"user_quota_history"> | number
    timestamp?: DateTimeFilter<"user_quota_history"> | Date | string
  }

  export type user_season_statsCreateWithoutSeasonInput = {
    id?: string
    elo: number
    winrate: number
    gamesPlayed: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutSeasonStatsInput
  }

  export type user_season_statsUncheckedCreateWithoutSeasonInput = {
    id?: string
    userId: string
    elo: number
    winrate: number
    gamesPlayed: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_season_statsCreateOrConnectWithoutSeasonInput = {
    where: user_season_statsWhereUniqueInput
    create: XOR<user_season_statsCreateWithoutSeasonInput, user_season_statsUncheckedCreateWithoutSeasonInput>
  }

  export type user_season_statsCreateManySeasonInputEnvelope = {
    data: user_season_statsCreateManySeasonInput | user_season_statsCreateManySeasonInput[]
    skipDuplicates?: boolean
  }

  export type season_leaderboardCreateWithoutSeasonInput = {
    id?: string
    rankGlobal: number
    rankCountry: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutSeasonLeaderboardsInput
  }

  export type season_leaderboardUncheckedCreateWithoutSeasonInput = {
    id?: string
    userId: string
    rankGlobal: number
    rankCountry: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type season_leaderboardCreateOrConnectWithoutSeasonInput = {
    where: season_leaderboardWhereUniqueInput
    create: XOR<season_leaderboardCreateWithoutSeasonInput, season_leaderboardUncheckedCreateWithoutSeasonInput>
  }

  export type season_leaderboardCreateManySeasonInputEnvelope = {
    data: season_leaderboardCreateManySeasonInput | season_leaderboardCreateManySeasonInput[]
    skipDuplicates?: boolean
  }

  export type user_quota_historyCreateWithoutSeasonInput = {
    id?: string
    quotaUsed: number
    timestamp?: Date | string
    user: usersCreateNestedOneWithoutQuotaHistoryInput
  }

  export type user_quota_historyUncheckedCreateWithoutSeasonInput = {
    id?: string
    userId: string
    quotaUsed: number
    timestamp?: Date | string
  }

  export type user_quota_historyCreateOrConnectWithoutSeasonInput = {
    where: user_quota_historyWhereUniqueInput
    create: XOR<user_quota_historyCreateWithoutSeasonInput, user_quota_historyUncheckedCreateWithoutSeasonInput>
  }

  export type user_quota_historyCreateManySeasonInputEnvelope = {
    data: user_quota_historyCreateManySeasonInput | user_quota_historyCreateManySeasonInput[]
    skipDuplicates?: boolean
  }

  export type user_season_statsUpsertWithWhereUniqueWithoutSeasonInput = {
    where: user_season_statsWhereUniqueInput
    update: XOR<user_season_statsUpdateWithoutSeasonInput, user_season_statsUncheckedUpdateWithoutSeasonInput>
    create: XOR<user_season_statsCreateWithoutSeasonInput, user_season_statsUncheckedCreateWithoutSeasonInput>
  }

  export type user_season_statsUpdateWithWhereUniqueWithoutSeasonInput = {
    where: user_season_statsWhereUniqueInput
    data: XOR<user_season_statsUpdateWithoutSeasonInput, user_season_statsUncheckedUpdateWithoutSeasonInput>
  }

  export type user_season_statsUpdateManyWithWhereWithoutSeasonInput = {
    where: user_season_statsScalarWhereInput
    data: XOR<user_season_statsUpdateManyMutationInput, user_season_statsUncheckedUpdateManyWithoutSeasonInput>
  }

  export type season_leaderboardUpsertWithWhereUniqueWithoutSeasonInput = {
    where: season_leaderboardWhereUniqueInput
    update: XOR<season_leaderboardUpdateWithoutSeasonInput, season_leaderboardUncheckedUpdateWithoutSeasonInput>
    create: XOR<season_leaderboardCreateWithoutSeasonInput, season_leaderboardUncheckedCreateWithoutSeasonInput>
  }

  export type season_leaderboardUpdateWithWhereUniqueWithoutSeasonInput = {
    where: season_leaderboardWhereUniqueInput
    data: XOR<season_leaderboardUpdateWithoutSeasonInput, season_leaderboardUncheckedUpdateWithoutSeasonInput>
  }

  export type season_leaderboardUpdateManyWithWhereWithoutSeasonInput = {
    where: season_leaderboardScalarWhereInput
    data: XOR<season_leaderboardUpdateManyMutationInput, season_leaderboardUncheckedUpdateManyWithoutSeasonInput>
  }

  export type user_quota_historyUpsertWithWhereUniqueWithoutSeasonInput = {
    where: user_quota_historyWhereUniqueInput
    update: XOR<user_quota_historyUpdateWithoutSeasonInput, user_quota_historyUncheckedUpdateWithoutSeasonInput>
    create: XOR<user_quota_historyCreateWithoutSeasonInput, user_quota_historyUncheckedCreateWithoutSeasonInput>
  }

  export type user_quota_historyUpdateWithWhereUniqueWithoutSeasonInput = {
    where: user_quota_historyWhereUniqueInput
    data: XOR<user_quota_historyUpdateWithoutSeasonInput, user_quota_historyUncheckedUpdateWithoutSeasonInput>
  }

  export type user_quota_historyUpdateManyWithWhereWithoutSeasonInput = {
    where: user_quota_historyScalarWhereInput
    data: XOR<user_quota_historyUpdateManyMutationInput, user_quota_historyUncheckedUpdateManyWithoutSeasonInput>
  }

  export type usersCreateWithoutSeasonStatsInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesCreateNestedManyWithoutUserInput
    gameMoves?: game_movesCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutUserInput
    whiteGames?: gamesCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutSeasonStatsInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaUncheckedCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutUserInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesUncheckedCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutUserInput
    whiteGames?: gamesUncheckedCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesUncheckedCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutSeasonStatsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSeasonStatsInput, usersUncheckedCreateWithoutSeasonStatsInput>
  }

  export type seasonsCreateWithoutSeasonStatsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaderboards?: season_leaderboardCreateNestedManyWithoutSeasonInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutSeasonInput
  }

  export type seasonsUncheckedCreateWithoutSeasonStatsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutSeasonInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type seasonsCreateOrConnectWithoutSeasonStatsInput = {
    where: seasonsWhereUniqueInput
    create: XOR<seasonsCreateWithoutSeasonStatsInput, seasonsUncheckedCreateWithoutSeasonStatsInput>
  }

  export type usersUpsertWithoutSeasonStatsInput = {
    update: XOR<usersUpdateWithoutSeasonStatsInput, usersUncheckedUpdateWithoutSeasonStatsInput>
    create: XOR<usersCreateWithoutSeasonStatsInput, usersUncheckedCreateWithoutSeasonStatsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSeasonStatsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSeasonStatsInput, usersUncheckedUpdateWithoutSeasonStatsInput>
  }

  export type usersUpdateWithoutSeasonStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutSeasonStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUncheckedUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUncheckedUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUncheckedUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUncheckedUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUncheckedUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type seasonsUpsertWithoutSeasonStatsInput = {
    update: XOR<seasonsUpdateWithoutSeasonStatsInput, seasonsUncheckedUpdateWithoutSeasonStatsInput>
    create: XOR<seasonsCreateWithoutSeasonStatsInput, seasonsUncheckedCreateWithoutSeasonStatsInput>
    where?: seasonsWhereInput
  }

  export type seasonsUpdateToOneWithWhereWithoutSeasonStatsInput = {
    where?: seasonsWhereInput
    data: XOR<seasonsUpdateWithoutSeasonStatsInput, seasonsUncheckedUpdateWithoutSeasonStatsInput>
  }

  export type seasonsUpdateWithoutSeasonStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaderboards?: season_leaderboardUpdateManyWithoutSeasonNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutSeasonNestedInput
  }

  export type seasonsUncheckedUpdateWithoutSeasonStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaderboards?: season_leaderboardUncheckedUpdateManyWithoutSeasonNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type usersCreateWithoutSeasonLeaderboardsInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesCreateNestedManyWithoutUserInput
    gameMoves?: game_movesCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutUserInput
    whiteGames?: gamesCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutSeasonLeaderboardsInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaUncheckedCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutUserInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesUncheckedCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutUserInput
    whiteGames?: gamesUncheckedCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesUncheckedCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutSeasonLeaderboardsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSeasonLeaderboardsInput, usersUncheckedCreateWithoutSeasonLeaderboardsInput>
  }

  export type seasonsCreateWithoutLeaderboardsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonStats?: user_season_statsCreateNestedManyWithoutSeasonInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutSeasonInput
  }

  export type seasonsUncheckedCreateWithoutLeaderboardsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutSeasonInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type seasonsCreateOrConnectWithoutLeaderboardsInput = {
    where: seasonsWhereUniqueInput
    create: XOR<seasonsCreateWithoutLeaderboardsInput, seasonsUncheckedCreateWithoutLeaderboardsInput>
  }

  export type usersUpsertWithoutSeasonLeaderboardsInput = {
    update: XOR<usersUpdateWithoutSeasonLeaderboardsInput, usersUncheckedUpdateWithoutSeasonLeaderboardsInput>
    create: XOR<usersCreateWithoutSeasonLeaderboardsInput, usersUncheckedCreateWithoutSeasonLeaderboardsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSeasonLeaderboardsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSeasonLeaderboardsInput, usersUncheckedUpdateWithoutSeasonLeaderboardsInput>
  }

  export type usersUpdateWithoutSeasonLeaderboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutSeasonLeaderboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUncheckedUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUncheckedUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUncheckedUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUncheckedUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type seasonsUpsertWithoutLeaderboardsInput = {
    update: XOR<seasonsUpdateWithoutLeaderboardsInput, seasonsUncheckedUpdateWithoutLeaderboardsInput>
    create: XOR<seasonsCreateWithoutLeaderboardsInput, seasonsUncheckedCreateWithoutLeaderboardsInput>
    where?: seasonsWhereInput
  }

  export type seasonsUpdateToOneWithWhereWithoutLeaderboardsInput = {
    where?: seasonsWhereInput
    data: XOR<seasonsUpdateWithoutLeaderboardsInput, seasonsUncheckedUpdateWithoutLeaderboardsInput>
  }

  export type seasonsUpdateWithoutLeaderboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonStats?: user_season_statsUpdateManyWithoutSeasonNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutSeasonNestedInput
  }

  export type seasonsUncheckedUpdateWithoutLeaderboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutSeasonNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type usersCreateWithoutQuotaHistoryInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesCreateNestedManyWithoutUserInput
    gameMoves?: game_movesCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsCreateNestedManyWithoutUserInput
    whiteGames?: gamesCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutQuotaHistoryInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaUncheckedCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutUserInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesUncheckedCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutCreatorInput
    websocketConnections?: websocket_connectionsUncheckedCreateNestedManyWithoutUserInput
    whiteGames?: gamesUncheckedCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesUncheckedCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutQuotaHistoryInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutQuotaHistoryInput, usersUncheckedCreateWithoutQuotaHistoryInput>
  }

  export type seasonsCreateWithoutQuotaHistoryInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonStats?: user_season_statsCreateNestedManyWithoutSeasonInput
    leaderboards?: season_leaderboardCreateNestedManyWithoutSeasonInput
  }

  export type seasonsUncheckedCreateWithoutQuotaHistoryInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutSeasonInput
    leaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type seasonsCreateOrConnectWithoutQuotaHistoryInput = {
    where: seasonsWhereUniqueInput
    create: XOR<seasonsCreateWithoutQuotaHistoryInput, seasonsUncheckedCreateWithoutQuotaHistoryInput>
  }

  export type usersUpsertWithoutQuotaHistoryInput = {
    update: XOR<usersUpdateWithoutQuotaHistoryInput, usersUncheckedUpdateWithoutQuotaHistoryInput>
    create: XOR<usersCreateWithoutQuotaHistoryInput, usersUncheckedCreateWithoutQuotaHistoryInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutQuotaHistoryInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutQuotaHistoryInput, usersUncheckedUpdateWithoutQuotaHistoryInput>
  }

  export type usersUpdateWithoutQuotaHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutQuotaHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUncheckedUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUncheckedUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutCreatorNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutUserNestedInput
    whiteGames?: gamesUncheckedUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUncheckedUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type seasonsUpsertWithoutQuotaHistoryInput = {
    update: XOR<seasonsUpdateWithoutQuotaHistoryInput, seasonsUncheckedUpdateWithoutQuotaHistoryInput>
    create: XOR<seasonsCreateWithoutQuotaHistoryInput, seasonsUncheckedCreateWithoutQuotaHistoryInput>
    where?: seasonsWhereInput
  }

  export type seasonsUpdateToOneWithWhereWithoutQuotaHistoryInput = {
    where?: seasonsWhereInput
    data: XOR<seasonsUpdateWithoutQuotaHistoryInput, seasonsUncheckedUpdateWithoutQuotaHistoryInput>
  }

  export type seasonsUpdateWithoutQuotaHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonStats?: user_season_statsUpdateManyWithoutSeasonNestedInput
    leaderboards?: season_leaderboardUpdateManyWithoutSeasonNestedInput
  }

  export type seasonsUncheckedUpdateWithoutQuotaHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutSeasonNestedInput
    leaderboards?: season_leaderboardUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type gamesCreateWithoutWebsocketConnectionsInput = {
    id: string
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesCreateNestedManyWithoutGameInput
    gameMoves?: game_movesCreateNestedManyWithoutGameInput
    tournament?: tournamentsCreateNestedOneWithoutGamesInput
    whitePlayer: usersCreateNestedOneWithoutWhiteGamesInput
    blackPlayer?: usersCreateNestedOneWithoutBlackGamesInput
    match?: matchesCreateNestedOneWithoutGameInput
    tournamentMatch?: tournament_matchesCreateNestedOneWithoutGameInput
    sessions?: GameSessionCreateNestedManyWithoutGameInput
    events?: GameEventCreateNestedManyWithoutGameInput
  }

  export type gamesUncheckedCreateWithoutWebsocketConnectionsInput = {
    id: string
    whitePlayerId: string
    blackPlayerId?: string | null
    tournamentId?: string | null
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutGameInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutGameInput
    match?: matchesUncheckedCreateNestedOneWithoutGameInput
    tournamentMatch?: tournament_matchesUncheckedCreateNestedOneWithoutGameInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    events?: GameEventUncheckedCreateNestedManyWithoutGameInput
  }

  export type gamesCreateOrConnectWithoutWebsocketConnectionsInput = {
    where: gamesWhereUniqueInput
    create: XOR<gamesCreateWithoutWebsocketConnectionsInput, gamesUncheckedCreateWithoutWebsocketConnectionsInput>
  }

  export type usersCreateWithoutWebsocketConnectionsInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesCreateNestedManyWithoutUserInput
    gameMoves?: game_movesCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutCreatorInput
    whiteGames?: gamesCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutWebsocketConnectionsInput = {
    id: string
    email: string
    password: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    country?: string | null
    eloRating?: number
    gamesPlayed?: number
    gamesWon?: number
    winRate?: number
    currentStreak?: number
    bestStreak?: number
    subscriptionType?: $Enums.SubscriptionType
    subscriptionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUserInput
    analysisQuotas?: AnalysisQuotaUncheckedCreateNestedManyWithoutUserInput
    iaQuota?: IAQuotaUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: chat_messagesUncheckedCreateNestedManyWithoutUserInput
    gameMoves?: game_movesUncheckedCreateNestedManyWithoutUserInput
    userAnalytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    gameAnalyses?: game_analysesUncheckedCreateNestedManyWithoutUsersInput
    subscription?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournamentParticipants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutCreatorInput
    whiteGames?: gamesUncheckedCreateNestedManyWithoutWhitePlayerInput
    blackGames?: gamesUncheckedCreateNestedManyWithoutBlackPlayerInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    seasonStats?: user_season_statsUncheckedCreateNestedManyWithoutUserInput
    seasonLeaderboards?: season_leaderboardUncheckedCreateNestedManyWithoutUserInput
    quotaHistory?: user_quota_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutWebsocketConnectionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutWebsocketConnectionsInput, usersUncheckedCreateWithoutWebsocketConnectionsInput>
  }

  export type gamesUpsertWithoutWebsocketConnectionsInput = {
    update: XOR<gamesUpdateWithoutWebsocketConnectionsInput, gamesUncheckedUpdateWithoutWebsocketConnectionsInput>
    create: XOR<gamesCreateWithoutWebsocketConnectionsInput, gamesUncheckedCreateWithoutWebsocketConnectionsInput>
    where?: gamesWhereInput
  }

  export type gamesUpdateToOneWithWhereWithoutWebsocketConnectionsInput = {
    where?: gamesWhereInput
    data: XOR<gamesUpdateWithoutWebsocketConnectionsInput, gamesUncheckedUpdateWithoutWebsocketConnectionsInput>
  }

  export type gamesUpdateWithoutWebsocketConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUpdateManyWithoutGameNestedInput
    gameMoves?: game_movesUpdateManyWithoutGameNestedInput
    tournament?: tournamentsUpdateOneWithoutGamesNestedInput
    whitePlayer?: usersUpdateOneRequiredWithoutWhiteGamesNestedInput
    blackPlayer?: usersUpdateOneWithoutBlackGamesNestedInput
    match?: matchesUpdateOneWithoutGameNestedInput
    tournamentMatch?: tournament_matchesUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUpdateManyWithoutGameNestedInput
    events?: GameEventUpdateManyWithoutGameNestedInput
  }

  export type gamesUncheckedUpdateWithoutWebsocketConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    whitePlayerId?: StringFieldUpdateOperationsInput | string
    blackPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutGameNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutGameNestedInput
    match?: matchesUncheckedUpdateOneWithoutGameNestedInput
    tournamentMatch?: tournament_matchesUncheckedUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    events?: GameEventUncheckedUpdateManyWithoutGameNestedInput
  }

  export type usersUpsertWithoutWebsocketConnectionsInput = {
    update: XOR<usersUpdateWithoutWebsocketConnectionsInput, usersUncheckedUpdateWithoutWebsocketConnectionsInput>
    create: XOR<usersCreateWithoutWebsocketConnectionsInput, usersUncheckedCreateWithoutWebsocketConnectionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutWebsocketConnectionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutWebsocketConnectionsInput, usersUncheckedUpdateWithoutWebsocketConnectionsInput>
  }

  export type usersUpdateWithoutWebsocketConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutCreatorNestedInput
    whiteGames?: gamesUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutWebsocketConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    eloRating?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesWon?: IntFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUserNestedInput
    analysisQuotas?: AnalysisQuotaUncheckedUpdateManyWithoutUserNestedInput
    iaQuota?: IAQuotaUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutUserNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutUserNestedInput
    userAnalytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    gameAnalyses?: game_analysesUncheckedUpdateManyWithoutUsersNestedInput
    subscription?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournamentParticipants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutCreatorNestedInput
    whiteGames?: gamesUncheckedUpdateManyWithoutWhitePlayerNestedInput
    blackGames?: gamesUncheckedUpdateManyWithoutBlackPlayerNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    seasonStats?: user_season_statsUncheckedUpdateManyWithoutUserNestedInput
    seasonLeaderboards?: season_leaderboardUncheckedUpdateManyWithoutUserNestedInput
    quotaHistory?: user_quota_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type tournament_matchesCreateManyWhiteInput = {
    id?: string
    tournamentId: string
    round: number
    matchNumber: number
    blackParticipantId?: string | null
    winnerParticipantId?: string | null
    status?: $Enums.TournamentMatchStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    gameId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tournament_matchesCreateManyBlackInput = {
    id?: string
    tournamentId: string
    round: number
    matchNumber: number
    whiteParticipantId?: string | null
    winnerParticipantId?: string | null
    status?: $Enums.TournamentMatchStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    gameId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tournament_matchesCreateManyWinnerInput = {
    id?: string
    tournamentId: string
    round: number
    matchNumber: number
    whiteParticipantId?: string | null
    blackParticipantId?: string | null
    status?: $Enums.TournamentMatchStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    gameId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tournament_matchesUpdateWithoutWhiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumTournamentMatchStatusFieldUpdateOperationsInput | $Enums.TournamentMatchStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: tournamentsUpdateOneRequiredWithoutMatchesNestedInput
    black?: tournament_participantsUpdateOneWithoutBlackMatchesNestedInput
    winner?: tournament_participantsUpdateOneWithoutWonMatchesNestedInput
    game?: gamesUpdateOneWithoutTournamentMatchNestedInput
  }

  export type tournament_matchesUncheckedUpdateWithoutWhiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    blackParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTournamentMatchStatusFieldUpdateOperationsInput | $Enums.TournamentMatchStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournament_matchesUncheckedUpdateManyWithoutWhiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    blackParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTournamentMatchStatusFieldUpdateOperationsInput | $Enums.TournamentMatchStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournament_matchesUpdateWithoutBlackInput = {
    id?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumTournamentMatchStatusFieldUpdateOperationsInput | $Enums.TournamentMatchStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: tournamentsUpdateOneRequiredWithoutMatchesNestedInput
    white?: tournament_participantsUpdateOneWithoutWhiteMatchesNestedInput
    winner?: tournament_participantsUpdateOneWithoutWonMatchesNestedInput
    game?: gamesUpdateOneWithoutTournamentMatchNestedInput
  }

  export type tournament_matchesUncheckedUpdateWithoutBlackInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    whiteParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTournamentMatchStatusFieldUpdateOperationsInput | $Enums.TournamentMatchStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournament_matchesUncheckedUpdateManyWithoutBlackInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    whiteParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTournamentMatchStatusFieldUpdateOperationsInput | $Enums.TournamentMatchStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournament_matchesUpdateWithoutWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumTournamentMatchStatusFieldUpdateOperationsInput | $Enums.TournamentMatchStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: tournamentsUpdateOneRequiredWithoutMatchesNestedInput
    white?: tournament_participantsUpdateOneWithoutWhiteMatchesNestedInput
    black?: tournament_participantsUpdateOneWithoutBlackMatchesNestedInput
    game?: gamesUpdateOneWithoutTournamentMatchNestedInput
  }

  export type tournament_matchesUncheckedUpdateWithoutWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    whiteParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    blackParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTournamentMatchStatusFieldUpdateOperationsInput | $Enums.TournamentMatchStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournament_matchesUncheckedUpdateManyWithoutWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    whiteParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    blackParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTournamentMatchStatusFieldUpdateOperationsInput | $Enums.TournamentMatchStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type gamesCreateManyTournamentInput = {
    id: string
    whitePlayerId: string
    blackPlayerId?: string | null
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
  }

  export type tournament_participantsCreateManyTournamentsInput = {
    id: string
    user_id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
  }

  export type tournament_matchesCreateManyTournamentInput = {
    id?: string
    round: number
    matchNumber: number
    whiteParticipantId?: string | null
    blackParticipantId?: string | null
    winnerParticipantId?: string | null
    status?: $Enums.TournamentMatchStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    gameId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type gamesUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUpdateManyWithoutGameNestedInput
    gameMoves?: game_movesUpdateManyWithoutGameNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutGameNestedInput
    whitePlayer?: usersUpdateOneRequiredWithoutWhiteGamesNestedInput
    blackPlayer?: usersUpdateOneWithoutBlackGamesNestedInput
    match?: matchesUpdateOneWithoutGameNestedInput
    tournamentMatch?: tournament_matchesUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUpdateManyWithoutGameNestedInput
    events?: GameEventUpdateManyWithoutGameNestedInput
  }

  export type gamesUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    whitePlayerId?: StringFieldUpdateOperationsInput | string
    blackPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutGameNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutGameNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutGameNestedInput
    match?: matchesUncheckedUpdateOneWithoutGameNestedInput
    tournamentMatch?: tournament_matchesUncheckedUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    events?: GameEventUncheckedUpdateManyWithoutGameNestedInput
  }

  export type gamesUncheckedUpdateManyWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    whitePlayerId?: StringFieldUpdateOperationsInput | string
    blackPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
  }

  export type tournament_participantsUpdateWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutTournamentParticipantsNestedInput
    whiteMatches?: tournament_matchesUpdateManyWithoutWhiteNestedInput
    blackMatches?: tournament_matchesUpdateManyWithoutBlackNestedInput
    wonMatches?: tournament_matchesUpdateManyWithoutWinnerNestedInput
  }

  export type tournament_participantsUncheckedUpdateWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whiteMatches?: tournament_matchesUncheckedUpdateManyWithoutWhiteNestedInput
    blackMatches?: tournament_matchesUncheckedUpdateManyWithoutBlackNestedInput
    wonMatches?: tournament_matchesUncheckedUpdateManyWithoutWinnerNestedInput
  }

  export type tournament_participantsUncheckedUpdateManyWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tournament_matchesUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumTournamentMatchStatusFieldUpdateOperationsInput | $Enums.TournamentMatchStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    white?: tournament_participantsUpdateOneWithoutWhiteMatchesNestedInput
    black?: tournament_participantsUpdateOneWithoutBlackMatchesNestedInput
    winner?: tournament_participantsUpdateOneWithoutWonMatchesNestedInput
    game?: gamesUpdateOneWithoutTournamentMatchNestedInput
  }

  export type tournament_matchesUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    whiteParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    blackParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTournamentMatchStatusFieldUpdateOperationsInput | $Enums.TournamentMatchStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournament_matchesUncheckedUpdateManyWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    matchNumber?: IntFieldUpdateOperationsInput | number
    whiteParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    blackParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerParticipantId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTournamentMatchStatusFieldUpdateOperationsInput | $Enums.TournamentMatchStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesCreateManyGameInput = {
    id: string
    userId?: string | null
    message: string
    messageType?: $Enums.MessageType
    createdAt?: Date | string
  }

  export type game_movesCreateManyGameInput = {
    id: string
    userId?: string | null
    player: $Enums.Player
    dice?: game_movesCreatediceInput | number[]
    move: string
    fromPoint?: number | null
    toPoint?: number | null
    equity?: number | null
    pr?: number | null
    thinkingTime?: number | null
    createdAt?: Date | string
  }

  export type websocket_connectionsCreateManyGameInput = {
    id: string
    connectionId: string
    userId: string
    connectedAt?: Date | string
    lastPing?: Date | string
    isActive?: boolean
  }

  export type GameSessionCreateManyGameInput = {
    id?: string
    userId: string
    resumeTokenHash: string
    lastAckSequence?: number
    lastHeartbeatAt?: Date | string | null
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GameEventCreateManyGameInput = {
    id?: string
    sequence: number
    type: string
    payload: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type chat_messagesUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneWithoutChatMessagesNestedInput
  }

  export type chat_messagesUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_movesUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    fromPoint?: NullableIntFieldUpdateOperationsInput | number | null
    toPoint?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinkingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneWithoutGameMovesNestedInput
  }

  export type game_movesUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    fromPoint?: NullableIntFieldUpdateOperationsInput | number | null
    toPoint?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinkingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_movesUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    fromPoint?: NullableIntFieldUpdateOperationsInput | number | null
    toPoint?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinkingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type websocket_connectionsUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionId?: StringFieldUpdateOperationsInput | string
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPing?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: usersUpdateOneRequiredWithoutWebsocketConnectionsNestedInput
  }

  export type websocket_connectionsUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPing?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type websocket_connectionsUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPing?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GameSessionUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeTokenHash?: StringFieldUpdateOperationsInput | string
    lastAckSequence?: IntFieldUpdateOperationsInput | number
    lastHeartbeatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutGameSessionsNestedInput
  }

  export type GameSessionUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeTokenHash?: StringFieldUpdateOperationsInput | string
    lastAckSequence?: IntFieldUpdateOperationsInput | number
    lastHeartbeatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeTokenHash?: StringFieldUpdateOperationsInput | string
    lastAckSequence?: IntFieldUpdateOperationsInput | number
    lastHeartbeatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameEventUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameEventUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameEventUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analysesCreateManyUserInput = {
    id: string
    boardState: string
    dice?: analysesCreatediceInput | number[]
    move: string
    bestMove: string
    equity: number
    pr: number
    explanation: string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysisType?: $Enums.AnalysisType
    createdAt?: Date | string
  }

  export type AnalysisQuotaCreateManyUserInput = {
    id?: string
    date: Date | string
    count: number
    extraQuota?: number
    initialFree?: boolean
  }

  export type UserSessionCreateManyUserInput = {
    id?: string
    tokenHash: string
    jti: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type chat_messagesCreateManyUserInput = {
    id: string
    gameId: string
    message: string
    messageType?: $Enums.MessageType
    createdAt?: Date | string
  }

  export type game_movesCreateManyUserInput = {
    id: string
    gameId: string
    player: $Enums.Player
    dice?: game_movesCreatediceInput | number[]
    move: string
    fromPoint?: number | null
    toPoint?: number | null
    equity?: number | null
    pr?: number | null
    thinkingTime?: number | null
    createdAt?: Date | string
  }

  export type user_analyticsCreateManyUsersInput = {
    id: string
    date?: Date | string
    games_played?: number
    games_won?: number
    analyses_completed?: number
    time_played?: number
    avg_equity?: number
    elo_change?: number
    claude_requests_today?: number
    claude_requests_this_month?: number
    claude_quota_remaining?: number
    chatgpt_requests_today?: number
    chatgpt_requests_this_month?: number
    gurubot_requests_today?: number
    gurubot_requests_this_month?: number
    gurubot_quota_remaining?: number
    easybot_requests_today?: number
    createdAt?: Date | string
  }

  export type game_analysesCreateManyUsersInput = {
    id?: string
    game_id: string
    analysis_report: JsonNullValueInput | InputJsonValue
    ai_services_used?: game_analysesCreateai_services_usedInput | string[]
    created_at?: Date | string
  }

  export type tournament_participantsCreateManyUsersInput = {
    id: string
    tournament_id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
  }

  export type tournamentsCreateManyCreatorInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
  }

  export type websocket_connectionsCreateManyUserInput = {
    id: string
    connectionId: string
    gameId?: string | null
    connectedAt?: Date | string
    lastPing?: Date | string
    isActive?: boolean
  }

  export type gamesCreateManyWhitePlayerInput = {
    id: string
    blackPlayerId?: string | null
    tournamentId?: string | null
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
  }

  export type gamesCreateManyBlackPlayerInput = {
    id: string
    whitePlayerId: string
    tournamentId?: string | null
    gameMode?: $Enums.GameMode
    status?: $Enums.GameStatus
    stake?: number
    winner?: $Enums.Player | null
    drawOfferedBy?: $Enums.Player | null
    whiteScore?: number
    blackScore?: number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    cubeLevel?: number
    cubeOwner?: $Enums.Player | null
    matchLength?: number | null
    doubleOfferedBy?: string | null
    doublePending?: boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: $Enums.TimeControlPreset | null
    timeControlTotalMs?: number | null
    timeControlIncrementMs?: number | null
    timeControlDelayMs?: number | null
    whiteTimeRemainingMs?: number | null
    blackTimeRemainingMs?: number | null
    activeTimer?: $Enums.Player | null
    timerUpdatedAt?: Date | string | null
    createdAt?: Date | string
    finishedAt?: Date | string | null
    updatedAt?: Date | string
    resignationType?: $Enums.ResignationType | null
  }

  export type GameSessionCreateManyUserInput = {
    id?: string
    gameId: string
    resumeTokenHash: string
    lastAckSequence?: number
    lastHeartbeatAt?: Date | string | null
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type user_season_statsCreateManyUserInput = {
    id?: string
    seasonId: string
    elo: number
    winrate: number
    gamesPlayed: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type season_leaderboardCreateManyUserInput = {
    id?: string
    seasonId: string
    rankGlobal: number
    rankCountry: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_quota_historyCreateManyUserInput = {
    id?: string
    seasonId: string
    quotaUsed: number
    timestamp?: Date | string
  }

  export type analysesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardState?: StringFieldUpdateOperationsInput | string
    dice?: analysesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    bestMove?: StringFieldUpdateOperationsInput | string
    equity?: FloatFieldUpdateOperationsInput | number
    pr?: FloatFieldUpdateOperationsInput | number
    explanation?: StringFieldUpdateOperationsInput | string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analysesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardState?: StringFieldUpdateOperationsInput | string
    dice?: analysesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    bestMove?: StringFieldUpdateOperationsInput | string
    equity?: FloatFieldUpdateOperationsInput | number
    pr?: FloatFieldUpdateOperationsInput | number
    explanation?: StringFieldUpdateOperationsInput | string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analysesUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardState?: StringFieldUpdateOperationsInput | string
    dice?: analysesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    bestMove?: StringFieldUpdateOperationsInput | string
    equity?: FloatFieldUpdateOperationsInput | number
    pr?: FloatFieldUpdateOperationsInput | number
    explanation?: StringFieldUpdateOperationsInput | string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisQuotaUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    extraQuota?: IntFieldUpdateOperationsInput | number
    initialFree?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnalysisQuotaUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    extraQuota?: IntFieldUpdateOperationsInput | number
    initialFree?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnalysisQuotaUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    extraQuota?: IntFieldUpdateOperationsInput | number
    initialFree?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: gamesUpdateOneRequiredWithoutChatMessagesNestedInput
  }

  export type chat_messagesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_movesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    fromPoint?: NullableIntFieldUpdateOperationsInput | number | null
    toPoint?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinkingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: gamesUpdateOneRequiredWithoutGameMovesNestedInput
  }

  export type game_movesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    fromPoint?: NullableIntFieldUpdateOperationsInput | number | null
    toPoint?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinkingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_movesUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    fromPoint?: NullableIntFieldUpdateOperationsInput | number | null
    toPoint?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinkingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_analyticsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    games_played?: IntFieldUpdateOperationsInput | number
    games_won?: IntFieldUpdateOperationsInput | number
    analyses_completed?: IntFieldUpdateOperationsInput | number
    time_played?: IntFieldUpdateOperationsInput | number
    avg_equity?: FloatFieldUpdateOperationsInput | number
    elo_change?: IntFieldUpdateOperationsInput | number
    claude_requests_today?: IntFieldUpdateOperationsInput | number
    claude_requests_this_month?: IntFieldUpdateOperationsInput | number
    claude_quota_remaining?: IntFieldUpdateOperationsInput | number
    chatgpt_requests_today?: IntFieldUpdateOperationsInput | number
    chatgpt_requests_this_month?: IntFieldUpdateOperationsInput | number
    gurubot_requests_today?: IntFieldUpdateOperationsInput | number
    gurubot_requests_this_month?: IntFieldUpdateOperationsInput | number
    gurubot_quota_remaining?: IntFieldUpdateOperationsInput | number
    easybot_requests_today?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_analyticsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    games_played?: IntFieldUpdateOperationsInput | number
    games_won?: IntFieldUpdateOperationsInput | number
    analyses_completed?: IntFieldUpdateOperationsInput | number
    time_played?: IntFieldUpdateOperationsInput | number
    avg_equity?: FloatFieldUpdateOperationsInput | number
    elo_change?: IntFieldUpdateOperationsInput | number
    claude_requests_today?: IntFieldUpdateOperationsInput | number
    claude_requests_this_month?: IntFieldUpdateOperationsInput | number
    claude_quota_remaining?: IntFieldUpdateOperationsInput | number
    chatgpt_requests_today?: IntFieldUpdateOperationsInput | number
    chatgpt_requests_this_month?: IntFieldUpdateOperationsInput | number
    gurubot_requests_today?: IntFieldUpdateOperationsInput | number
    gurubot_requests_this_month?: IntFieldUpdateOperationsInput | number
    gurubot_quota_remaining?: IntFieldUpdateOperationsInput | number
    easybot_requests_today?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_analyticsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    games_played?: IntFieldUpdateOperationsInput | number
    games_won?: IntFieldUpdateOperationsInput | number
    analyses_completed?: IntFieldUpdateOperationsInput | number
    time_played?: IntFieldUpdateOperationsInput | number
    avg_equity?: FloatFieldUpdateOperationsInput | number
    elo_change?: IntFieldUpdateOperationsInput | number
    claude_requests_today?: IntFieldUpdateOperationsInput | number
    claude_requests_this_month?: IntFieldUpdateOperationsInput | number
    claude_quota_remaining?: IntFieldUpdateOperationsInput | number
    chatgpt_requests_today?: IntFieldUpdateOperationsInput | number
    chatgpt_requests_this_month?: IntFieldUpdateOperationsInput | number
    gurubot_requests_today?: IntFieldUpdateOperationsInput | number
    gurubot_requests_this_month?: IntFieldUpdateOperationsInput | number
    gurubot_quota_remaining?: IntFieldUpdateOperationsInput | number
    easybot_requests_today?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_analysesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    game_id?: StringFieldUpdateOperationsInput | string
    analysis_report?: JsonNullValueInput | InputJsonValue
    ai_services_used?: game_analysesUpdateai_services_usedInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_analysesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    game_id?: StringFieldUpdateOperationsInput | string
    analysis_report?: JsonNullValueInput | InputJsonValue
    ai_services_used?: game_analysesUpdateai_services_usedInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_analysesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    game_id?: StringFieldUpdateOperationsInput | string
    analysis_report?: JsonNullValueInput | InputJsonValue
    ai_services_used?: game_analysesUpdateai_services_usedInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournament_participantsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tournaments?: tournamentsUpdateOneRequiredWithoutParticipantsNestedInput
    whiteMatches?: tournament_matchesUpdateManyWithoutWhiteNestedInput
    blackMatches?: tournament_matchesUpdateManyWithoutBlackNestedInput
    wonMatches?: tournament_matchesUpdateManyWithoutWinnerNestedInput
  }

  export type tournament_participantsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournament_id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whiteMatches?: tournament_matchesUncheckedUpdateManyWithoutWhiteNestedInput
    blackMatches?: tournament_matchesUncheckedUpdateManyWithoutBlackNestedInput
    wonMatches?: tournament_matchesUncheckedUpdateManyWithoutWinnerNestedInput
  }

  export type tournament_participantsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournament_id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tournamentsUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: gamesUpdateManyWithoutTournamentNestedInput
    participants?: tournament_participantsUpdateManyWithoutTournamentsNestedInput
    matches?: tournament_matchesUpdateManyWithoutTournamentNestedInput
  }

  export type tournamentsUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: gamesUncheckedUpdateManyWithoutTournamentNestedInput
    participants?: tournament_participantsUncheckedUpdateManyWithoutTournamentsNestedInput
    matches?: tournament_matchesUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type tournamentsUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type websocket_connectionsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionId?: StringFieldUpdateOperationsInput | string
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPing?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    game?: gamesUpdateOneWithoutWebsocketConnectionsNestedInput
  }

  export type websocket_connectionsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionId?: StringFieldUpdateOperationsInput | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPing?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type websocket_connectionsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionId?: StringFieldUpdateOperationsInput | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPing?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type gamesUpdateWithoutWhitePlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUpdateManyWithoutGameNestedInput
    gameMoves?: game_movesUpdateManyWithoutGameNestedInput
    tournament?: tournamentsUpdateOneWithoutGamesNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutGameNestedInput
    blackPlayer?: usersUpdateOneWithoutBlackGamesNestedInput
    match?: matchesUpdateOneWithoutGameNestedInput
    tournamentMatch?: tournament_matchesUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUpdateManyWithoutGameNestedInput
    events?: GameEventUpdateManyWithoutGameNestedInput
  }

  export type gamesUncheckedUpdateWithoutWhitePlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    blackPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutGameNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutGameNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutGameNestedInput
    match?: matchesUncheckedUpdateOneWithoutGameNestedInput
    tournamentMatch?: tournament_matchesUncheckedUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    events?: GameEventUncheckedUpdateManyWithoutGameNestedInput
  }

  export type gamesUncheckedUpdateManyWithoutWhitePlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    blackPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
  }

  export type gamesUpdateWithoutBlackPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUpdateManyWithoutGameNestedInput
    gameMoves?: game_movesUpdateManyWithoutGameNestedInput
    tournament?: tournamentsUpdateOneWithoutGamesNestedInput
    websocketConnections?: websocket_connectionsUpdateManyWithoutGameNestedInput
    whitePlayer?: usersUpdateOneRequiredWithoutWhiteGamesNestedInput
    match?: matchesUpdateOneWithoutGameNestedInput
    tournamentMatch?: tournament_matchesUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUpdateManyWithoutGameNestedInput
    events?: GameEventUpdateManyWithoutGameNestedInput
  }

  export type gamesUncheckedUpdateWithoutBlackPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    whitePlayerId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
    chatMessages?: chat_messagesUncheckedUpdateManyWithoutGameNestedInput
    gameMoves?: game_movesUncheckedUpdateManyWithoutGameNestedInput
    websocketConnections?: websocket_connectionsUncheckedUpdateManyWithoutGameNestedInput
    match?: matchesUncheckedUpdateOneWithoutGameNestedInput
    tournamentMatch?: tournament_matchesUncheckedUpdateOneWithoutGameNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    events?: GameEventUncheckedUpdateManyWithoutGameNestedInput
  }

  export type gamesUncheckedUpdateManyWithoutBlackPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    whitePlayerId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    stake?: IntFieldUpdateOperationsInput | number
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    drawOfferedBy?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    whiteScore?: IntFieldUpdateOperationsInput | number
    blackScore?: IntFieldUpdateOperationsInput | number
    boardState?: JsonNullValueInput | InputJsonValue
    currentPlayer?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    cubeLevel?: IntFieldUpdateOperationsInput | number
    cubeOwner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    matchLength?: NullableIntFieldUpdateOperationsInput | number | null
    doubleOfferedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doublePending?: BoolFieldUpdateOperationsInput | boolean
    cubeHistory?: JsonNullValueInput | InputJsonValue
    timeControlPreset?: NullableEnumTimeControlPresetFieldUpdateOperationsInput | $Enums.TimeControlPreset | null
    timeControlTotalMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlIncrementMs?: NullableIntFieldUpdateOperationsInput | number | null
    timeControlDelayMs?: NullableIntFieldUpdateOperationsInput | number | null
    whiteTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    blackTimeRemainingMs?: NullableIntFieldUpdateOperationsInput | number | null
    activeTimer?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    timerUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resignationType?: NullableEnumResignationTypeFieldUpdateOperationsInput | $Enums.ResignationType | null
  }

  export type GameSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeTokenHash?: StringFieldUpdateOperationsInput | string
    lastAckSequence?: IntFieldUpdateOperationsInput | number
    lastHeartbeatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: gamesUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type GameSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    resumeTokenHash?: StringFieldUpdateOperationsInput | string
    lastAckSequence?: IntFieldUpdateOperationsInput | number
    lastHeartbeatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    resumeTokenHash?: StringFieldUpdateOperationsInput | string
    lastAckSequence?: IntFieldUpdateOperationsInput | number
    lastHeartbeatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_season_statsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    elo?: IntFieldUpdateOperationsInput | number
    winrate?: FloatFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: seasonsUpdateOneRequiredWithoutSeasonStatsNestedInput
  }

  export type user_season_statsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    elo?: IntFieldUpdateOperationsInput | number
    winrate?: FloatFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_season_statsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    elo?: IntFieldUpdateOperationsInput | number
    winrate?: FloatFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type season_leaderboardUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rankGlobal?: IntFieldUpdateOperationsInput | number
    rankCountry?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: seasonsUpdateOneRequiredWithoutLeaderboardsNestedInput
  }

  export type season_leaderboardUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    rankGlobal?: IntFieldUpdateOperationsInput | number
    rankCountry?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type season_leaderboardUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    rankGlobal?: IntFieldUpdateOperationsInput | number
    rankCountry?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_quota_historyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotaUsed?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: seasonsUpdateOneRequiredWithoutQuotaHistoryNestedInput
  }

  export type user_quota_historyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    quotaUsed?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_quota_historyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    quotaUsed?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_season_statsCreateManySeasonInput = {
    id?: string
    userId: string
    elo: number
    winrate: number
    gamesPlayed: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type season_leaderboardCreateManySeasonInput = {
    id?: string
    userId: string
    rankGlobal: number
    rankCountry: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_quota_historyCreateManySeasonInput = {
    id?: string
    userId: string
    quotaUsed: number
    timestamp?: Date | string
  }

  export type user_season_statsUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    elo?: IntFieldUpdateOperationsInput | number
    winrate?: FloatFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutSeasonStatsNestedInput
  }

  export type user_season_statsUncheckedUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    elo?: IntFieldUpdateOperationsInput | number
    winrate?: FloatFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_season_statsUncheckedUpdateManyWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    elo?: IntFieldUpdateOperationsInput | number
    winrate?: FloatFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type season_leaderboardUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    rankGlobal?: IntFieldUpdateOperationsInput | number
    rankCountry?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutSeasonLeaderboardsNestedInput
  }

  export type season_leaderboardUncheckedUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rankGlobal?: IntFieldUpdateOperationsInput | number
    rankCountry?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type season_leaderboardUncheckedUpdateManyWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rankGlobal?: IntFieldUpdateOperationsInput | number
    rankCountry?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_quota_historyUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotaUsed?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutQuotaHistoryNestedInput
  }

  export type user_quota_historyUncheckedUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    quotaUsed?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_quota_historyUncheckedUpdateManyWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    quotaUsed?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use Tournament_participantsCountOutputTypeDefaultArgs instead
     */
    export type Tournament_participantsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tournament_participantsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TournamentsCountOutputTypeDefaultArgs instead
     */
    export type TournamentsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TournamentsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GamesCountOutputTypeDefaultArgs instead
     */
    export type GamesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GamesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeasonsCountOutputTypeDefaultArgs instead
     */
    export type SeasonsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeasonsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use analysesDefaultArgs instead
     */
    export type analysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = analysesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnalysisQuotaDefaultArgs instead
     */
    export type AnalysisQuotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnalysisQuotaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IAQuotaDefaultArgs instead
     */
    export type IAQuotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IAQuotaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSessionDefaultArgs instead
     */
    export type UserSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use chat_messagesDefaultArgs instead
     */
    export type chat_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = chat_messagesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use game_movesDefaultArgs instead
     */
    export type game_movesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = game_movesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use subscriptionsDefaultArgs instead
     */
    export type subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = subscriptionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tournament_participantsDefaultArgs instead
     */
    export type tournament_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tournament_participantsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tournament_matchesDefaultArgs instead
     */
    export type tournament_matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tournament_matchesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tournamentsDefaultArgs instead
     */
    export type tournamentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tournamentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_analyticsDefaultArgs instead
     */
    export type user_analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_analyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use game_analysesDefaultArgs instead
     */
    export type game_analysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = game_analysesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use gamesDefaultArgs instead
     */
    export type gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = gamesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameSessionDefaultArgs instead
     */
    export type GameSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameEventDefaultArgs instead
     */
    export type GameEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use matchesDefaultArgs instead
     */
    export type matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = matchesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_learning_progressDefaultArgs instead
     */
    export type user_learning_progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_learning_progressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_achievementsDefaultArgs instead
     */
    export type user_achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_achievementsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_preferencesDefaultArgs instead
     */
    export type user_preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_preferencesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use seasonsDefaultArgs instead
     */
    export type seasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = seasonsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_season_statsDefaultArgs instead
     */
    export type user_season_statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_season_statsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use season_leaderboardDefaultArgs instead
     */
    export type season_leaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = season_leaderboardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_quota_historyDefaultArgs instead
     */
    export type user_quota_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_quota_historyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use websocket_connectionsDefaultArgs instead
     */
    export type websocket_connectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = websocket_connectionsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}